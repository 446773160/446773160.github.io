<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山不让尘，川不辞盈</title>
  
  <subtitle>山不让尘，川不辞盈</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-02T06:57:01.774Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>山不让尘，川不辞盈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis学习</title>
    <link href="http://example.com/2022/12/01/Redis%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2022/12/01/Redis%E5%BA%94%E7%94%A8/</id>
    <published>2022-12-01T08:30:00.000Z</published>
    <updated>2022-12-02T06:57:01.774Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PS：Linux启动redis</strong></p><p>sudo service redis-server start</p><p>redis-cli</p><h1 id="Redis是什么？what？"><a href="#Redis是什么？what？" class="headerlink" title="Redis是什么？what？"></a>Redis是什么？what？</h1><p>Redis（Remote Dictionary Server )，即远程字典服务 !<br>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。<br>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！<br>Redis能干嘛？<br>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） 2、效率高，可以用于高速缓存<br>3、发布订阅系统<br>4、地图信息分析<br>5、计时器、计数器（浏览量！）<br>6、…</p><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span>  #查看当前连接是否正常，正常返回PONG</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; clear  #清楚当前控制台（为了更好的看到下面输入的命令）</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *  #查看当前库里所有的key</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; flushall  #清空所有库的内容</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *  #查看所以的key</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name didadida  #设置key value键值对</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name #获取键值</span><br><span class="line">&quot;didadida&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exists name  #判断当前key是否存在</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">move</span> name <span class="number">1</span>  #移除当前库<span class="number">1</span>的key为‘name‘的数据 成功返回<span class="number">1</span>不成功返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; flushall  #再次清空所有库的内容</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; expire name <span class="number">15</span>  #设置key为’name‘的数据过期时间为<span class="number">15</span>秒 单位seconds</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name  #查看当前key为’name‘的剩余生命周期时间</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> name</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h1 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h1><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><h3 id="创建、添加、查询、追加、获取长度，判断是否存在的操作"><a href="#创建、添加、查询、追加、获取长度，判断是否存在的操作" class="headerlink" title="创建、添加、查询、追加、获取长度，判断是否存在的操作"></a>创建、添加、查询、追加、获取长度，判断是否存在的操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name didadida</span><br><span class="line">OK</span><br><span class="line">#查询</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line">&quot;didadida&quot;</span><br><span class="line">#添加</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">append</span> name hello #返回添加之后的字符串长度</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exists name  #判断key为‘name’的数据存在不存在，存在返回<span class="number">1</span> ，不存在返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; strlen name  #获取字符串长度</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key1 &quot;hello world!&quot;  #注意点：插入的数据中如果有空格的数据，请用“”双引号，否则会报错！</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key1 hello world!  #报错，因为在Redis中空格就是分隔符，相当于该参数已结束</span><br><span class="line">(error) ERR syntax error</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key1 hello,world!  #逗号是可以的</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="自增自减操作"><a href="#自增自减操作" class="headerlink" title="自增自减操作"></a>自增自减操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> num <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get num</span><br><span class="line">&quot;<span class="number">0</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; incr num #指定key为‘num’的数据自增<span class="number">1</span>，返回结果  相当于java中 i++</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get num #一般用来做文章浏览量、点赞数、收藏数等功能</span><br><span class="line">&quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; decr num  #指定key为‘num’的数据自减<span class="number">1</span>，返回结果  相当于java中 i--</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; decr num ##可以一直减为负数~ 一般用来做文章取消点赞、取消收藏等功能</span><br><span class="line">(integer) -<span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; incrby num <span class="number">10</span> #后面跟上by  指定key为‘num’的数据自增‘参数（<span class="number">10</span>）’，返回结果</span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; decrby num <span class="number">10</span> #后面跟上by  指定key为‘num’的数据自减‘参数（<span class="number">10</span>）’，返回结果</span><br><span class="line">(integer) -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="截取、替换字符串操作"><a href="#截取、替换字符串操作" class="headerlink" title="截取、替换字符串操作"></a>截取、替换字符串操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getrange name <span class="number">0</span> <span class="number">4</span> #截取字符串，相当于java中的subString，下标从<span class="number">0</span>开始，不会改变原有数据 下标是左闭右闭</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getrange name <span class="number">0</span> -<span class="number">1</span> #倒数第一个数据下标是-<span class="number">1</span>，倒数第二个是-<span class="number">2</span>依次类推</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setrange name <span class="number">5</span> <span class="number">666</span>  #此语句跟java中<span class="built_in">replace</span>有点类似，下标也是从<span class="number">0</span>开始，但是有区别：java中是指定替换字符，Redis中是从指定位置开始替换，替换的数据根据你所需替换的长度一致，返回值是替换后的长度</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line">&quot;hello666world&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SETRANGE name <span class="number">5</span> <span class="number">67</span> ##该处只替换了两位</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line">&quot;hello676world&quot;</span><br></pre></td></tr></table></figure><h3 id="设置过期时间、不存在设置操作"><a href="#设置过期时间、不存在设置操作" class="headerlink" title="设置过期时间、不存在设置操作"></a>设置过期时间、不存在设置操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#设置过期时间，跟Expire的区别是前者设置已存在的key的过期时间，而setex是在创建的时候设置过期时间</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setex name <span class="number">15</span> hello #新建一个key为‘name’，值为‘hello’，过期时间为<span class="number">15</span>秒的字符串数据</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name #利用ttl查看剩余时间</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl name #返回-<span class="number">2</span>表示不存在已经过期了</span><br><span class="line">(integer) -<span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setnx name hello #如果key为‘name’不存在，新增数据，返回值<span class="number">1</span>证明成功</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setnx name world  #如果key为‘name’的已存在，设置失败，返回值<span class="number">0</span>，也就是说这个跟<span class="built_in">set</span>的区别是：<span class="built_in">set</span>会替换原有的值，而setnx不会，存在即不设置，确保了数据误操作~</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="插入多条数据（mset、mget）操作"><a href="#插入多条数据（mset、mget）操作" class="headerlink" title="插入多条数据（mset、mget）操作"></a>插入多条数据（mset、mget）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; mset k1 v1 k2 v2 k3 v3 #插入多条数据</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * #查询所有key值</span><br><span class="line"><span class="number">1</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; mget k1 k2 k3  #查询key为‘k1’，‘k2’，‘k3’的数据</span><br><span class="line"><span class="number">1</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; msetnx k1 v1 k4 v4  #msetnx是一个原子性的操作，在一定程度上保证了事务！要么都成功，要么都失败！相当于<span class="keyword">if</span>中的条件&amp;&amp;（与）  由于里面已经有k1所有插入失败</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; msetnx k4 v4 k5 v5 #全部成功</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">4</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">5</span>) &quot;k5&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="添加获取对象、get-set操作"><a href="#添加获取对象、get-set操作" class="headerlink" title="添加获取对象、get set操作"></a>添加获取对象、get set操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#这里其实本质上还是字符串，但是我们讲其key巧妙的设计了一下。</span><br><span class="line">#mset student:<span class="number">1</span>:name  student 相当于类名，<span class="number">1</span> 相当于id，name 相当于属性</span><br><span class="line">#如果所需数据全部这样设计，那么我们在java的业务代码中，就不需要关注太多的key</span><br><span class="line">#只需要找到student类，下面哪个id，需要哪个属性即可，减少了代码的繁琐，在一定程度上可以理解为这个一个类的对象！</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; mset student:<span class="number">1</span>:name liao.sc student:<span class="number">1</span>:age <span class="number">18</span>  #新增一个key为‘student:<span class="number">1</span>:name’，value为‘liao.sc ’等等</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * #获取所有键值</span><br><span class="line"><span class="number">1</span>) &quot;student:<span class="number">1</span>:age&quot;</span><br><span class="line"><span class="number">2</span>) &quot;student:<span class="number">1</span>:name&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; mget student:<span class="number">1</span>:age student:<span class="number">1</span>:name #获取所有value</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">18</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;liao.sc&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getset name hello #先get再<span class="built_in">set</span>，先获取key，如果没有，<span class="built_in">set</span>值进去，返回的是get的值</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name #获取name的值</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getset name world #先获取key，如果有，<span class="built_in">set</span>（替换）最新的值进去，返回的是get的值</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name #替换成功</span><br><span class="line">&quot;world&quot;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><em>String是Redis中最常用的一种数据类型，也是Redis中最简单的一种数据类型。首先，表面上它是字符串，但其实他可以灵活的表示字符串、整数、浮点数3种值。Redis会自动的识别这3种值。</em></p><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><h3 id="lpush（左插入）、lrange（查询集合）、rpush（右插入）操作"><a href="#lpush（左插入）、lrange（查询集合）、rpush（右插入）操作" class="headerlink" title="lpush（左插入）、lrange（查询集合）、rpush（右插入）操作"></a>lpush（左插入）、lrange（查询集合）、rpush（右插入）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpush list v1  #左插入,如果没有会新建一个集合</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查询集合所有数据，-<span class="number">1</span>表示最后一个元素，-<span class="number">2</span>表示倒数第二个元素</span><br><span class="line"><span class="number">1</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpush  list v1 v2 v3 v4 v5 #批量添加元素</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看所有元素</span><br><span class="line"><span class="number">1</span>) &quot;v5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">5</span>) &quot;v1&quot;</span><br><span class="line">#这里大家有没有注意到，先进去的会到后面，也就是我们的lpush的意思是左插入，l--left</span><br><span class="line">#rpush和lpush相似属于右插入这边不过多赘述</span><br></pre></td></tr></table></figure><h3 id="lpop（左移除）、rpop（右移除）操作"><a href="#lpop（左移除）、rpop（右移除）操作" class="headerlink" title="lpop（左移除）、rpop（右移除）操作"></a>lpop（左移除）、rpop（右移除）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpop list #从左边第一个开始移除</span><br><span class="line">&quot;v5&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看全部数据</span><br><span class="line"><span class="number">1</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; rpop list #从右边第一个开始移除</span><br><span class="line">&quot;v1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看全部数据</span><br><span class="line"><span class="number">1</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h3 id="lindex（查询指定下标元素）、llen（获取集合长度）-操作"><a href="#lindex（查询指定下标元素）、llen（获取集合长度）-操作" class="headerlink" title="lindex（查询指定下标元素）、llen（获取集合长度） 操作"></a>lindex（查询指定下标元素）、llen（获取集合长度） 操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lindex list <span class="number">1</span> #从左边开始查询下标为<span class="number">1</span>的数据</span><br><span class="line">&quot;v3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; llen list #从左边开始计算集合的长度</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="lrem（根据value移除指定的值）"><a href="#lrem（根据value移除指定的值）" class="headerlink" title="lrem（根据value移除指定的值）"></a>lrem（根据value移除指定的值）</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看集合所有数据</span><br><span class="line"><span class="number">1</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrem list <span class="number">1</span> v3 #移除集合list里面值为v3的元素一个</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrem list <span class="number">0</span> v2 #这里<span class="number">0</span>和<span class="number">1</span>的效果是一样的，移除list集合里面值为v2的元素一个</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt;lpush list  v3 v2 v2 v2 #这里再插入几个元素</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrem list <span class="number">3</span> v2 #这里移除三个v2的元素</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作"><a href="#ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作" class="headerlink" title="ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作"></a>ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpush list1 k1 k2 k3 #新建两个集合</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpush list2 v1 v2 v3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ltrim list1 <span class="number">1</span> <span class="number">2</span> #截取了list1的值此时list1的值已经发生了改变</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list1 <span class="number">0</span> -<span class="number">1</span>#查看list1集合的值</span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; rpoplpush list1 list2 #移除list1集合中的最后一个元素到list2中</span><br><span class="line">&quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list2 <span class="number">0</span> -<span class="number">1</span> #查看list2</span><br><span class="line"><span class="number">1</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list1 <span class="number">0</span> -<span class="number">1</span> #查看list1集合</span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br></pre></td></tr></table></figure><h3 id="lset（更新）、linsert操作"><a href="#lset（更新）、linsert操作" class="headerlink" title="lset（更新）、linsert操作"></a>lset（更新）、linsert操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lpush list k1 k2 k3 #新建一个集合</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lset list -<span class="number">1</span> v1 #更新list集合中最后一个元素是v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看list集合</span><br><span class="line"><span class="number">1</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v1&quot;</span><br><span class="line">##注意点：</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lset list1 <span class="number">0</span> vvvv  #如果指定的‘集合’不存在，报错</span><br><span class="line">(error) ERR no such key</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lset list <span class="number">8</span> vvv  #如果集合存在，但是指定的‘下标’不存在，报错</span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; linsert list after v1 v2 #在集合list中插入v2到v1后面</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; linsert list before v1 v2 #在集合list中插入v2到v1前面</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span> #查看list集合</span><br><span class="line"><span class="number">1</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">5</span>) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>实际上是一个链表，before Node after ， left，right 都可以插入值</li><li>如果key 不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在！</li><li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li><li>消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！</li></ul><h2 id="Set（集合）元素唯一不重复"><a href="#Set（集合）元素唯一不重复" class="headerlink" title="Set（集合）元素唯一不重复"></a>Set（集合）元素唯一不重复</h2><h3 id="sadd（添加）、smembers（查看所有元素）、sismember（判断是否存在）、scard（查看长度）、srem（移除指定元素）操作"><a href="#sadd（添加）、smembers（查看所有元素）、sismember（判断是否存在）、scard（查看长度）、srem（移除指定元素）操作" class="headerlink" title="sadd（添加）、smembers（查看所有元素）、sismember（判断是否存在）、scard（查看长度）、srem（移除指定元素）操作"></a>sadd（添加）、smembers（查看所有元素）、sismember（判断是否存在）、scard（查看长度）、srem（移除指定元素）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; sadd <span class="built_in">set</span> hello world <span class="number">11</span> <span class="number">22</span> #添加<span class="built_in">set</span>集合（可批量可单个，写法一致，不再赘述）</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span> #查看<span class="built_in">set</span>中所有元素</span><br><span class="line"><span class="number">1</span>) &quot;world&quot;</span><br><span class="line"><span class="number">2</span>) &quot;hello&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">11</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">22</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; sismember <span class="built_in">set</span> hello #判断某个值在不在<span class="built_in">set</span>中，在返回<span class="number">1</span>不存在返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; scard <span class="built_in">set</span> #查看集合长度</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; srem <span class="built_in">set</span> <span class="number">22</span> #移除指定元素</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="srandmember（抽随机）操作"><a href="#srandmember（抽随机）操作" class="headerlink" title="srandmember（抽随机）操作"></a>srandmember（抽随机）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span> <span class="number">3</span>#随机查看三个值并且返回</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">7</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; srandmember <span class="built_in">set</span> <span class="number">5</span>#随机查看五个值并且返回</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">7</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;<span class="number">6</span>&quot;</span><br></pre></td></tr></table></figure><h3 id="spop（随机删除元素）、smove（移动指定元素到新的集合中）操作"><a href="#spop（随机删除元素）、smove（移动指定元素到新的集合中）操作" class="headerlink" title="spop（随机删除元素）、smove（移动指定元素到新的集合中）操作"></a>spop（随机删除元素）、smove（移动指定元素到新的集合中）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; spop <span class="built_in">set</span> <span class="number">1</span> #随机删除一个</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; spop <span class="built_in">set</span> <span class="number">3</span> #随机删除三个</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">7</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; smembers <span class="built_in">set</span></span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">6</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; smove <span class="built_in">set</span> myset <span class="number">2</span>  #移动指定<span class="built_in">set</span>中的元素到新的<span class="built_in">set</span>集合中，如果没有则会新建一个</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="sdiff（差集）、sinter（交集）、sunion（并集）操作"><a href="#sdiff（差集）、sinter（交集）、sunion（并集）操作" class="headerlink" title="sdiff（差集）、sinter（交集）、sunion（并集）操作"></a>sdiff（差集）、sinter（交集）、sunion（并集）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; sadd myset1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; sadd myset2 <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SMEMBERS myset1</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SMEMBERS myset2</span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">6</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;<span class="number">7</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SDIFF myset1 myset2  #查询指定的<span class="built_in">set</span>之间的差集，可以是多个<span class="built_in">set</span></span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SINTER myset1 myset2  #查询指定的<span class="built_in">set</span>之间的交集，可以是多个<span class="built_in">set</span></span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; sunion myset1 myset2  #查询指定的<span class="built_in">set</span>之间的并集，可以是多个<span class="built_in">set</span></span><br><span class="line"><span class="number">1</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">4</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;<span class="number">5</span>&quot;</span><br><span class="line"><span class="number">6</span>) &quot;<span class="number">6</span>&quot;</span><br><span class="line"><span class="number">7</span>) &quot;<span class="number">7</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结：可实现共同好友、共同关注等需求。"><a href="#总结：可实现共同好友、共同关注等需求。" class="headerlink" title="总结：可实现共同好友、共同关注等需求。"></a>总结：可实现共同好友、共同关注等需求。</h3><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><h3 id="hset（添加hash）、hget（查询）、hgetall（查询所有）、hdel（删除hash中指定的值）、hlen（获取hash的长度）、hexists（判断key是否存在）操作"><a href="#hset（添加hash）、hget（查询）、hgetall（查询所有）、hdel（删除hash中指定的值）、hlen（获取hash的长度）、hexists（判断key是否存在）操作" class="headerlink" title="hset（添加hash）、hget（查询）、hgetall（查询所有）、hdel（删除hash中指定的值）、hlen（获取hash的长度）、hexists（判断key是否存在）操作"></a>hset（添加hash）、hget（查询）、hgetall（查询所有）、hdel（删除hash中指定的值）、hlen（获取hash的长度）、hexists（判断key是否存在）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hset myhash name liaosc age <span class="number">18</span> #添加hash，可多个</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hget myhash name #获取hash中key是name的值</span><br><span class="line">&quot;liaosc&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hget myhash age #获取hash中key是age的值</span><br><span class="line">&quot;<span class="number">18</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hgetall myhash #获取hash中所有的值，包含key</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;liaosc&quot;</span><br><span class="line"><span class="number">3</span>) &quot;age&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">18</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hdel myhash name age #删除指定hash中的key（可多个），key删除后对应的value也会被删除</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hlen myhash #获取指定hash的长度，相当于length、size</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hexists myhash name #判断key是否存在于指定的hash，存在返回<span class="number">1</span> 不存在返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="hkeys（获取所有key）、hvals（获取所有value）、hincrby（给值加增量）、hsetnx（存在不添加）操作"><a href="#hkeys（获取所有key）、hvals（获取所有value）、hincrby（给值加增量）、hsetnx（存在不添加）操作" class="headerlink" title="hkeys（获取所有key）、hvals（获取所有value）、hincrby（给值加增量）、hsetnx（存在不添加）操作"></a>hkeys（获取所有key）、hvals（获取所有value）、hincrby（给值加增量）、hsetnx（存在不添加）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hkeys myhash #获取所有的key</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;age&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hvals myhash #获取所有的value</span><br><span class="line"><span class="number">1</span>) &quot;liaosc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">18</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hincrby myhash age <span class="number">2</span> #让hash中age的value指定+<span class="number">2</span>(自增)</span><br><span class="line">(integer) <span class="number">20</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hincrby myhash age -<span class="number">1</span> #让hash中age的value指定-<span class="number">1</span>(自减)</span><br><span class="line">(integer) <span class="number">19</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hsetnx myhash nokey novalue  #添加不存在就新增返回新增成功的数量（只能单个增加哦）</span><br><span class="line">(integer) <span class="number">1</span> </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hsetnx myhash name miaotiao  #添加存在则失败返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; hgetall myhash #获取所有值</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;liaosc&quot;</span><br><span class="line"><span class="number">3</span>) &quot;age&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">19</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nokey&quot;</span><br><span class="line"><span class="number">6</span>) &quot;novalue&quot;</span><br></pre></td></tr></table></figure><p>总结：比String更加适合存对象~</p><h2 id="zSet（有序集合）"><a href="#zSet（有序集合）" class="headerlink" title="zSet（有序集合）"></a><strong>zSet</strong>（有序集合）</h2><h3 id="zadd（添加）、zrange（查询）、zrangebyscore（排序小-大）、zrevrange（排序大-小）、zrangebyscore-withscores（查询所有值包含key）操作"><a href="#zadd（添加）、zrange（查询）、zrangebyscore（排序小-大）、zrevrange（排序大-小）、zrangebyscore-withscores（查询所有值包含key）操作" class="headerlink" title="zadd（添加）、zrange（查询）、zrangebyscore（排序小-大）、zrevrange（排序大-小）、zrangebyscore withscores（查询所有值包含key）操作"></a>zadd（添加）、zrange（查询）、zrangebyscore（排序小-大）、zrevrange（排序大-小）、zrangebyscore withscores（查询所有值包含key）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> one <span class="number">2</span> two <span class="number">3</span> three  #添加zset值，可多个</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE myzset <span class="number">0</span> -<span class="number">1</span>  #查询所有的值</span><br><span class="line"><span class="number">1</span>) &quot;one&quot;</span><br><span class="line"><span class="number">2</span>) &quot;two&quot;</span><br><span class="line"><span class="number">3</span>) &quot;three&quot;</span><br><span class="line">#-inf 负无穷  +inf 正无穷</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE myzset -inf +inf  #将zset的值根据key来从小到大排序并输出</span><br><span class="line"><span class="number">1</span>) &quot;one&quot;</span><br><span class="line"><span class="number">2</span>) &quot;two&quot;</span><br><span class="line"><span class="number">3</span>) &quot;three&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE myzset <span class="number">0</span> <span class="number">1</span>  #只查询key&lt;=<span class="number">1</span>的值并且排序从小到大</span><br><span class="line"><span class="number">1</span>) &quot;one&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANGE myzset <span class="number">1</span> -<span class="number">1</span>  #从大到小排序输出</span><br><span class="line"><span class="number">1</span>) &quot;two&quot;</span><br><span class="line"><span class="number">2</span>) &quot;one&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE myzset -inf +inf withscores  #查询指定zset的所有值，包含序号的值</span><br><span class="line"><span class="number">1</span>) &quot;one&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;two&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">2</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;three&quot;</span><br><span class="line"><span class="number">6</span>) &quot;<span class="number">3</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="zrem（移除元素）、zcard（查看元素个数）、zcount（查询指定区间内的元素个数）操作"><a href="#zrem（移除元素）、zcard（查看元素个数）、zcount（查询指定区间内的元素个数）操作" class="headerlink" title="zrem（移除元素）、zcard（查看元素个数）、zcount（查询指定区间内的元素个数）操作"></a>zrem（移除元素）、zcard（查看元素个数）、zcount（查询指定区间内的元素个数）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zadd myset <span class="number">1</span> v1 <span class="number">2</span> v2 <span class="number">3</span> v3 <span class="number">4</span> v4</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE myset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zrem myset v3  #移除指定的元素，可多个</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE myset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v4&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zcard myset  #查看zset的元素个数，相当于长度，size。</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zcount myset <span class="number">0</span> <span class="number">100</span>  #查询指定区间内的元素个数</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; zcount myset <span class="number">0</span> <span class="number">2</span>  #查询指定区间内的元素个数</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：成绩表排序，工资表排序，年龄排序等需求可以用zset来实现！</p><h1 id="Redis三种特殊类型"><a href="#Redis三种特殊类型" class="headerlink" title="Redis三种特殊类型"></a>Redis三种特殊类型</h1><h2 id="Geospatial：-地理位置"><a href="#Geospatial：-地理位置" class="headerlink" title="Geospatial： 地理位置"></a>Geospatial： 地理位置</h2><p><strong>城市经纬度查询：</strong> <a href="https://jingweidu.bmcx.com/">经纬度查询</a><br>注意点1：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！<br>注意点2：有效的经度从-180度到180度。<br>注意点3：有效的纬度从-85.05112878度到85.05112878度。<br>注意点4：m 为米。km 为千米。mi 为英里。ft 为英尺。<br>①geoadd（添加）、geopos（查看）、geodist（计算距离）操作</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd city <span class="number">118</span>.<span class="number">8921</span> <span class="number">31</span>.<span class="number">32751</span> nanjing <span class="number">197</span>.<span class="number">30794</span> <span class="number">31</span>.<span class="number">79322</span>  </span><br><span class="line">#当经纬度其中一个或者两个超过界限值，报错，信息如下：</span><br><span class="line">(error) ERR syntax error. Try GEOADD key [x1] [y1] [name1] [x2] [y2] [name2] ...</span><br><span class="line">#添加城市经纬度 语法格式： geoadd key 经度 纬度 name +++可多个添加</span><br><span class="line">#添加成功后返回添加成功的数量值</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geoadd city <span class="number">118</span>.<span class="number">8921</span> <span class="number">31</span>.<span class="number">32751</span> nanjing <span class="number">117</span>.<span class="number">30794</span> <span class="number">31</span>.<span class="number">79322</span> hefei <span class="number">102</span>.<span class="number">82147</span> <span class="number">24</span>.<span class="number">88554</span> kunming <span class="number">91</span>.<span class="number">13775</span> <span class="number">29</span>.<span class="number">65262</span> lasa <span class="number">116</span>.<span class="number">23128</span> <span class="number">40</span>.<span class="number">22077</span> beijing <span class="number">106</span>.<span class="number">54041</span> <span class="number">29</span>.<span class="number">40268</span> chongqing  </span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE city <span class="number">0</span> -<span class="number">1</span>  #注意：geo的查看方式和zset的命令是一致的，</span><br><span class="line">#由此可知，geo本质上还是个集合，不过Redis官方对其进行了二次封装</span><br><span class="line"><span class="number">1</span>) &quot;lasa&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kunming&quot;</span><br><span class="line"><span class="number">3</span>) &quot;chongqing&quot;</span><br><span class="line"><span class="number">4</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">6</span>) &quot;beijing&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos city nanjing  #查看看指定城市的经纬度信息</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;<span class="number">118</span>.<span class="number">89209836721420288</span>&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">32750976275760735</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos city nanjing beijing  #查看看多个城市的经纬度信息</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;<span class="number">118</span>.<span class="number">89209836721420288</span>&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">32750976275760735</span>&quot;</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">23128265142440796</span>&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">40</span>.<span class="number">22076905438526495</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist city nanjing beijing   #计算南京到北京之间的距离，默认返回单位是m</span><br><span class="line">&quot;<span class="number">1017743</span>.<span class="number">1413</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist city nanjing beijing km  #km  千米</span><br><span class="line">&quot;<span class="number">1017</span>.<span class="number">7431</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist city nanjing beijing mi  #mi  英里</span><br><span class="line">&quot;<span class="number">632</span>.<span class="number">3978</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist city nanjing beijing ft  #ft  英尺</span><br><span class="line">&quot;<span class="number">3339052</span>.<span class="number">3010</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="georadius（查询附近位置）操作"><a href="#georadius（查询附近位置）操作" class="headerlink" title="georadius（查询附近位置）操作"></a>georadius（查询附近位置）操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE city <span class="number">0</span> -<span class="number">1</span>  #查看城市</span><br><span class="line"><span class="number">1</span>) &quot;lasa&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kunming&quot;</span><br><span class="line"><span class="number">3</span>) &quot;chongqing&quot;</span><br><span class="line"><span class="number">4</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">6</span>) &quot;beijing&quot;</span><br><span class="line">#查看指定位置的<span class="number">1000</span>公里范围内有哪些城市</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">1000</span> km  </span><br><span class="line"><span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line"><span class="number">2</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">3</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">400</span> km  #查看指定位置的<span class="number">400</span>公里范围内有哪些城市</span><br><span class="line">(empty array)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">550</span> km  #查看指定位置的<span class="number">550</span>公里范围内有哪些城市</span><br><span class="line"><span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line">#查看指定位置的<span class="number">550</span>公里范围内有哪些城市,withcoord指定返回城市的name</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">1000</span> km withcoord</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">23128265142440796</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">40</span>.<span class="number">22076905438526495</span>&quot;</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) &quot;hefei&quot;</span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) &quot;<span class="number">117</span>.<span class="number">30793744325637817</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">79321915080526395</span>&quot;</span><br><span class="line"><span class="number">3</span>) <span class="number">1</span>) &quot;nanjing&quot;</span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) &quot;<span class="number">118</span>.<span class="number">89209836721420288</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">32750976275760735</span>&quot;</span><br><span class="line">#查看指定位置的<span class="number">550</span>公里范围内有哪些城市,withdist指定返回城市的’经纬度‘值</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">1000</span> km withcoord withdist</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">408</span>.<span class="number">3496</span>&quot;</span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">23128265142440796</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">40</span>.<span class="number">22076905438526495</span>&quot;</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) &quot;hefei&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">732</span>.<span class="number">6371</span>&quot;</span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) &quot;<span class="number">117</span>.<span class="number">30793744325637817</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">79321915080526395</span>&quot;</span><br><span class="line"><span class="number">3</span>) <span class="number">1</span>) &quot;nanjing&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">749</span>.<span class="number">0265</span>&quot;</span><br><span class="line">   <span class="number">3</span>) <span class="number">1</span>) &quot;<span class="number">118</span>.<span class="number">89209836721420288</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">32750976275760735</span>&quot;</span><br><span class="line">#查看指定位置的<span class="number">550</span>公里范围内有哪些城市,withhash指定返回城市的’经纬度‘的hash值</span><br><span class="line">#如果两个城市的hash值越’像‘，证明城市距离越近！</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">1000</span> km withcoord withdist withhash</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">408</span>.<span class="number">3496</span>&quot;</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">4069896088584598</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">23128265142440796</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">40</span>.<span class="number">22076905438526495</span>&quot;</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) &quot;hefei&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">732</span>.<span class="number">6371</span>&quot;</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">4052763834193093</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) &quot;<span class="number">117</span>.<span class="number">30793744325637817</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">79321915080526395</span>&quot;</span><br><span class="line"><span class="number">3</span>) <span class="number">1</span>) &quot;nanjing&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">749</span>.<span class="number">0265</span>&quot;</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">4054278565840695</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) &quot;<span class="number">118</span>.<span class="number">89209836721420288</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">32750976275760735</span>&quot;</span><br><span class="line">#查看指定位置的<span class="number">550</span>公里范围内有哪些城市,count num 指定返回’num‘个城市数据量</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadius city <span class="number">120</span> <span class="number">38</span> <span class="number">1000</span> km withcoord withdist withhash count <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) &quot;beijing&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">408</span>.<span class="number">3496</span>&quot;</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">4069896088584598</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) &quot;<span class="number">116</span>.<span class="number">23128265142440796</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">40</span>.<span class="number">22076905438526495</span>&quot;</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) &quot;hefei&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;<span class="number">732</span>.<span class="number">6371</span>&quot;</span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">4052763834193093</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) &quot;<span class="number">117</span>.<span class="number">30793744325637817</span>&quot;</span><br><span class="line">      <span class="number">2</span>) &quot;<span class="number">31</span>.<span class="number">79321915080526395</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="georadiusbymember-（查找指定元素指定范围内的元素）、geohash-（返回经纬度的hash值）、zrange、zrem（使用zset命令操作geo）"><a href="#georadiusbymember-（查找指定元素指定范围内的元素）、geohash-（返回经纬度的hash值）、zrange、zrem（使用zset命令操作geo）" class="headerlink" title="georadiusbymember （查找指定元素指定范围内的元素）、geohash （返回经纬度的hash值）、zrange、zrem（使用zset命令操作geo）"></a>georadiusbymember （查找指定元素指定范围内的元素）、geohash （返回经纬度的hash值）、zrange、zrem（使用zset命令操作geo）</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#查询南京 <span class="number">500</span>公里范围有哪些城市</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadiusbymember city nanjing <span class="number">500</span> km</span><br><span class="line"><span class="number">1</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">2</span>) &quot;nanjing&quot;</span><br><span class="line">#查询重庆 <span class="number">1500</span>公里范围有哪些城市</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; georadiusbymember city chongqing <span class="number">1500</span> km</span><br><span class="line"><span class="number">1</span>) &quot;lasa&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kunming&quot;</span><br><span class="line"><span class="number">3</span>) &quot;chongqing&quot;</span><br><span class="line"><span class="number">4</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">6</span>) &quot;beijing&quot;</span><br><span class="line">#返回北京和南京的经纬度的 hash值</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geohash city beijing nanjing</span><br><span class="line"><span class="number">1</span>) &quot;wx4sucvncn0&quot;</span><br><span class="line"><span class="number">2</span>) &quot;wtsd1qyxfx0&quot;</span><br><span class="line">#查看所有城市name</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE city <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;lasa&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kunming&quot;</span><br><span class="line"><span class="number">3</span>) &quot;chongqing&quot;</span><br><span class="line"><span class="number">4</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">6</span>) &quot;beijing&quot;</span><br><span class="line">#根据geo中的name删除g元素</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREM city lasa</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#删除成功</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE city <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;kunming&quot;</span><br><span class="line"><span class="number">2</span>) &quot;chongqing&quot;</span><br><span class="line"><span class="number">3</span>) &quot;hefei&quot;</span><br><span class="line"><span class="number">4</span>) &quot;nanjing&quot;</span><br><span class="line"><span class="number">5</span>) &quot;beijing&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：实际需求中，我们可以用来查询附近的人、计算两人之间的距离等。当然，那些所需的经纬度我们肯定要结合java代码来一次导入，手动查询和录入太过于浪费时间！</p><h2 id="Hyperloglog：-基数"><a href="#Hyperloglog：-基数" class="headerlink" title="Hyperloglog： 基数"></a>Hyperloglog： 基数</h2><p>首先得明白什么是基数？<br>再数学层面上可以说是：两个数据集中不重复的元素~<br>但是再Redis中，可能会有一定的误差性。 官方给出的误差率是0.81%。<br>Hyperloglog的优点： 占用的内存是固定的，2^64个元素，相当于只需要12kb的内存即可。效率极高！<br>pfadd（添加数据集）、pfcount（统计数据集）、pfmegre（合并数据集-自动去重）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfadd dataList <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>  #添加数据集</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfcount dataList  #统计数据集中的元素</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfadd dataList1 <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>  #添加数据集</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfcount dataList1  #统计数据集中的元素</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line">#将dataList 和dataList1  两个数据集合并成一个新的 newdata数据集，并且自动去重</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfmerge newdata dataList dataList1  </span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; pfcount newdata</span><br><span class="line">(integer) <span class="number">10</span></span><br></pre></td></tr></table></figure><p>总结：如果在实际业务中，允许一定的误差值，我们可以使用基数统计来计算~效率非常高！比如：网站的访问量，就可以利用<strong>Hyperloglog</strong>来进行计算统计！</p><h2 id="Bitmap：-位存储"><a href="#Bitmap：-位存储" class="headerlink" title="Bitmap： 位存储"></a>Bitmap： 位存储</h2><p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！<br>setbit（添加）、getset（获取）、bitcount（统计）操作</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">1</span> <span class="number">1</span>   #添加周一已登陆 为<span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">2</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">3</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">4</span> <span class="number">0</span>  #添加周四已登陆 为<span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">5</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">6</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit login <span class="number">7</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getbit login <span class="number">1</span>  #获取周一是否登录</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getbit login <span class="number">4</span>  #获取周四是否登陆</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; bitcount login  #统计这周登陆的天数</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><p>总结：实际需求中，可能需要我们统计用户的登陆信息，员工的打卡信息等等。只要是事务的只有<strong>两个状态</strong>的，我们都可以用Bitmap来进行操作！！！</p><h1 id="Redis中的事务和乐观锁如何实现"><a href="#Redis中的事务和乐观锁如何实现" class="headerlink" title="Redis中的事务和乐观锁如何实现"></a>Redis中的事务和乐观锁如何实现</h1><p><strong>事务</strong><br>①原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。<br>②一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>③隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>④持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。<br>在Redis事务没有没有隔离级别的概念！<br>在Redis单条命令式保证原子性的，但是事务不保证原子性！</p><p><strong>乐观锁</strong><br>①当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。<br>②没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。<br>在Redis是可以实现乐观锁的！</p><h2 id="Redis如何实现事务？"><a href="#Redis如何实现事务？" class="headerlink" title="Redis如何实现事务？"></a>Redis如何实现事务？</h2><h3 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name dingyongjun  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">26</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> high <span class="number">172</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec  #执行事务</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name  #获取数据成功，证明事务执行成功</span><br><span class="line">&quot;dingyongjun&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line">&quot;<span class="number">26</span>&quot;</span><br></pre></td></tr></table></figure><h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name dingyongjun  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">26</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; discard  #放弃事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name  #不会执行事务里面的添加操作</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行"><a href="#编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行" class="headerlink" title="编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行"></a>编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name dingyongjun  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">23</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getset name  #输入一个错误的命令，这时候已经报错了，但是这个还是进入了事务的队列当中</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> &#x27;getset&#x27; command</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> high <span class="number">173</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec  #执行事务，报错，并且所有的命令都不会执行</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get name  #获取数据为空，证明没有执行</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行"><a href="#运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行" class="headerlink" title="运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行"></a>运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name dingyongjun  #添加字符串数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; incr name  #对字符串数据进行自增操作</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">23</span>  #添加数据</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get age  #获取数据</span><br><span class="line">QUEUED </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec  #执行事务。虽然对字符串数据进行自增操作报错了，但是其他的命令还是可以正常执行的</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) (error) ERR value is <span class="keyword">not</span> an integer or out of range</span><br><span class="line"><span class="number">3</span>) OK</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">23</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get age  #获取数据成功</span><br><span class="line">&quot;<span class="number">23</span>&quot;</span><br></pre></td></tr></table></figure><p>总结：由以上可以得出结论，Redis是支持单条命令事务的，但是事务并不能保证原子性！</p><h2 id="Redis如何实现乐观锁？"><a href="#Redis如何实现乐观锁？" class="headerlink" title="Redis如何实现乐观锁？"></a>Redis如何实现乐观锁？</h2><h3 id="watch（监视）"><a href="#watch（监视）" class="headerlink" title="watch（监视）"></a>watch（监视）</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> money <span class="number">100</span>  #添加金钱<span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> cost <span class="number">0</span>  #添加花费<span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; watch money  #监控金钱</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; DECRBY money <span class="number">30</span>  #金钱-<span class="number">30</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; incrby cost <span class="number">30</span>  #花费+<span class="number">30</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec  #执行事务，成功！这时候数据没有发生变动才可以成功</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">70</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="多线程测试watch"><a href="#多线程测试watch" class="headerlink" title="多线程测试watch"></a>多线程测试watch</h3><p>#线程1</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#线程<span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> money <span class="number">100</span>  #添加金钱<span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> cost <span class="number">0</span>  #添加花费<span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; watch money  #开启监视（乐观锁）</span><br><span class="line">OK </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi  #开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; DECRBY money <span class="number">20</span>  #金钱-<span class="number">20</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; INCRBY cost <span class="number">20</span>   #花费+<span class="number">20</span></span><br><span class="line">QUEUED</span><br><span class="line">#这里先不要执行，先执行线程<span class="number">2</span>来修改被监视的值</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec  #执行报错，因为我们监视了money这个值，如果事务要对这个值进行操作前</span><br><span class="line">#监视器会判断这个值是否正常，如果发生改变，事务执行失败！</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>#线程2</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#线程<span class="number">2</span>，这个在事务执行前操作执行</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; INCRBY money <span class="number">20</span>  #金钱+<span class="number">20</span></span><br><span class="line">(integer) <span class="number">120</span></span><br></pre></td></tr></table></figure><p>总结：乐观锁和悲观锁的区别。<br><strong>悲观锁：</strong> 什么时候都会出问题，所以一直监视着，没有执行当前步骤完成前，不让任何线程执行，十分浪费性能！一般不使用！<br><strong>乐观锁：</strong> 只有更新数据的时候去判断一下，在此期间是否有人修改过被监视的这个数据，没有的话正常执行事务，反之执行失败！</p><h1 id="SpringBoot如何整合Redis"><a href="#SpringBoot如何整合Redis" class="headerlink" title="SpringBoot如何整合Redis"></a>SpringBoot如何整合Redis</h1><p>SpringBoot应该不用过多介绍了吧！是Spring当前最火的一个框架，既然学习了Redis，我们肯定是要在实际项目中使用，那么肯定首选整合SpringBoot啦！</p><p>简单介绍下SpringBoot对Jedis的支持吧，在1.×版本的时候，SpringBoot的底层还是使用Jedis来连接Redis的，但是在2.×版本后，就换成了Lettuce。两者的区别如下：<br><strong>Jedis:</strong> 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式！<br><strong>Lettuce:</strong> 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式！</p><h2 id="添加POM依赖："><a href="#添加POM依赖：" class="headerlink" title="添加POM依赖："></a>添加POM依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--集成redis--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--序列化--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--lombok,自动生成set、get等方法--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置连接的application-yml文件："><a href="#配置连接的application-yml文件：" class="headerlink" title="配置连接的application.yml文件："></a>配置连接的application.yml文件：</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testRedis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dadadingdada!&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">其他方法如下</span></span><br><span class="line"><span class="comment">// redisTemplate  #操作不同的数据类型，api和我们的指令是一样的 </span></span><br><span class="line"><span class="comment">// opsForValue  #操作字符串 类似String </span></span><br><span class="line"><span class="comment">// opsForList  #操作List 类似List </span></span><br><span class="line"><span class="comment">// opsForSet  #操作set</span></span><br><span class="line"><span class="comment">// opsForHash  #操作hash</span></span><br><span class="line"><span class="comment">// opsForZSet  #操作zset</span></span><br><span class="line"><span class="comment">// opsForGeo   #操作geo</span></span><br><span class="line"><span class="comment">// opsForHyperLogLog  #操作HyperLogLog</span></span><br><span class="line"><span class="comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的 CRUD </span></span><br><span class="line"><span class="comment">// 获取redis的连接对象 </span></span><br><span class="line"><span class="comment">// RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); </span></span><br><span class="line"><span class="comment">// connection.flushDb(); </span></span><br><span class="line"><span class="comment">// connection.flushAll();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>证明如果是用基本RedisTemplate类来操作Redis的话，是基本上可以达到所有的效果的，因为具体方法和命令大体一致！</p><h2 id="对象的保存和读取"><a href="#对象的保存和读取" class="headerlink" title="对象的保存和读取"></a>对象的保存和读取</h2><p>User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.annotation.MyAnnotation;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/6 15:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会报异常   </span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;liao.sc&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221201153557.png?raw=true" alt="blog_images20221201153557.png"></p><p>结论：所以在操作Redis中，关于对象的保存我们得序列化才可以正常操作！</p><h2 id="自定义封装RedisTemplate类"><a href="#自定义封装RedisTemplate类" class="headerlink" title="自定义封装RedisTemplate类"></a>自定义封装RedisTemplate类</h2><p>上面说了大体上可以实现，但是为了在工作中更容易操作Redis，我们一般重新封装RedisTemplate类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="comment">//解决Redis存储对象没有序列化问题</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span></span><br><span class="line">    <span class="comment">// 自己定义了一个RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化完成后我们再试试对象的添加获取</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221201154258.png?raw=true" alt="blog_images20221201154258.png"></p><h2 id="封装RedisUtils类："><a href="#封装RedisUtils类：" class="headerlink" title="封装RedisUtils类："></a>封装RedisUtils类：</h2><p>在实际工作中，我们不可能用<strong>RedisTemplate</strong> 来操作Redis的，因为实在太繁琐，所以我们一般自定义一个RedisUtils工具类来操作Redis！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">keys</span><span class="params">(String keys)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.keys(keys);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入, 不存在放入，存在返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setnx</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().setIfAbsent(key,value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间,不存在放入，存在返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setnx</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：其实这篇讲了这么多，大家可以发现，SpringBoot真的是极度方便，整合Redis之后我们只需要简单的操作即可完美使用Redis！<br>但是，前面的内容还都是Redis相关的基础，接下来我将继续整理关于Redis的进阶知识！</p><h1 id="Redis的配置文件详解"><a href="#Redis的配置文件详解" class="headerlink" title="Redis的配置文件详解"></a>Redis的配置文件详解</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> # 绑定的ip </span><br><span class="line">protected-<span class="built_in">mode</span> yes # 保护模式 </span><br><span class="line">port <span class="number">6379</span> # 端口设置</span><br></pre></td></tr></table></figure><p>通用GENERAL</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！ </span><br><span class="line">pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！ </span><br><span class="line"># 日志 </span><br><span class="line"># Specify the server verbosity level. </span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful <span class="keyword">for</span> development/testing) </span><br><span class="line"># verbose (many rarely useful info, but <span class="keyword">not</span> a mess like the debug level) </span><br><span class="line"># notice (moderately verbose, what you want <span class="keyword">in</span> production probably) 生产环境 </span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice </span><br><span class="line">logfile &quot;&quot; # 日志的文件位置名 </span><br><span class="line">databases <span class="number">16</span> # 数据库的数量，默认是 <span class="number">16</span> 个数据库 </span><br><span class="line">always-show-logo yes # 是否总是显示LOGO</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快照（RDB）：持久化，在规定的时间内，执行了多少次操作则会持久化到文件 .rdb .aof文件<br><strong>Redis是内存数据库，如果没有持久化，那么数据断电即失！</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如果<span class="number">900</span>s内，如果至少有一个<span class="number">1</span> key进行了修改，我们及进行持久化操作 </span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> </span><br><span class="line"># 如果<span class="number">300</span>s内，如果至少<span class="number">10</span> key进行了修改，我们及进行持久化操作 </span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> </span><br><span class="line"># 如果<span class="number">60</span>s内，如果至少<span class="number">10000</span> key进行了修改，我们及进行持久化操作 </span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line"># 我们之后学习持久化，会自己定义这个测试！</span><br></pre></td></tr></table></figure><p>SECURITY 安全<br>可以在这里设置Redis的密码，默认是没有密码的。</p><p>通过命令设置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span></span><br><span class="line">PONG</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; config get requirepass  #获取Redis的密码</span><br><span class="line"><span class="number">1</span>) &quot;requirepass&quot;</span><br><span class="line"><span class="number">2</span>) &quot;&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; config <span class="built_in">set</span> requirepass &quot;<span class="number">123456</span>&quot;  #设置Redis的密码为<span class="number">123456</span></span><br><span class="line">OK</span><br><span class="line"># Ctrl+C 退出当前连接</span><br><span class="line">[root@dyjcomputer bin]# redis-cli -p <span class="number">6379</span>  #重新连接</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span>  #测试<span class="built_in">ping</span>，失败，所有的命令都显示无权限</span><br><span class="line">(error) NOAUTH Authentication required.  </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k1 v1  #失败，所有的命令都显示无权限</span><br><span class="line">(error) NOAUTH Authentication required.  </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; auth <span class="number">123456</span>  #auth + 密码  登陆上去</span><br><span class="line">OK </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span>  #正常</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; config get requirepass  #获取密码，正常</span><br><span class="line"><span class="number">1</span>) &quot;requirepass&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">123456</span>&quot;</span><br></pre></td></tr></table></figure><p>通过修改配置文件设置，找到图示位置，添加密码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass <span class="number">12346</span></span><br></pre></td></tr></table></figure><p>重启Redis测试！</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span></span><br><span class="line">(error) NOAUTH Authentication required.  </span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; auth <span class="number">123456</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">ping</span></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>限制CLIENTS</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxclients <span class="number">10000</span>   #设置能连接上redis的最大客户端的数量 </span><br><span class="line">maxmemory &lt;bytes&gt;  #redis 配置最大的内存容量 </span><br><span class="line">maxmemory-policy noeviction  #内存到达上限之后的处理策略 </span><br><span class="line"><span class="number">1</span>、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line"><span class="number">2</span>、allkeys-lru ： 删除lru算法的key </span><br><span class="line"><span class="number">3</span>、volatile-random：随机删除即将过期key </span><br><span class="line"><span class="number">4</span>、allkeys-random：随机删除 </span><br><span class="line"><span class="number">5</span>、volatile-ttl ： 删除即将过期的 </span><br><span class="line"><span class="number">6</span>、noeviction ： 永不过期，返回错误</span><br></pre></td></tr></table></figure><p>APPEND ONLY 模式 aof配置（持久化保存）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly no  #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下,rdb完全够用！ </span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  #持久化的文件的名字 </span><br><span class="line"># appendfsync always # 每次修改都会 sync。消耗性能 </span><br><span class="line">appendfsync everysec # 每秒执行一次 sync，可能会丢失这<span class="number">1</span>s的数据！ </span><br><span class="line"># appendfsync no  #不执行 sync，这个时候操作系统自己同步数据，速度最快！</span><br></pre></td></tr></table></figure><h1 id="Redis持久化之RDB和AOF"><a href="#Redis持久化之RDB和AOF" class="headerlink" title="Redis持久化之RDB和AOF"></a>Redis持久化之RDB和AOF</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能 !</p>]]></content>
    
    
    <summary type="html">Redis详解</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>论文模板</title>
    <link href="http://example.com/2022/11/29/%E6%B0%B4%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2022/11/29/%E6%B0%B4%E8%AE%BA%E6%96%87/</id>
    <published>2022-11-29T07:00:00.000Z</published>
    <updated>2022-11-29T09:02:55.527Z</updated>
    
    <content type="html"><![CDATA[<p>你一定要记住，你知道的别不一定知道，那么你可以不说，但是你说出来，一定要是真的</p><h1 id="论文模板"><a href="#论文模板" class="headerlink" title="论文模板"></a>论文模板</h1><ol><li>模型确定，</li><li>结果正在跑（或已结束），</li><li>目标期刊已定，一般可以定顶刊<ol><li>从目标期刊中打印3-5份最近的论文定模板</li></ol></li><li>第一遍初稿写的时候没必要注意排版格式</li></ol><h2 id="Abstrac"><a href="#Abstrac" class="headerlink" title="Abstrac"></a>Abstrac</h2><p>简单描述你这个领域，你这个领域出现了什么问题（创新在这里），你用了什么方法解决，你的方法有了性能提升。简述</p><p>关键词：</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>描述你这个了领域，这个领域对这个现实世界有什么帮助。</p><p>你这个领域出现了什么问题（引用别人的），尽量用可视化的例子来表达</p><p>我就想着解决这个问题，我通过以下三点（我加的小模块）解决了这个问题：</p><ol><li>1</li><li>2</li><li>3</li></ol><p>总结，我这个性能是很好</p><h2 id="Realted-Work"><a href="#Realted-Work" class="headerlink" title="Realted Work"></a>Realted Work</h2><p>首先描述你这个领域的普遍做法（选）</p><p>具体讲别人是怎么做的</p><p>总结下，受上面的启发，我怎么做的（简述）</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><h3 id="Basic-Module"><a href="#Basic-Module" class="headerlink" title="Basic Module"></a>Basic Module</h3><p>用的一些小模块，简单讲，不要把你懂得当做别人也懂</p><h3 id="你的方法（一般为标题）"><a href="#你的方法（一般为标题）" class="headerlink" title="你的方法（一般为标题）"></a>你的方法（一般为标题）</h3><p>你的方法分成多个小模块</p><p>编码器-解码器架构</p><ol><li>总的讲一下你的方法的一个架构，一个组成</li><li>编码器<ol><li>a编码器<ol><li>目标检测</li><li>知识图谱</li></ol></li><li>b编码器</li></ol></li><li>解码器<ol><li>正向解码器</li><li>反向解码器</li></ol></li></ol><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Experiments-Settings"><a href="#Experiments-Settings" class="headerlink" title="Experiments Settings"></a>Experiments Settings</h3><p>一些你用到的东西，评价的东西（可以模仿别人写）</p><ol><li>Data Sets   数据</li><li>Evaluation Metrics 评价指标</li><li>Parameter Settings  参数设定</li></ol><h3 id="Performance-Comprison"><a href="#Performance-Comprison" class="headerlink" title="Performance Comprison"></a>Performance Comprison</h3><p>和近几年的比较</p><p>你可以挑几个差点的顶刊顶会</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Quantitative-Analysis（消融实验）"><a href="#Quantitative-Analysis（消融实验）" class="headerlink" title="Quantitative Analysis（消融实验）"></a>Quantitative Analysis（消融实验）</h3><p>基准模型加模块（加了a、b、c三个模块）</p><p>去掉abc</p><p>仅去掉a+b</p><p>仅去掉c</p><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><p>案例分析：实例分析</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>我做了一件事，这件事怎么做的，有了提升</p><h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
    
    
    <summary type="html">小论文</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot注解</title>
    <link href="http://example.com/2022/11/29/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2022/11/29/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-11-29T07:00:00.000Z</published>
    <updated>2022-11-29T09:01:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><p>这个注解是Spring Boot最核心的注解，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p><h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h1><p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p><p>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p><p>@EnableAutoConfiguration实现的关键在于引入了AutoConfigurationImportSelector，其核心逻辑为selectImports方法，逻辑大致如下：</p><p>　●　从配置文件META-INF/spring.factories加载所有可能用到的自动配置类；</p><p>　●　去重，并将exclude和excludeName属性携带的类排除；</p><p>　●　过滤，将满足条件（@Conditional）的自动配置类返回；</p><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><p>用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h1><p>组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>@ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。</p><h1 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h1><p>用于标注数据访问组件，即DAO组件。</p><p>使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><h1 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h1><p>一般用于修饰service层的组件</p><h1 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h1><p>用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。</p><h1 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h1><p>表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，<strong>加上@responsebody后，会直接返回json数据。</strong></p><h1 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h1><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><p>相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><h1 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h1><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p><p>当加上（required=false）时，就算找不到bean也不报错。</p><h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p><h1 id="Resource-name-”name”-type-”type”"><a href="#Resource-name-”name”-type-”type”" class="headerlink" title="@Resource(name=”name”,type=”type”)"></a>@Resource(name=”name”,type=”type”)</h1><p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>RequestMapping是一个用来处理请求地址映射的注解；提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><ul><li><code>value</code>:映射的请求URL或者其别名</li><li><code>method</code>:兼容HTTP的方法名</li><li><code>params</code>:根据HTTP参数的存在、缺省或值对请求进行过滤</li><li><code>header</code>:根据HTTP Header的存在、缺省或值对请求进行过滤</li><li><code>consume</code>:设定在HTTP请求正文中允许使用的媒体类型</li><li><code>product</code>:在HTTP响应体中允许使用的媒体类型</li></ul><p>提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记下面是使用@RequestMapping的两个示例：</p><p><img src="https://s8.51cto.com/oss/202206/15/326128e90f0e1cc1856700db0139f1dc75c338.jpg" alt="图片"></p><p>@RequestMapping还可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前，如下：</p><p><img src="https://s9.51cto.com/oss/202206/15/d2060b050f5ab0c35ef4884792f07f887cedd1.jpg" alt="图片"></p><h1 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h1><p><code>@PathVariable</code>注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。特别地，<code>@PathVariable</code>注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p><p><img src="https://s9.51cto.com/oss/202206/15/67b5d0e51e44b21cd511748b3b3b5356fcfc56.jpg" alt="图片"></p><p>模板变量名需要使用<code>&#123; &#125;</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。下面是一个简写的示例：</p><p><img src="https://s4.51cto.com/oss/202206/15/d866b84086cb835ecd56331161bb9a0361816c.jpg" alt="图片"></p><p>提示：如果参数是一个非必须的，可选的项，则可以在@PathVariable中设置require=false@RequestParam@RequestParam注解用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。下面是使用该注解的代码示例：</p><p><img src="https://s2.51cto.com/oss/202206/15/816c991693fd4bcaa39898c45b2ab0b42e869f.jpg" alt="图片"></p><p>该注解的其他属性配置与<code>@PathVariable</code>的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。示例代码如下：</p><p><img src="https://s8.51cto.com/oss/202206/15/15e6aa6840a3df347a82134b60fa4d0dc72ea9.jpg" alt="图片"></p><h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h1><p>@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过<code>HttpMessageConverter</code>传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。此外，还可以通过@Valid注解对请求主体中的参数进行校验。下面是一个使用<code>@RequestBody</code>的示例：</p><p><img src="https://s2.51cto.com/oss/202206/15/d745a8798e08963a39c350241753f1fd688fc2.jpg" alt="图片"></p><p>@Valid在进行数据校验的时候需要在实体类的字段名上加上注解标注字段的取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 姓名 */</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请输入名称&quot;)</span></span><br><span class="line">    <span class="meta">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 年龄 */</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请输入年龄&quot;)</span></span><br><span class="line">    <span class="meta">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span></span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br></pre></td></tr></table></figure><p>标注之后在RequestBody进行映射的时候会对数据进行验证，如果不符合要求则会返回message信息</p><h1 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h1><p><code>@GetMapping</code>注解用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是<code>@RequestMapping(method=RequestMethod.GET)</code>的快捷方式。下面是<code>@GetMapping</code>的一个使用示例：</p><p><img src="https://s3.51cto.com/oss/202206/15/f4de9f638b01d70bee9156b39eca886f71254e.jpg" alt="图片"></p><h1 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h1><p><code>@PostMapping</code>注解用于处理HTTP POST请求，并将请求映射到具体的处理方法中。@PostMapping与@GetMapping一样，也是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.POST)</code>的快捷方式。下面是使用<code>@PostMapping</code>的一个示例：</p><p><img src="https://s7.51cto.com/oss/202206/15/247798479df3a6a26e53640831216acbaeb500.jpg" alt="图片"></p><h1 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h1><p><code>@PutMapping</code>注解用于处理HTTP PUT请求，并将请求映射到具体的处理方法中，@PutMapping是一个组合注解，相当于是<code>@RequestMapping(method=HttpMethod.PUT)</code>的快捷方式。下面是使用<code>@PutMapping</code>的一个示例：</p><p><img src="https://s7.51cto.com/oss/202206/15/4468c6249f67830d8a64718d91585f02c18da1.jpg" alt="图片"></p><h1 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h1><p><code>@DeleteMapping</code>注解用于处理HTTP DELETE请求，并将请求映射到删除方法中。@DeleteMapping是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.DELETE)</code>的快捷方式。下面是使用<code>@DeleteMapping</code>的一个示例：</p><p><img src="https://s5.51cto.com/oss/202206/15/994d47a01df0279903f123410493b9e0b870a3.jpg" alt="图片"></p><h1 id="PatchMapping"><a href="#PatchMapping" class="headerlink" title="@PatchMapping"></a>@PatchMapping</h1><p><code>@PatchMapping</code>注解用于处理HTTP PATCH请求，并将请求映射到对应的处理方法中。@PatchMapping相当于是<code>@RequestMapping(method=HttpMethod.PATCH)</code>的快捷方式。下面是一个简单的示例：</p><p><img src="https://s6.51cto.com/oss/202206/15/b9f511b11392a89b5ca900ffc34c73775753b4.jpg" alt="图片"></p><h1 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h1><p><code>@ControllerAdvice</code>是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。<code>@ControllerAdvice</code>需要和<code>@ExceptionHandler</code>、<code>@InitBinder</code>以及<code>@ModelAttribute</code>注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被<code>@ControllerAdvice</code>所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。此外，在有必要的时候，可以使用<code>@InitBinder</code>在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用<code>@ControllerAdvice</code>注解，就可以快速的创建统一的，自定义的异常处理类。下面是一个使用<code>@ControllerAdvice</code>的示例代码：</p><h2 id="ControllerAdvice-配合-ExceptionHandler-实现全局异常处理"><a href="#ControllerAdvice-配合-ExceptionHandler-实现全局异常处理" class="headerlink" title="@ControllerAdvice 配合 @ExceptionHandler 实现全局异常处理"></a>@ControllerAdvice 配合 @ExceptionHandler 实现全局异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(IllegalArgumentException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleException</span><span class="params">(IllegalArgumentException e)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;errorMessage&quot;</span>, <span class="string">&quot;参数不符合规范!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ControllerAdvice-配合-ModelAttribute-预设全局数据"><a href="#ControllerAdvice-配合-ModelAttribute-预设全局数据" class="headerlink" title="@ControllerAdvice 配合 @ModelAttribute 预设全局数据"></a>@ControllerAdvice 配合 @ModelAttribute 预设全局数据</h2><p>我们先来看看 <code>ModelAttribute</code>注解类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation that binds a method parameter or method return value</span></span><br><span class="line"><span class="comment"> * to a named model attribute, exposed to a web view. Supported</span></span><br><span class="line"><span class="comment"> * for controller classes with &#123;<span class="doctag">@link</span> RequestMapping <span class="doctag">@RequestMapping</span>&#125;</span></span><br><span class="line"><span class="comment"> * methods.</span></span><br><span class="line"><span class="comment"> * 此注解用于绑定一个方法参数或者返回值到一个被命名的model属性中，暴露给web视图。支持在</span></span><br><span class="line"><span class="comment"> * 在Controller类中注有<span class="doctag">@RequestMapping</span>的方法使用（这里有点拗口，不过结合下面的使用介绍</span></span><br><span class="line"><span class="comment"> * 你就会明白的)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ModelAttribute &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">binding</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上这个注解的作用就是，允许你往 <code>Model</code> 中注入全局属性（可以供所有Controller中注有@Request Mapping的方法使用），<code>value</code> 和 <code>name</code> 用于指定 属性的 <code>key</code> ，<code>binding</code> 表示是否绑定，默认为 <code>true</code>。</p><p>具体使用方法如下：</p><p>全局参数绑定</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">presetParam</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;globalAttr&quot;</span>,<span class="string">&quot;this is a global attribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute()</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">presetParam</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式对于加单个属性比较方便。默认会把返回值（如上面的map）作为属性的value，而对于key有两种指定方式：</p><p>当 @ModelAttribute() 不传任何参数的时候，默认会把返回值的字符串值作为key，如上例的 key 则是 ”map”（值得注意的是，不支持字符串的返回值作为key）。<br>当 @ModelAttribute(“myMap”) 传参数的时候，则以参数值作为key，这里 key 则是 ”myMap“。</p><p><strong>全局参数使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdviceController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;methodOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodOne</span><span class="params">(Model model)</span>&#123; </span><br><span class="line">        Map&lt;String, Object&gt; modelMap = model.asMap();</span><br><span class="line">        <span class="keyword">return</span> (String)modelMap.get(<span class="string">&quot;globalAttr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;methodTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodTwo</span><span class="params">(<span class="meta">@ModelAttribute(&quot;globalAttr&quot;)</span> String globalAttr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> globalAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;methodThree&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodThree</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) modelMap.get(<span class="string">&quot;globalAttr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="请求参数预处理"><a href="#请求参数预处理" class="headerlink" title="请求参数预处理"></a>请求参数预处理</h3><p>@ControllerAdvice 配合 @InitBinder 实现对请求参数的预处理</p><p>再次之前我们先来了解一下 <code>@IniiBinder</code>，先看一下源码，我会提取一些重要的注释进行浅析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation that identifies methods which initialize the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.bind.WebDataBinder&#125; which</span></span><br><span class="line"><span class="comment"> * will be used for populating command and form object arguments</span></span><br><span class="line"><span class="comment"> * of annotated handler methods.</span></span><br><span class="line"><span class="comment"> * 粗略翻译：此注解用于标记那些 (初始化[用于组装命令和表单对象参数的]WebDataBinder)的方法。</span></span><br><span class="line"><span class="comment"> * 原谅我的英语水平，翻译起来太拗口了，从句太多就用‘()、[]’分割一下便于阅读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Init-binder methods must not have a return value; they are usually</span></span><br><span class="line"><span class="comment"> * declared as &#123;<span class="doctag">@code</span> void&#125;.</span></span><br><span class="line"><span class="comment"> * 粗略翻译：初始化绑定的方法禁止有返回值，他们通常声明为 &#x27;void&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typical arguments are &#123;<span class="doctag">@link</span> org.springframework.web.bind.WebDataBinder&#125;</span></span><br><span class="line"><span class="comment"> * in combination with &#123;<span class="doctag">@link</span> org.springframework.web.context.request.WebRequest&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> java.util.Locale&#125;, allowing to register context-specific editors.</span></span><br><span class="line"><span class="comment"> * 粗略翻译：典型的参数是`WebDataBinder`，结合`WebRequest`或`Locale`使用，允许注册特定于上下文的编辑 </span></span><br><span class="line"><span class="comment"> * 器。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 总结如下：</span></span><br><span class="line"><span class="comment"> *  1. <span class="doctag">@InitBinder</span> 标识的方法的参数通常是 WebDataBinder。</span></span><br><span class="line"><span class="comment"> *  2. <span class="doctag">@InitBinder</span> 标识的方法,可以对 WebDataBinder 进行初始化。WebDataBinder 是 DataBinder 的一</span></span><br><span class="line"><span class="comment"> *            个子类,用于完成由表单字段到 JavaBean 属性的绑定。</span></span><br><span class="line"><span class="comment"> *  3. <span class="doctag">@InitBinder</span> 标识的方法不能有返回值,必须声明为void。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InitBinder &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The names of command/form attributes and/or request parameters</span></span><br><span class="line"><span class="comment"> * that this init-binder method is supposed to apply to.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Default is to apply to all command/form attributes and all request parameters</span></span><br><span class="line"><span class="comment"> * processed by the annotated handler class. Specifying model attribute names or</span></span><br><span class="line"><span class="comment"> * request parameter names here restricts the init-binder method to those specific</span></span><br><span class="line"><span class="comment"> * attributes/parameters, with different init-binder methods typically applying to</span></span><br><span class="line"><span class="comment"> * different groups of attributes or parameters.</span></span><br><span class="line"><span class="comment"> * 粗略翻译：此init-binder方法应该应用于的命令/表单属性和/或请求参数的名称。默认是应用于所有命   * 令/表单属性和所有由带注释的处理类处理的请求参数。这里指定模型属性名或请求参数名将init-binder * 方法限制为那些特定的属性/参数，不同的init-binder方法通常应用于不同的属性或参数组。</span></span><br><span class="line"><span class="comment"> * 我至己都理解不太理解这说的是啥呀，我们还是看例子吧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看看具体用途，其实这些用途在 <code>Controller</code>里也可以定义，但是作用范围就只限当前Controller，因此下面的例子我们将结合 <code>ControllerAdvice</code> 作全局处理。</p><h3 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processParam</span><span class="params">(WebDataBinder dataBinder)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个字符串微调编辑器</span></span><br><span class="line"><span class="comment">         * 参数&#123;boolean emptyAsNull&#125;: 是否把空字符串(&quot;&quot;)视为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">StringTrimmerEditor</span> <span class="variable">trimmerEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTrimmerEditor</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 注册自定义编辑器</span></span><br><span class="line"><span class="comment">         * 接受两个参数&#123;Class&lt;?&gt; requiredType, PropertyEditor propertyEditor&#125;</span></span><br><span class="line"><span class="comment">         * requiredType：所需处理的类型</span></span><br><span class="line"><span class="comment">         * propertyEditor：属性编辑器，StringTrimmerEditor就是 propertyEditor的一个子类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dataBinder.registerCustomEditor(String.class, trimmerEditor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//同上，这里就不再一步一步讲解了</span></span><br><span class="line">        dataBinder.registerCustomEditor(Date.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomDateEditor</span>(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样之后呢，就可以实现全局的实现对 <code>Controller</code> 中<code>RequestMapping</code>标识的方法中的所有 <code>String</code> 和<code>Date</code>类型的参数都会被作相应的处理。</p><p>测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderTestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;processParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">test</span><span class="params">(String str, Date date)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;str&quot;</span>, str);</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, date);</span><br><span class="line">        <span class="keyword">return</span>  map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数绑定</p><p>参数绑定可以解决特定问题，那么我们先来看看我们面临的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// omitted getters and setters.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="comment">// omitted getters and setters.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderTestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;bindParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person person, Book book)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们会发现 <code>Person</code>类和 <code>Book</code> 类都有 <code>name</code>属性，那么这个时候就会出先问题，它可没有那么只能区分哪个<code>name</code>是哪个类的。因此 <code>@InitBinder</code>就派上用场了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @InitBinder(&quot;person&quot;) 对应找到@RequstMapping标识的方法参数中</span></span><br><span class="line"><span class="comment">     * 找参数名为person的参数。</span></span><br><span class="line"><span class="comment">     * 在进行参数绑定的时候，以‘p.’开头的都绑定到名为person的参数中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder(&quot;person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BindPerson</span><span class="params">(WebDataBinder dataBinder)</span>&#123;</span><br><span class="line">        dataBinder.setFieldDefaultPrefix(<span class="string">&quot;p.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder(&quot;book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BindBook</span><span class="params">(WebDataBinder dataBinder)</span>&#123;</span><br><span class="line">        dataBinder.setFieldDefaultPrefix(<span class="string">&quot;b.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，传入的同名信息就能对应绑定到相应的实体类中：</p><blockquote><p>p.name -&gt; Person.name b.name -&gt; Book.name</p><p>还有一点注意的是如果 @InitBinder(“value”) 中的 value 值和 Controller 中 @RequestMapping() 标识的方法的参数名不匹配，则就会产生绑定失败的后果,如：</p><p>@InitBinder(“p”)、@InitBinder(“b”)</p><p>public void test(Person person, Book book)</p><p>上述情况就会出现绑定失败，有两种解决办法</p><p>第一中：统一名称，要么全叫p，要么全叫person，只要相同就行。</p><p>第二种：方法参数加 @ModelAttribute，有点类似@RequestParam</p><p>@InitBinder(“p”)、@InitBinder(“b”)</p><p>public void test(@ModelAttribute(“p”) Person person, @ModelAttribute(“b”) Book book)</p></blockquote><h1 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h1><p><code>@ExceptionHander</code>注解用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被<code>@ExceptionHandler</code>标注的方法。下面是使用该注解的一个示例：</p><p><img src="https://s3.51cto.com/oss/202206/15/26e18e20674af12382c686c32272827e75430a.jpg" alt="图片"></p><h1 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h1><p>@ResponseStatus注解可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。下面是使用@ResponseStatus注解的一个示例：</p><p><img src="https://s4.51cto.com/oss/202206/15/f4401b4412d2f369049171b4a3e9579b749a5f.jpg" alt="图片"></p><h1 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h1><p>通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。下面是使用此注解的一个简单示例：</p><p><img src="https://s7.51cto.com/oss/202206/15/123a5574786bad89ef2957975f86f36e550036.jpg" alt="图片"></p><p>与<code>@PathVariable</code>和<code>@RequestParam</code>注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称，简写示例如下：</p><p><img src="https://s9.51cto.com/oss/202206/15/d8d0ad4826e4d6eb5ef6858dc1f57cdc060ba8.jpg" alt="图片"></p><p>特别地，如果使用<code>@ModelAttribute</code>对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。示例如下：</p><p><img src="https://s3.51cto.com/oss/202206/15/b458b53921fd2d263696357fd1b0fc95f8ba01.jpg" alt="图片"></p><p>在Spring调用具体的处理方法之前，被<code>@ModelAttribute</code>注解标注的所有方法都将被执行。**@CrossOrigin**``注解将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。使用此注解的示例如下：</p><p><img src="https://s7.51cto.com/oss/202206/15/c5ee5f4771df9a7c7482576e8f46bccf105623.jpg" alt="图片"></p><h1 id="DependsOn"><a href="#DependsOn" class="headerlink" title="@DependsOn"></a>@DependsOn</h1><p><code>@DependsOn</code>注解可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。下面是此注解使用示例代码：</p><p><img src="https://s2.51cto.com/oss/202206/15/f42652c422cbc9ffd9238948675cbec8b0d99f.jpg" alt="图片"></p><h1 id="Bean-1"><a href="#Bean-1" class="headerlink" title="@Bean"></a>@Bean</h1><p>@Bean注解主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。@Bean注解的用法很简单，在这里，着重介绍@Bean注解中<code>initMethod</code>和<code>destroyMethod</code>的用法。示例如下：</p><p><img src="https://s2.51cto.com/oss/202206/15/88813cc2291888b570f058a37aa0d31677bcd2.jpg" alt="图片"></p><h1 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h1><p>@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>globalSession</code>或者其他的自定义范围。这里以prototype为例子进行讲解。当一个Spring Bean被声明为prototype（原型模式）时，在每次需要使用到该类的时候，Spring IoC容器都会初始化一个新的改类的实例。在定义一个Bean时，可以设置Bean的scope属性为<code>prototype：scope=“prototype”</code>,也可以使用@Scope注解设置，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scope(value=ConfigurableBeanFactory.SCOPE_PROPTOTYPE)</span><br></pre></td></tr></table></figure><p>下面将给出两种不同的方式来使用@Scope注解，示例代码如下：</p><p><img src="https://s2.51cto.com/oss/202206/15/58a728501eba99314547134b0b1fec2c3c1366.jpg" alt="图片"></p><p><strong>单例模式</strong>当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。同样的原理，此情形也有两种配置方式，示例代码如下：</p><p><img src="https://s5.51cto.com/oss/202206/15/050a2fc37ece2cf8472756e71d5f9c6e054364.jpg" alt="图片"></p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。</p><h2 id="作用于构造函数"><a href="#作用于构造函数" class="headerlink" title="作用于构造函数"></a>作用于构造函数</h2><p><img src="https://s5.51cto.com/oss/202206/15/c695029224973fbd2f62445c9fae8f8f9758c6.jpg" alt="图片"></p><h2 id="作用于setter方法"><a href="#作用于setter方法" class="headerlink" title="作用于setter方法"></a>作用于setter方法</h2><p>下面是@Autowired注解标注setter方法的示例代码：</p><p><img src="https://s4.51cto.com/oss/202206/15/e6c42c5318e3b879e001523c6327501e03c8ea.jpg" alt="图片"></p><h2 id="作用于字段"><a href="#作用于字段" class="headerlink" title="作用于字段"></a>作用于字段</h2><p>@Autowired注解标注字段是最简单的，只需要在对应的字段上加入此注解即可，示例代码如下：</p><p><img src="https://s5.51cto.com/oss/202206/15/a67869204dfa7603aa85979d8b45bc0ab7c993.jpg" alt="图片"></p><h1 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h1><p>当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。下面将给出一个实例代码来说明这一特性：</p><p><img src="https://s2.51cto.com/oss/202206/15/b8399867508b7dbe11d8217092abf86c36bf57.jpg" alt="图片"></p><h1 id="PostConstruct与-PreDestroy"><a href="#PostConstruct与-PreDestroy" class="headerlink" title="@PostConstruct与@PreDestroy"></a>@PostConstruct与@PreDestroy</h1><p>值得注意的是，这两个注解不属于Spring,它们是源于JSR-250中的两个注解，位于<code>common-annotations.jar</code>中。@PostConstruct注解用于标注在Bean被Spring初始化之前需要执行的方法。@PreDestroy注解用于标注Bean被销毁前需要执行的方法。下面是具体的示例代码：</p><p><img src="https://s9.51cto.com/oss/202206/15/d6adcbe386f0942a203086e19cd0bc36d0c7cf.jpg" alt="图片"></p><h1 id="Qualifier-1"><a href="#Qualifier-1" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><p>当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。下面是一个关于此注解的代码示例：</p><p><img src="https://s9.51cto.com/oss/202206/15/3802111933c371a4bc54998f7e202181feb384.jpg" alt="图片"></p><h1 id="ConditionalOnBean与-ConditionalOnMissingBean"><a href="#ConditionalOnBean与-ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnBean与@ConditionalOnMissingBean"></a>@ConditionalOnBean与@ConditionalOnMissingBean</h1><p>这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;dataSource&quot;)</span></span><br><span class="line">LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h1><p>@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;alipay&quot;,havingValue=&quot;on&quot;)</span></span><br><span class="line">Alipay <span class="title function_">alipay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Alipay</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="ConditionalOnResource"><a href="#ConditionalOnResource" class="headerlink" title="@ConditionalOnResource"></a>@ConditionalOnResource</h1><p>此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnResource(resources = &quot;classpath:website.properties&quot;)</span><br><span class="line">Properties addWebsiteProperties()&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConditionalOnWebApplication与-ConditionalOnNotWebApplication"><a href="#ConditionalOnWebApplication与-ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnWebApplication与@ConditionalOnNotWebApplication"></a>@ConditionalOnWebApplication与@ConditionalOnNotWebApplication</h1><p>这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line">HealthCheckController <span class="title function_">healthCheckController</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConditionalExpression"><a href="#ConditionalExpression" class="headerlink" title="@ConditionalExpression"></a>@ConditionalExpression</h1><p>此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalException(&quot;$&#123;localstore&#125; &amp;&amp; $&#123;local == &#x27;true&#x27;&#125;&quot;)</span></span><br><span class="line">LocalFileStore <span class="title function_">store</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><p>@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditioanl(CustomConditioanl.class)</span></span><br><span class="line">CustomProperties <span class="title function_">addCustomProperties</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="http://example.com/2022/11/29/String%E7%B1%BB/"/>
    <id>http://example.com/2022/11/29/String%E7%B1%BB/</id>
    <published>2022-11-29T07:00:00.000Z</published>
    <updated>2022-11-29T09:01:12.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><code>String</code>类表示的字符串。java程序中的所有字符串，如 <code>&quot;abc&quot;</code>，实现这个类的实例。 </p><p>字符串是常量，它们的值不能被创建后改变。支持可变字符串字符串缓冲区。因为字符串对象是不可改变的，所以它们可以被共享。例如：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote><h2 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h2><ul><li>String:字符串，使用一对“”引起来表示。</li><li>1.String声明为final的，不可被继承</li><li>2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</li><li>3.String内部定义了final char[] value用于存储字符串数据</li><li>4.String:代表不可变的字符序列。简称：不可变性。</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value; 在堆中</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断值是否相同需要使用String.equals()方法。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String()<span class="comment">//创建一个内容为空的字符串</span></span><br><span class="line">String(String value)<span class="comment">//根据指定的字符串内容创建对象</span></span><br><span class="line">String(<span class="type">char</span>[] value)<span class="comment">//根据指定的字符数组创建对象</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes)<span class="comment">//根据指定的字节数组创建对象</span></span><br></pre></td></tr></table></figure><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int length()：返回字符串的长度：return value.length</span></span><br><span class="line"><span class="comment"> * char charAt(int index)：返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="comment"> * boolean isEmpty()：判断是否是空字符串：return value.length==0</span></span><br><span class="line"><span class="comment"> * String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写</span></span><br><span class="line"><span class="comment"> * String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写</span></span><br><span class="line"><span class="comment"> * String trim()：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="comment"> * boolean equals(Object obj)：比较字符串的内容是否相同</span></span><br><span class="line"><span class="comment"> * boolean equals IgnoreCase(String anotherString)：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="comment"> * String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+”</span></span><br><span class="line"><span class="comment"> * int compareTo(String anotherString)：比较两个字符串的大小</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</span></span><br><span class="line"><span class="comment"> * int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="comment"> * int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换：</span></span><br><span class="line"><span class="comment"> * String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="comment"> * String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="comment"> * String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="comment"> * String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 匹配:</span></span><br><span class="line"><span class="comment"> * boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 切片：</span></span><br><span class="line"><span class="comment"> * String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="comment"> * String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="理解String的不可变性"><a href="#理解String的不可变性" class="headerlink" title="理解String的不可变性"></a>理解String的不可变性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String:字符串，使用一对“”引起来表示。</span></span><br><span class="line"><span class="comment">     * 1.String声明为final的，不可被继承</span></span><br><span class="line"><span class="comment">     * 2.String实现了Serializable接口：表示字符串是支持序列化的。</span></span><br><span class="line"><span class="comment">     *         实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment">     * 3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment">     * 4.String:代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment">     *      体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     * 5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span></span><br><span class="line"><span class="comment">     * 6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  <span class="comment">//字面量的定义方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//比较s1和s2的地址值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s4);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s5);<span class="comment">//mbc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String不同拼接操作的对比"><a href="#String不同拼接操作的对比" class="headerlink" title="String不同拼接操作的对比"></a>String不同拼接操作的对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结论</span></span><br><span class="line"><span class="comment">     *     1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</span></span><br><span class="line"><span class="comment">     *     2.只要其中有一个是变量，结果就在堆中</span></span><br><span class="line"><span class="comment">     *     3.如果拼接的结果调用intern()方法，返回值就在常量池中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s5.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String与其他类型的转换"><a href="#String与其他类型的转换" class="headerlink" title="String与其他类型的转换"></a>String与其他类型的转换</h2><h3 id="String与基本数据类型包装类的转换"><a href="#String与基本数据类型包装类的转换" class="headerlink" title="String与基本数据类型包装类的转换"></a>String与基本数据类型包装类的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    String与基本数据类型、包装类之间的转换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</span></span><br><span class="line"><span class="comment">     *    基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//        int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);   <span class="comment">//&quot;123</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str3);   <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="String与char-之间的转换"><a href="#String与char-之间的转换" class="headerlink" title="String与char[]之间的转换"></a>String与char[]之间的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String 与 char[]之间的转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String --&gt; char[]:调用String的toCharArray()</span></span><br><span class="line"><span class="comment"> * char[] --&gt; String:调用String的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>; <span class="comment">//题目： a21cb3</span></span><br><span class="line">  <span class="type">char</span>[] charArray = str1.toCharArray(); <span class="comment">//字符串转换成字符</span></span><br><span class="line">  <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);  <span class="comment">//字符转换成字符串</span></span><br></pre></td></tr></table></figure><h3 id="String与byte-之间的转换"><a href="#String与byte-之间的转换" class="headerlink" title="String与byte[]之间的转换"></a>String与byte[]之间的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String 与 byte[]之间的转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 编码：String --&gt; byte[]:调用String的getBytes()</span></span><br><span class="line"><span class="comment"> * 解码：byte[] --&gt; String:调用String的构造器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)</span></span><br><span class="line"><span class="comment"> * 解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123重工&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符编码集,进行转换</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">    System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    System.out.println(str4);<span class="comment">//没有出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure><h2 id="StringBuffer和StringBuilder的介绍"><a href="#StringBuffer和StringBuilder的介绍" class="headerlink" title="StringBuffer和StringBuilder的介绍"></a>StringBuffer和StringBuilder的介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><h2 id="StringBuffer的源码分析"><a href="#StringBuffer的源码分析" class="headerlink" title="StringBuffer的源码分析"></a>StringBuffer的源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于StringBuffer和StringBuilder的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferBuilderTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 源码分析：</span></span><br><span class="line"><span class="comment">     * String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment">     * String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment">     * System.out.println(sb1.length());//</span></span><br><span class="line"><span class="comment">     * sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">     * sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * //问题1.System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment">     * //问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment">     *        默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.println(sb2.length());   <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer() <span class="comment">//构造一个没有字符的字符串缓冲区，并构造了16个字符的初始容量。  </span></span><br><span class="line">StringBuffer(CharSequence seq) <span class="comment">//构建一个包含指定的 CharSequence相同字符的字符串缓冲区。  </span></span><br><span class="line">StringBuffer(<span class="type">int</span> capacity) <span class="comment">//构造一个没有字符的字符串缓冲区，并构造指定的初始容量。  </span></span><br><span class="line">StringBuffer(String str) <span class="comment">//构造一个初始化为指定字符串内容的字符串缓冲区。  </span></span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment"> * StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment"> * StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment"> * StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment"> * StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment"> * public int indexOf(String str)</span></span><br><span class="line"><span class="comment"> * public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment"> * public int length()</span></span><br><span class="line"><span class="comment"> * public char charAt(int n )</span></span><br><span class="line"><span class="comment"> * public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> *     增：append(xxx)</span></span><br><span class="line"><span class="comment"> *     删：delete(int start,int end)</span></span><br><span class="line"><span class="comment"> *     改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment"> *     查：charAt(int n )</span></span><br><span class="line"><span class="comment"> *     插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment"> *     长度：length();</span></span><br><span class="line"><span class="comment"> *     遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="字符串拼接方法解析"><a href="#字符串拼接方法解析" class="headerlink" title="字符串拼接方法解析"></a>字符串拼接方法解析</h2><h3 id="使用-拼接字符串的实现原理"><a href="#使用-拼接字符串的实现原理" class="headerlink" title="使用**+**拼接字符串的实现原理"></a>使用**+**拼接字符串的实现原理</h3><p>前面提到过，使用+拼接字符串，其实只是 Java 提供的一个语法糖， 那么，我们就</p><p>来解一解这个语法糖，看看他的内部原理到底是如何实现的。</p><p>还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">wechat</span> <span class="operator">=</span> <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">introduce</span> <span class="operator">=</span> <span class="string">&quot;每日更新 Java 相关技术文章&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">hollis</span> <span class="operator">=</span> wechat + <span class="string">&quot;,&quot;</span> + introduce;</span><br></pre></td></tr></table></figure><p>反编译后的内容如下，反编译工具为 jad。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">wechat</span> <span class="operator">=</span> <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">introduce</span> <span class="operator">=</span> <span class="string">&quot;\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6</span></span><br><span class="line"><span class="string">587\u7AE0&quot;</span>;<span class="comment">//每日更新 Java 相关技术文章</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hollis</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(wechat).append(<span class="string">&quot;,&quot;</span>).append(<span class="type">int</span></span><br><span class="line">roduce).toString();</span><br></pre></td></tr></table></figure><p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String 转成了 StringBuilder 后，使用其 append 方法进行处理的。那 么 也 就 是 说 ， J a v a 中 的 + 对 字 符 串 的 拼 接 ， 其 实 现 原 理 是 使 用StringBuilder.append。</p><h3 id="concat-是如何实现的"><a href="#concat-是如何实现的" class="headerlink" title="concat 是如何实现的"></a>concat 是如何实现的</h3><p>我们再来看一下 concat 方法的源代码，看一下这个方法又是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line"><span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line"><span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">str.getChars(buf, len);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的 String 对象并返回。通过源码我们也可以看到，经过 concat 方法，其实是 new 了一个新的 String，这也就呼应到前面我们说的字符串的不变性问题上了。</p><h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p>接下来我们看看 StringBuffer 和 StringBuilder 的实现原理。</p><p>和 String 类类似，StringBuilder 类也封装了一个字符数组，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure><p>与 String 不同的是，它并不是 final 的，所以他是可以修改的。另外，与 String 不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count;</span><br></pre></td></tr></table></figure><p>其 append 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.append(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类继承了 AbstractStringBuilder 类，看下其 append 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> appendNull();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line"></span><br><span class="line">ensureCapacityInternal(count + len);</span><br><span class="line"></span><br><span class="line">str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line"></span><br><span class="line">count += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append 会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p><p>StringBuffer 和 StringBuilder 类似，最大的区别就是 StringBuffer 是线程安全的，</p><p>看一下 StringBuffer 的 append 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line"></span><br><span class="line">toStringCache = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.append(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法使用 synchronized 进行声明，说明是一个线程安全的方法。而 StringBuilder则不是线程安全的。</p><h3 id="StringUtils-join-是如何实现的"><a href="#StringUtils-join-是如何实现的" class="headerlink" title="StringUtils.join 是如何实现的"></a>StringUtils.join 是如何实现的</h3><p>通过查看 StringUtils.join 的源代码，我们可以发现，其实他也是通过 StringBuilder来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(<span class="keyword">final</span> Object[] array, String separator, <span class="keyword">final</span> <span class="type">int</span></span></span><br><span class="line"><span class="params">startIndex, <span class="keyword">final</span> <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (array == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (separator == <span class="literal">null</span>) &#123;</span><br><span class="line">separator = EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// endIndex - startIndex &gt; 0: Len = NofStrings *(len(firstString) + len(s</span></span><br><span class="line">eparator))</span><br><span class="line"><span class="comment">// (Assuming that all Strings are roughly equally long)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">noOfItems</span> <span class="operator">=</span> endIndex - startIndex;</span><br><span class="line"><span class="keyword">if</span> (noOfItems &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(noOfItems * <span class="number">16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; startIndex) &#123;</span><br><span class="line">buf.append(separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (array[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">buf.append(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h3><p>既然有这么多种字符串拼接的方法，那么到底哪一种效率最高呢？我们来简单对比一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//这里是初始字符串定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//这里是字符串拼接代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;cost:&quot;</span> + (t2 - t1));</span><br></pre></td></tr></table></figure><p>我们使用形如以上形式的代码，分别测试下五种字符串拼接代码的运行时间。得到结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+cost:<span class="number">5119</span></span><br><span class="line">StringBuilder cost:<span class="number">3</span></span><br><span class="line">StringBuffer cost:<span class="number">4</span></span><br><span class="line">concat cost:<span class="number">3623</span></span><br><span class="line">StringUtils.join cost:<span class="number">25726</span></span><br></pre></td></tr></table></figure><p>从结果可以看出，用时从短到长的对比是：</p><blockquote><p>StringBuilder&lt;StringBuffer&lt;concat&lt;+&lt;StringUtils.join</p></blockquote><p>StringBuffer 在 StringBuilder 的基础上，做了同步处理，所以在耗时上会相对多一些。</p><p>StringUtils.join 也是使用了 StringBuilder，并且其中还是有很多其他操作，所以耗时</p><p>较长，这个也容易理解。其实 StringUtils.join 更擅长处理字符串数组或者列表的拼接。</p><p>那么问题来了，前面我们分析过，其实使用+拼接字符串的实现原理也是使用的</p><p>StringBuilder，那为什么结果相差这么多，高达 1000 多倍呢？我们再把以下代码反编译下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hollis&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">str += s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;+ cost:&quot;</span> + (t2 - t1));</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hollis&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">str = (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(<span class="string">&quot;+ cost:&quot;</span>).append(t2 - t1).to</span><br><span class="line"><span class="title function_">String</span><span class="params">()</span>);</span><br></pre></td></tr></table></figure><p>我们可以看到反编译后的代码，在 for 循环中，每次都是 new 了一个 StringBuilder，然后再把 String 转成 StringBuilder，再进行 append。而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。所以， Java 开发手册建议：循环体内，字符串的连接方式，使用 StringBuilder 的append 方法进行扩展。而不要使用+。 </p>]]></content>
    
    
    <summary type="html">java基础</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot基础</title>
    <link href="http://example.com/2022/11/29/SpringBoot/"/>
    <id>http://example.com/2022/11/29/SpringBoot/</id>
    <published>2022-11-29T07:00:00.000Z</published>
    <updated>2022-11-29T09:02:07.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-依赖管理特性"><a href="#SpringBoot-依赖管理特性" class="headerlink" title="SpringBoot-依赖管理特性"></a>SpringBoot-依赖管理特性</h1><ul><li><p>父项目做依赖管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">依赖管理</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">上面项目的父项目如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>开发导入starter场景启动器</li></ul><p>​         1.见到很多 spring-boot-starter-* ： *就某种场景</p><p>​         2.只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</p><pre><code>     3.更多SpringBoot所有支持的场景      4.见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</code></pre></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无需关注版本号，自动版本仲裁</p><ol><li>引入依赖默认都可以不写版本</li><li>引入非版本仲裁的jar，要写版本号。</li></ol><p>可以修改默认版本号</p><ol><li>查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</li><li>在当前项目里面重写配置，如下面的代码。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SpringBoot-自动配置特性"><a href="#SpringBoot-自动配置特性" class="headerlink" title="SpringBoot-自动配置特性"></a>SpringBoot-自动配置特性</h1><p>自动配好Tomcat</p><ul><li>引入Tomcat依赖。</li><li>配置Tomcat</li></ul><p>自动配好SpringMVC</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul><p>自动配好Web常见功能，如：字符编码问题</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的包结构</p><ul><li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li><li>无需以前的包扫描配置</li><li>想要改变扫描路径<ul><li>@SpringBootApplication(scanBasePackages=“com.lun”)</li><li>@ComponentScan 指定扫描路径</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lun&quot;)</span></span><br></pre></td></tr></table></figure><p>各种配置拥有默认值</p><ul><li>默认配置最终都是映射到某个类上，如：<code>MultipartProperties</code></li><li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul><p>按需加载所有自动配置项</p><ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li></ul><h1 id="底层注解-Configuration详解"><a href="#底层注解-Configuration详解" class="headerlink" title="底层注解-@Configuration详解"></a>底层注解-@Configuration详解</h1><ul><li>基本使用<ul><li>Full模式与Lite模式</li><li>示例</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)（保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的）（默认）</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)（每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Configuration测试代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom02</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        <span class="type">MyConfig</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">        <span class="comment">//保持组件单实例</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳实战</p><ul><li>配置 类组件之间<strong>无依赖关系</strong>用Lite模式加速容器启动过程，减少判断</li><li>配置 类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件，用Full模式（默认）</li></ul><h1 id="底层注解-Import导入组件"><a href="#底层注解-Import导入组件" class="headerlink" title="底层注解-@Import导入组件"></a>底层注解-@Import导入组件</h1><blockquote><ul><li><p>@Bean、@Component、@Controller、@Service、@Repository，它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能。</p></li><li><p>@ComponentScan 在07、基础入门-SpringBoot-自动配置特性有用例。</p></li><li><p>@Import({User.class, DBHelper.class})给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1、返回我们IOC容器</span></span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、获取组件</span></span><br><span class="line">String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DBHelper</span> <span class="variable">bean1</span> <span class="operator">=</span> run.getBean(DBHelper.class);</span><br><span class="line">System.out.println(bean1);</span><br></pre></td></tr></table></figure><h1 id="底层注解-Conditional条件装配"><a href="#底层注解-Conditional条件装配" class="headerlink" title="底层注解-@Conditional条件装配"></a>底层注解-@Conditional条件装配</h1><p><strong>条件装配：满足Conditional指定的条件，则进行组件注入</strong></p><p><img src="https://img-blog.csdnimg.cn/20210205005453173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>用@ConditionalOnMissingBean举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span><span class="comment">//没有tom名字的Bean时，MyConfig类的Bean才能生效。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">user01</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom22</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="底层注解-ImportResource导入Spring配置文件"><a href="#底层注解-ImportResource导入Spring配置文件" class="headerlink" title="底层注解-@ImportResource导入Spring配置文件"></a>底层注解-@ImportResource导入Spring配置文件</h1><p>比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。</p><p>bean.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">haha</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hehe</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="底层注解-ConfigurationProperties配置绑定"><a href="#底层注解-ConfigurationProperties配置绑定" class="headerlink" title="底层注解-@ConfigurationProperties配置绑定"></a>底层注解-@ConfigurationProperties配置绑定</h1><p>如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用</p><p>传统方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getProperties</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">         <span class="type">Properties</span> <span class="variable">pps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">         pps.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.properties&quot;</span>));</span><br><span class="line">         <span class="type">Enumeration</span> <span class="variable">enum1</span> <span class="operator">=</span> pps.propertyNames();<span class="comment">//得到配置文件的名字</span></span><br><span class="line">         <span class="keyword">while</span>(enum1.hasMoreElements()) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">strKey</span> <span class="operator">=</span> (String) enum1.nextElement();</span><br><span class="line">             <span class="type">String</span> <span class="variable">strValue</span> <span class="operator">=</span> pps.getProperty(strKey);</span><br><span class="line">             System.out.println(strKey + <span class="string">&quot;=&quot;</span> + strValue);</span><br><span class="line">             <span class="comment">//封装到JavaBean。</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring Boot一种配置配置绑定：</p><p>@ConfigurationProperties + @Component</p><p>假设有配置文件application.properties</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mycar.brand=BYD</span></span><br><span class="line"><span class="string">mycar.price=100000</span></span><br></pre></td></tr></table></figure><p>只有在容器中的组件，才会拥有SpringBoot提供的强大功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot另一种配置配置绑定：(SpringBoot采用这种方式配置文件)</p><p>@EnableConfigurationProperties + @ConfigurationProperties</p><ol><li>开启Car配置绑定功能</li><li>把这个Car这个组件自动注册到容器中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自动配置【源码分析】-自动包规则原理"><a href="#自动配置【源码分析】-自动包规则原理" class="headerlink" title="自动配置【源码分析】-自动包规则原理"></a>自动配置【源码分析】-自动包规则原理</h1><p>Spring Boot应用的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下<code>@SpringBootApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点分析<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>@Configuration</code>代表当前是一个配置类。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>指定扫描哪些Spring注解。</p><p>@ComponentScan</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点分析<code>@AutoConfigurationPackage</code>，<code>@Import(AutoConfigurationImportSelector.class)</code>。</p><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>标签名直译为：自动配置包，指定了默认的包规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用Registrar给容器中导入一系列组件</li><li>将指定的一个包下的所有组件导入进MainApplication所在包下。</li></ol><h1 id="自动配置【源码分析】-初始加载自动配置类"><a href="#自动配置【源码分析】-初始加载自动配置类" class="headerlink" title="自动配置【源码分析】-初始加载自动配置类"></a>自动配置【源码分析】-初始加载自动配置类</h1><h2 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h2><ul><li><p>利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</p></li><li><p>调用List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</p></li><li><p>利用工厂加载 Map&lt;String, List<String>&gt; loadSpringFactories(@Nullable ClassLoader classLoader);得到所有的组件</p></li><li><p>从META-INF/spring.factories位置来加载一个文件。</p><pre><code>                 默认扫描我们当前系统里面所有`META-INF/spring.factories`位置的文件                </code></pre></li></ul><p>​                    <code>spring-boot-autoconfigure-2.3.4.RELEASE.jar</code>包里面也有<code>META-INF/spring.factories</code></p><p><img src="https://img-blog.csdnimg.cn/20210205005536620.png#pic_center" alt="img"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类</span></span><br><span class="line"><span class="comment"># spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories</span></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p><p>如<code>AopAutoConfiguration</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.aop&quot;,</span></span><br><span class="line"><span class="meta">    name = &quot;auto&quot;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AopAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自动配置【源码分析】-自动配置流程"><a href="#自动配置【源码分析】-自动配置流程" class="headerlink" title="自动配置【源码分析】-自动配置流程"></a>自动配置【源码分析】-自动配置流程</h1><p>以<code>DispatcherServletAutoConfiguration</code>的内部类<code>DispatcherServletConfiguration</code>为例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="comment">//容器中有这个类型组件</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="comment">//容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line"><span class="comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span></span><br><span class="line"><span class="comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span></span><br><span class="line"><span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line"><span class="keyword">return</span> resolver;<span class="comment">//给容器中加入了文件上传解析器；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了以用户的优先</strong>。</p><p>总结：</p><ul><li>SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置</li></ul><p>​            用户直接自己@Bean替换底层的组件<br>​            用户去看这个组件是获取的配置文件什么值就去修改。<br><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值 —-&gt; application.properties</strong></p><h1 id="SpringBoot应用如何编写"><a href="#SpringBoot应用如何编写" class="headerlink" title="SpringBoot应用如何编写"></a>SpringBoot应用如何编写</h1><p>引入场景依赖</p><ul><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">官方文档</a></p></li><li><p>查看自动配置了哪些（选做）</p><ul><li>自己分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true开启自动配置报告。<ul><li>Negative（不生效）</li><li>Positive（生效）</li></ul></li></ul></li></ul><p>是否需要修改</p><ul><li>参照文档修改配置项<ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">官方文档</a></li><li>自己分析。xxxxProperties绑定了配置文件的哪些。</li></ul></li><li>自定义加入或者替换组件<ul><li>@Bean、@Component…</li></ul></li><li>自定义器 XXXXXCustomizer；</li></ul><h1 id="最佳实践-Lombok简化开发"><a href="#最佳实践-Lombok简化开发" class="headerlink" title="最佳实践-Lombok简化开发"></a>最佳实践-Lombok简化开发</h1><p>Lombok用标签方式代替构造器、getter/setter、toString()等鸡肋代码。</p><p>spring boot已经管理Lombok。引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IDEA中File-&gt;Settings-&gt;Plugins，搜索安装Lombok插件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化日志开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>+<span class="string">&quot;你好：&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最佳实践-dev-tools"><a href="#最佳实践-dev-tools" class="headerlink" title="最佳实践-dev-tools"></a>最佳实践-dev-tools</h1><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools">官方文档</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IDEA中，项目或者页面修改以后：Ctrl+F9。</p><h1 id="配置文件-yaml的用法"><a href="#配置文件-yaml的用法" class="headerlink" title="配置文件-yaml的用法"></a>配置文件-yaml的用法</h1><p>同以前的properties用法</p><p>YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。</p><p><strong>非常适合用来做以数据为中心的配置文件</strong>。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>key: value；kv之间有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li><li>字符串无需加引号，如果要加，单引号’’、双引号””表示字符串内容会被 转义、不转义</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">v</span></span><br></pre></td></tr></table></figure><ul><li>对象：键值对的集合。map、hash、set、object</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><h1 id="配置文件-自定义类绑定的配置提示"><a href="#配置文件-自定义类绑定的配置提示" class="headerlink" title="配置文件-自定义类绑定的配置提示"></a>配置文件-自定义类绑定的配置提示</h1><blockquote><p>You can easily generate your own configuration metadata file from items annotated with @ConfigurationProperties by using the spring-boot-configuration-processor jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——link</p></blockquote><p>自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="web场景-web开发简介"><a href="#web场景-web开发简介" class="headerlink" title="web场景-web开发简介"></a>web场景-web开发简介</h1><p>Spring Boot provides auto-configuration for Spring MVC that <strong>works well with most applications.(大多场景我们都无需自定义配置)</strong></p><p>The auto-configuration adds the following features on top of Spring’s defaults:</p><p>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</p><p>​           内容协商视图解析器和BeanName视图解析器<br>Support for serving static resources, including support for WebJars (covered later in this document)).</p><p>​           静态资源（包括webjars）<br>Automatic registration of Converter, GenericConverter, and Formatter beans.</p><p>​            自动注册 Converter，GenericConverter，Formatter<br>Support for HttpMessageConverters (covered later in this document).</p><p>​            支持 HttpMessageConverters （后来我们配合内容协商理解原理）<br>Automatic registration of MessageCodesResolver (covered later in this document).</p><p>​            自动注册 MessageCodesResolver （国际化用）<br>Static index.html support.</p><p>​            静态index.html 页支持<br>Custom Favicon support (covered later in this document).</p><p>​            自定义 Favicon<br>Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).</p><p>​            自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上）</p><blockquote><p>If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.</p><p>不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则</p></blockquote><blockquote><p>If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.</p><p>声明 WebMvcRegistrations 改变默认底层组件</p></blockquote><blockquote><p>If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc.</p><p>使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC</p></blockquote><h1 id="web场景-静态资源规则与定制化"><a href="#web场景-静态资源规则与定制化" class="headerlink" title="web场景-静态资源规则与定制化"></a>web场景-静态资源规则与定制化</h1><h2 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h2><p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p><p>访问 ： 当前项目根路径/ + 静态资源名</p><p>原理： 静态映射/**。</p><p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。</p><p>也可以改变默认的静态资源路径，<code>/static</code>，<code>/public</code>,<code>/resources</code>, <code>/META-INF/resources</code>失效</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure><h2 id="静态资源访问前缀"><a href="#静态资源访问前缀" class="headerlink" title="静态资源访问前缀"></a>静态资源访问前缀</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p><h2 id="webjar"><a href="#webjar" class="headerlink" title="webjar"></a>webjar</h2><p>可用jar方式添加css，js等资源文件，</p><p><a href="https://www.webjars.org/">https://www.webjars.org/</a></p><p>例如，添加jquery</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">http://localhost:8080/webjars/<strong>jquery/3.5.1/jquery.js</strong></a> 后面地址要按照依赖里面的包路径</p><h1 id="web场景-welcome与favicon功能"><a href="#web场景-welcome与favicon功能" class="headerlink" title="web场景-welcome与favicon功能"></a>web场景-welcome与favicon功能</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-welcome-page">官方文档</a></p><h2 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h2><ul><li>静态资源路径下 index.html。<ul><li>可以配置静态资源路径</li><li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致welcome page功能失效</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure><ul><li>controller能处理/index。</li></ul><h2 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h2><p>指网页标签上的小图标。</p><p>favicon.ico 放在静态资源目录下即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效</span></span><br></pre></td></tr></table></figure><h1 id="web场景-【源码分析】-静态资源原理"><a href="#web场景-【源码分析】-静态资源原理" class="headerlink" title="web场景-【源码分析】-静态资源原理"></a>web场景-【源码分析】-静态资源原理</h1><ul><li>SpringBoot启动默认加载 xxxAutoConfiguration 类（自动配置类）</li><li>SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code>，生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给容器中配置的内容：<ul><li>配置文件的相关属性的绑定：WebMvcProperties==<strong>spring.mvc</strong>、</li><li>ResourceProperties==<strong>spring.resources</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类只有一个有参构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造器所有参数的值都会从容器中确定,容器内部必须与参数类型的bea对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(WebProperties webProperties, WebMvcProperties mvcProperties,</span></span><br><span class="line"><span class="params">ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.mvcProperties = mvcProperties;</span><br><span class="line"><span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="built_in">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line"><span class="built_in">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line"><span class="built_in">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line"><span class="built_in">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line"><span class="built_in">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</li><li>WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</li><li>ListableBeanFactory beanFactory Spring的beanFactory</li><li>HttpMessageConverters 找到所有的HttpMessageConverters</li><li>ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。</li><li>DispatcherServletPath</li><li>ServletRegistrationBean 给应用注册Servlet、Filter…</li></ul><p><strong>资源处理的默认规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line"><span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">registration.addResourceLocations(<span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(servletContext, SERVLET_LOCATION));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码，我们可以同过配置禁止所有静态资源规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment">#禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure><p>静态资源规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span></span><br><span class="line"><span class="comment">     * /resources/, /static/, /public/].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求处理-【源码分析】-Rest映射及源码解析"><a href="#请求处理-【源码分析】-Rest映射及源码解析" class="headerlink" title="请求处理-【源码分析】-Rest映射及源码解析"></a>请求处理-【源码分析】-Rest映射及源码解析</h1><h2 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h2><ul><li>@xxxMapping;<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li></ul><p>Rest风格支持（使用<strong>HTTP</strong>请求方式动词来表示对资源的操作）</p><ul><li><p>以前：</p><ul><li>/getUser 获取用户</li><li>/deleteUser 删除用户</li><li>/editUser 修改用户</li><li>/saveUser保存用户</li></ul></li><li><ul><li>现在： /user<ul><li>GET-获取用户</li><li>DELETE-删除用户</li><li>PUT-修改用户</li><li>POST-保存用户</li></ul></li><li>核心Filter；HiddenHttpMethodFilter</li></ul></li><li><p><strong>用法</strong></p><ul><li>开启页面表单的Rest功能</li><li>页面 form的属性method=post，隐藏域 _method=put、delete等（如果直接get或post，无需隐藏域）</li><li>编写请求映射</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-GET提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-POST提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-DELETE 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-PUT提交&quot;</span><span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">putUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Rest原理（表单提交要使用REST的时候）</p><ul><li>表单提交会带上<code>\_method=PUT</code></li><li>请求过来被<code>HiddenHttpMethodFilter</code>拦截</li></ul><p>​        请求是否正常，并且是POST</p><ul><li><p>获取到<code>\_method</code>的值。</p></li><li><p>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></p></li><li><p><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></p></li><li><p><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),</span><br><span class="line">HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default method parameter: &#123;<span class="doctag">@code</span> _method&#125;. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_METHOD_PARAM</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodParam</span> <span class="operator">=</span> DEFAULT_METHOD_PARAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the parameter name to look for HTTP methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #DEFAULT_METHOD_PARAM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodParam</span><span class="params">(String methodParam)</span> &#123;</span><br><span class="line">Assert.hasText(methodParam, <span class="string">&quot;&#x27;methodParam&#x27; must not be empty&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.methodParam = methodParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line"><span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filterChain.doFilter(requestToUse, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple &#123;<span class="doctag">@link</span> HttpServletRequest&#125; wrapper that returns the supplied method for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HttpServletRequest#getMethod()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpMethodRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HttpMethodRequestWrapper</span><span class="params">(HttpServletRequest request, String method)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(request);</span><br><span class="line"><span class="built_in">this</span>.method = method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.method;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Rest使用客户端工具。<ul><li>如PostMan可直接发送put、delete等方式请求。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">SpringBoot</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://example.com/2022/11/22/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/11/22/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2022-11-22T07:00:00.000Z</published>
    <updated>2022-11-22T08:55:04.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>任务描述：我们已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限，如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（没错，当然是第I象限，但我们的任务是要让机器知道）</p><p><img src="https://picd.zhimg.com/v2-777808fc5b00e7727df4dc835c1fc44f_720w.jpg?source=172ae18b" alt="神经网络15分钟入门！足够通俗易懂了吧"></p><h2 id="输入层："><a href="#输入层：" class="headerlink" title="输入层："></a><strong>输入层：</strong></h2><p>在我们的例子中，输入层是坐标值，例如（1,1），这是一个包含两个元素的数组，也可以看作是一个1<em>2的矩阵。输入层的元素维度与输入量的特征息息相关，如果输入的是一张32</em>32像素的灰度图像，那么输入层的维度就是32*32。</p><h2 id="从输入层到隐藏层"><a href="#从输入层到隐藏层" class="headerlink" title="从输入层到隐藏层"></a><strong>从输入层到隐藏层</strong></h2><p>接输入层和隐藏层的是W1和b1。由X计算得到H十分简单，就是矩阵运算：</p><p><img src="https://pic2.zhimg.com/80/v2-b31ecd1eea01a5e52968075778cb9699_1440w.webp" alt="img"></p><p>如果你学过线性代数，对这个式子一定不陌生。如上图中所示，在设定隐藏层为50维（也可以理解成50个神经元）之后，矩阵H的大小为（1*50）的矩阵。</p><h2 id="从隐藏层到输出层"><a href="#从隐藏层到输出层" class="headerlink" title="从隐藏层到输出层"></a><strong>从隐藏层到输出层</strong></h2><p>连接隐藏层和输出层的是W2和b2。同样是通过矩阵运算进行的：</p><p><img src="https://pic4.zhimg.com/80/v2-0c8c9f5ea2376623cb31ba74e9256627_1440w.webp" alt="img"></p><p>通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：***一系列线性方程的运算最终都可以用一个线性方程表示***。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a><strong>激活函数</strong></h2><p>所以这里要对网络注入灵魂：<strong>激活层</strong>。 传统的神经网络解决不了非线性问题只有加入激活函数才能把线性函数转换成非线性</p><p><strong>简而言之，激活层是为矩阵运算的结果添加非线性的</strong>。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。不要被奇怪的函数名吓到，其实它们的形式都很简单。</p><p><strong>Sigmoid函数：当输入趋近于正无穷/负无穷时，输出无限接近于1/0</strong><br>$$<br>Sigmoid 激活函数 :  \frac{1}{1+x^-1}<br>$$<br><img src="https://n.sinaimg.cn/spider2021224/658/w875h583/20210224/0b99-kkmphps7571844.png" alt="img"></p><p><strong>在什么情况下适合使用Sigmoid 激活函数呢？</strong></p><p>Sigmoid 函数的输出范围是 0 到 1。由于输出值限定在 0 到 1，因此它对每个神经元的输出进行了归一化；</p><p>用于将预测概率作为输出的模型。由于概率的取值范围是 0 到 1，因此 Sigmoid 函数非常合适；\</p><p><strong>Sigmoid 激活函数有哪些优点？</strong></p><p>梯度平滑，避免「跳跃」的输出值；</p><p>函数是可微的。这意味着可以找到任意两个点的 sigmoid 曲线的斜率；</p><p>明确的预测，即非常接近 1 或 0。</p><p><strong>Sigmoid 激活函数有哪些缺点？</strong></p><p>倾向于梯度消失；</p><p>函数输出不是以 0 为中心的，这会降低权重更新的效率；</p><p>Sigmoid 函数执行指数运算，计算机运行得较慢。</p><p><strong>ReLU函数：当输入小于0时，输出0；当输入大于0时，输出等于输入。</strong><br>$$<br>ReLU函数：<br>f(x)=<br>\begin{cases}<br>max(x,0),\quad x\geq 0\<br>0, \quad x&lt; 0<br>\end{cases}</p><p><br>$$<br><img src="https://n.sinaimg.cn/spider2021224/138/w600h338/20210224/0781-kkmphps7572767.png" alt="img"></p><p><strong>阶跃函数：当输入小于等于0时，输出0；当输入大于0时，输出1</strong><br>$$<br>阶跃函数：<br>f(x)=<br>\begin{cases}<br>1,\quad x&gt; 0\<br>0, \quad x&lt; 0<br>\end{cases}</p><p><br>$$<br><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221121114919.png?raw=true" alt="blog_images20221121114919.png"></p><h2 id="输出的正规化"><a href="#输出的正规化" class="headerlink" title="输出的正规化"></a><strong>输出的正规化</strong></h2><p>输出Y的值可能会是(3,1,0.1,0.5)这样的矩阵，诚然我们可以找到里边的最大值“3”，从而找到对应的分类为I，但是这并不直观。我们想让最终的输出为<strong>概率</strong>，也就是说可以生成像(90%,5%,2%,3%)这样的结果，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。</p><p>具体是怎么计算的呢？计算公式如下：</p><p><img src="https://pic4.zhimg.com/80/v2-3ad93ae576918ff385485dab6a2e6b87_1440w.webp" alt="img"></p><p>简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值。</p><p>我们将使用这个计算公式做输出结果正规化处理的层叫做“Softmax”层。此时的神经网络将变成</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesc3a441f7547683740f91e3142f1999e.png?raw=true" alt="blog_imagesc3a441f7547683740f91e3142f1999e.png"></p><h2 id="如何衡量输出的好坏"><a href="#如何衡量输出的好坏" class="headerlink" title="如何衡量输出的好坏"></a><strong>如何衡量输出的好坏</strong></h2><p>通过Softmax层之后，我们得到了I，II，III和IV这四个类别分别对应的概率，但是要注意，这是神经网络计算得到的概率值结果，而非真实的情况。比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。一种直观的解决方法，是用1减去Softmax输出的概率，比如1-90%=0.1。不过更为常用且巧妙的方法是，求<strong>对数的负数</strong>。是用90%举例，对数的负数就是：-log0.9=0.046。可以想见，概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做“<strong>交叉熵损失</strong>（Cross Entropy Error）”。我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images696afb1fcb192f34fdbb1c02334a93f.png?raw=true" alt="blog_images696afb1fcb192f34fdbb1c02334a93f.png"></p><h2 id="反向传播与参数优化"><a href="#反向传播与参数优化" class="headerlink" title="反向传播与参数优化"></a><strong>反向传播与参数优化</strong></h2><p><strong>神经网络正向传播：神经网络的传播都是形如Y=WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。</strong></p><p>算出交叉熵损失后，就要开始反向传播了。其实反向传播就是一个<strong>参数优化</strong>的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。</p><p><strong>例如</strong></p><p>在沙漠中有一个球形机器，我们在机器中操纵着四个旋钮，分别叫做W1，b1，W2，b2。当我们旋转其中的某个旋钮时，球形机器会发生移动，但是旋转旋钮大小和机器运动方向之间的对应关系是不知道的。而我们的目的就是<strong>走到沙漠的最低点</strong>。</p><p>此时我们该怎么办？只能挨个试喽。</p><p>如果增大W1后，球向上走了，那就减小W1。</p><p>如果增大b1后，球向下走了，那就继续增大b1。</p><p>如果增大W2后，球向下走了一大截，那就多增大些W2。</p><p>。。。</p><p>这就是进行参数优化的形象解释（有没有想到求导？），这个方法叫做梯度下降法。</p><p>当我们的球形机器走到最低点时，也就代表着我们的交叉熵损失达到最小（接近于0）。</p><p>关于反向传播，还有许多可以讲的，但是因为内容较多，就放在下一篇文章中说吧。不过上述例子对于理解神经网络参数优化的过程，还是很有帮助的。</p><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><p>卷积神经网络也就是convolutional neural networks （简称CNN）</p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>拿到一张图片，要对它进行识别，最简单的栗子是，这张图是什么？比如，我现在要训练一个最简单的CNN，用来识别一张图片里的字母是X还是O。</p><p><img src="https://pic4.zhimg.com/80/v2-ce4e2ad2cb9919d7e49a66fcd9f7a267_1440w.webp" alt="img"></p><p>我们人眼一看，很简单嘛，明显就是X啊，但是计算机不知道，它不明白什么是X。所以我们给这张图片加一个标签，也就是俗称的Label，Label=X，就告诉了计算机这张图代表的是X。它就记住了X的长相。但是并不是所有的X都长这样呀。比如说…</p><p><img src="https://pic4.zhimg.com/80/v2-547828bbcc202a030dfc98fcb3cfe5af_1440w.webp" alt="img"></p><p>这四个都是X，但它们和之前那张X明显不一样，计算机没见过它们，又都不认识了。</p><p>（这里可以扯出机器学习中听起来很高冷的名词 <strong>欠拟合</strong></p><p>不认识了怎么办，当然是回忆看看是不是见过差不多的呀。这时候CNN要做的，就是如何提取内容为X的图片的特征。</p><p>我们都知道，图片在计算机内部以像素值的方式被存储，也就是说两张X在计算机看来，其实是这样子的。</p><p><img src="https://pic3.zhimg.com/80/v2-8bc4063deeaf11853fe1f9531b71e50a_1440w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-e216abf6d8042827b1e6de85732f0060_1440w.webp" alt="img"></p><p>其中1代表白色，-1代表黑色。</p><p>如果按照每像素逐个比较肯定是不科学的，结果不对而且效率低下，因此提出其他匹配方法。</p><p>我们称之为patch匹配。</p><p>观察这两张X图，可以发现尽管像素值无法一一对应，但也存在着某些共同点。</p><p><img src="https://pic3.zhimg.com/80/v2-df0a51f10a46347704274ee6ddbb614a_1440w.webp" alt="img"></p><p>如上图所示，两张图中三个同色区域的结构完全一致！因此，我们就考虑，要将这两张图联系起来，无法进行全体像素对应，但是否能进行局部地匹配？</p><p>答案当然是肯定的。</p><p>相当于如果我要在一张照片中进行人脸定位，但是CNN不知道什么是人脸，我就告诉它：人脸上有三个特征，眼睛鼻子嘴巴是什么样，再告诉它这三个长啥样，只要CNN去搜索整张图，找到了这三个特征在的地方就定位到了人脸。同理，从标准的X图中我们提取出三个<strong>特征</strong>（<strong>feature</strong>）</p><p><img src="https://pic4.zhimg.com/80/v2-2230b625dcbac671af2646ff9d39a7d7_1440w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-2674d52504845d3fc062fa36a607fff2_1440w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-292a36d6fedd82498d406846e6a8fba2_1440w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-d71bef1581b18cdb5e13e5a472d7220e_1440w.webp" alt="img"></p><p>我们发现只要用这三个feature便可定位到X的某个局部。</p><p><img src="https://pic2.zhimg.com/80/v2-eaa1665a93ae616abad84971ac09f60d_1440w.webp" alt="img"></p><p>feature在CNN中也被成为卷积核（filter），一般是3X3，或者5X5的大小。</p><h2 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h2><p>举个栗子</p><p>取 feature里的（1，1）元素值，再取图像上蓝色框内的（1，1）元素值，二者相乘等于1。把这个结果1填入新的图中。</p><p><img src="https://pic1.zhimg.com/80/v2-e96f9de5db221fc8a0e3ddd5e8ba0514_1440w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-a9af9a7d6d5208720df375d1b79634a3_1440w.webp" alt="img"></p><p>同理再继续计算其他8个坐标处的值</p><p><img src="https://pic2.zhimg.com/80/v2-dd84ec4256cfbae35f4b3fd1c0bd1e5d_1440w.webp" alt="img"></p><p>9个都计算完了就会变成这样。</p><p><img src="https://pic3.zhimg.com/80/v2-725dd797cb015fa424524a4d366c214a_1440w.webp" alt="img"></p><p>接下来的工作是对右图九个值求平均，得到一个均值，将均值填入一张新的图中。</p><p>这张新的图我们称之为 <strong>feature map</strong> （<strong>特征图</strong>）</p><p><img src="https://pic3.zhimg.com/80/v2-68a6efb63fbbb0b83ebded0d6268d0fe_1440w.webp" alt="img"></p><p>可能有小盆友要举手问了，为什么蓝色框要放在图中这个位置呢？</p><p>这只是个栗子嘛。 这个蓝色框我们称之为 “窗口”，窗口的特性呢，就是要会滑动。</p><p>其实最开始，它应该在起始位置。</p><p><img src="https://pic4.zhimg.com/80/v2-6b3596592e0122e3c5dfd66255a9c773_1440w.webp" alt="img"></p><p>进行卷积对应相乘运算并求得均值后，滑动窗便开始向右边滑动。根据步长的不同选择滑动幅度。</p><p>比如，若 步长 stride=1，就往右平移一个像素。</p><p><img src="https://pic3.zhimg.com/80/v2-c9d84fa9f5fc1b826d44e2d95aaec7de_1440w.webp" alt="img"></p><p>若 步长 stride=2，就往右平移两个像素。</p><p><img src="https://pic2.zhimg.com/80/v2-09338fc4abadd746badea88f74c379a1_1440w.webp" alt="img"></p><p>就这么移动到最右边后，返回左边，开始第二排。同样，若步长stride=1，向下平移一个像素；stride=2则向下平移2个像素。</p><p><img src="https://pic4.zhimg.com/80/v2-26021c366f377a8ae7b941ea0d8f8c97_1440w.webp" alt="img"></p><p>好了,经过一系列卷积对应相乘，求均值运算后，我们终于把一张完整的feature map填满了。</p><p><img src="https://pic4.zhimg.com/80/v2-683c8d63e22eef01a271a08016006d17_1440w.webp" alt="img"></p><p>feature map是每一个feature从原始图像中提取出来的“特征”。其中的值，越接近为<strong>1</strong>表示对应位置和feature的<strong>匹配越完整</strong>，越是接近-1，表示对应位置和feature的反面匹配越完整，而值接近<strong>0</strong>的表示对应位置没有任何匹配或者说<strong>没有什么关联</strong>。一个feature作用于图片产生一张feature map，对这张X图来说，我们用的是3个feature，因此最终产生3个 feature map。</p><p><img src="https://pic1.zhimg.com/80/v2-fb26f8eeaea46279cf9e94695289b44c_1440w.webp" alt="img"></p><h2 id="非线性激活层"><a href="#非线性激活层" class="headerlink" title="非线性激活层"></a>非线性激活层</h2><p>卷积层对原图运算多个卷积产生一组线性激活响应，而非线性激活层是对之前的结果进行一个非线性的激活响应。</p><p>在神经网络中用到最多的非线性激活函数是Relu函数，它的公式定义如下：<br>$$<br>f(x)=max(0,x)<br>$$<br>即，保留大于等于0的值，其余所有小于0的数值直接改写为0。</p><p>为什么要这么做呢？上面说到，卷积后产生的特征图中的值，越靠近1表示与该特征越关联，越靠近-1表示越不关联，而我们进行特征提取时，为了使得数据更少，操作更方便，就直接舍弃掉那些不相关联的数据。</p><p>如下图所示：&gt;=0的值不变</p><p><img src="https://pic3.zhimg.com/80/v2-f1f4029c3ff8d2bbb138fcdc7af090fe_1440w.webp" alt="img"></p><p>而&lt;0的值一律改写为0</p><p><img src="https://pic4.zhimg.com/80/v2-b9508442abbab0395810df7f288ceda7_1440w.webp" alt="img"></p><p>得到非线性激活函数作用后 的结果：</p><p><img src="https://pic4.zhimg.com/80/v2-f9af9fde70d5d3b7db5562956c6cc213_1440w.webp" alt="img"></p><h2 id="pooling池化层"><a href="#pooling池化层" class="headerlink" title="pooling池化层"></a>pooling池化层</h2><p>卷积操作后，我们得到了一张张有着不同值的feature map，尽管数据量比原图少了很多，但还是过于庞大（比较深度学习动不动就几十万张训练图片），因此接下来的池化操作就可以发挥作用了，它最大的目标就是减少数据量。</p><p>池化分为两种，Max Pooling 最大池化、Average Pooling平均池化。顾名思义，最大池化就是取最大值，平均池化就是取平均值。</p><p>拿最大池化举例：选择池化尺寸为2x2，因为选定一个2x2的窗口，在其内选出最大值更新进新的feature map。</p><p><img src="https://pic4.zhimg.com/80/v2-bdc0421a13e06122b6d13fb84cdf5e9f_1440w.webp" alt="img"></p><p>同样向右依据步长滑动窗口。</p><p><img src="https://pic3.zhimg.com/80/v2-bc7736e0a815c8db07a855c35234b76e_1440w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-e58c86e2a784a341afe648607ab2f1a7_1440w.webp" alt="img"></p><p>最终得到池化后的feature map。可明显发现数据量减少了很多。</p><p>因为最大池化保留了每一个小块内的最大值，所以它相当于保留了这一块最佳匹配结果（因为值越接近1表示匹配越好）。这也就意味着它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。这也就能够看出，CNN能够发现图像中是否具有某种特征，而不用在意到底在哪里具有这种特征。这也就能够帮助解决之前提到的计算机逐一像素匹配的死板做法。</p><p>到这里就介绍了CNN的基本配置—卷积层、Relu层、池化层。</p><p>在常见的几种CNN中，这三层都是可以堆叠使用的，将前一层的输入作为后一层的输出。比如：</p><p><img src="https://pic3.zhimg.com/80/v2-141ed65cf0003c9550a8d57fe7c6afb2_1440w.webp" alt="img"></p>]]></content>
    
    
    <summary type="html">神经网络</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Scapy</title>
    <link href="http://example.com/2022/11/16/scapy/"/>
    <id>http://example.com/2022/11/16/scapy/</id>
    <published>2022-11-16T08:00:00.000Z</published>
    <updated>2022-11-16T08:23:33.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载和安装Scapy"><a href="#下载和安装Scapy" class="headerlink" title="下载和安装Scapy"></a>下载和安装Scapy</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install scapy #Anconada下载</span><br><span class="line">pip install scapy #pip下载</span><br></pre></td></tr></table></figure><h1 id="开始使用Scapy"><a href="#开始使用Scapy" class="headerlink" title="开始使用Scapy"></a>开始使用Scapy</h1><p>在window是在打开cmd命令并且确保自己有管理员权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scapy</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221103082635.png?raw=true" alt="blog_images20221103082635.png"></p><p>scapy每一个协议都是一个类，所以当我们调用这些协议的时候我们必须对协议进行实例化才可以进行调用。</p><p>执行explore()命令查看scapy里面的类</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images331017acd6aad38d4c713ec7a94001a.jpg?raw=true" alt="blog_images331017acd6aad38d4c713ec7a94001a.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>explore()</span><br><span class="line">Packets contained <span class="keyword">in</span> scapy.layers.inet:</span><br><span class="line">Class                     |Name</span><br><span class="line">--------------------------|-------------------------------------------</span><br><span class="line">ICMP                      |ICMP</span><br><span class="line">ICMPerror                 |ICMP <span class="keyword">in</span> ICMP</span><br><span class="line">IP                        |IP</span><br><span class="line">IPOption                  |IP Option</span><br><span class="line">IPOption_Address_Extension|IP Option Address Extension</span><br><span class="line">IPOption_EOL              |IP Option End of Options <span class="type">List</span></span><br><span class="line">IPOption_LSRR             |IP Option Loose Source <span class="keyword">and</span> Record Route</span><br><span class="line">IPOption_MTU_Probe        |IP Option MTU Probe</span><br><span class="line">IPOption_MTU_Reply        |IP Option MTU Reply</span><br><span class="line">IPOption_NOP              |IP Option No Operation</span><br><span class="line">IPOption_RR               |IP Option Record Route</span><br><span class="line">IPOption_Router_Alert     |IP Option Router Alert</span><br><span class="line">IPOption_SDBM             |IP Option Selective Directed Broadcast Mode</span><br><span class="line">IPOption_SSRR             |IP Option Strict Source <span class="keyword">and</span> Record Route</span><br><span class="line">IPOption_Security         |IP Option Security</span><br><span class="line">IPOption_Stream_Id        |IP Option Stream ID</span><br><span class="line">IPOption_Timestamp        |IP Option Timestamp</span><br><span class="line">IPOption_Traceroute       |IP Option Traceroute</span><br><span class="line">IPerror                   |IP <span class="keyword">in</span> ICMP</span><br><span class="line">TCP                       |TCP</span><br><span class="line">TCPerror                  |TCP <span class="keyword">in</span> ICMP</span><br><span class="line">UDP                       |UDP</span><br><span class="line">UDPerror                  |UDP <span class="keyword">in</span> ICMP</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>各个协议默认值</strong></p><p>数据链路层：</p><p>Ether()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst        : DestMACField                        = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">src        : SourceMACField                      = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="built_in">type</span>       : XShortEnumField                     = (<span class="string">&#x27;36864&#x27;</span>)</span><br></pre></td></tr></table></figure><p>网络层：</p><p>IP()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version    : BitField  (<span class="number">4</span> bits)                  = (<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">ihl        : BitField  (<span class="number">4</span> bits)                  = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">tos        : XByteField                          = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="built_in">len</span>        : ShortField                          = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="built_in">id</span>         : ShortField                          = (<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">flags      : FlagsField                          = (<span class="string">&#x27;&lt;Flag 0 ()&gt;&#x27;</span>)</span><br><span class="line">frag       : BitField  (<span class="number">13</span> bits)                 = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">ttl        : ByteField                           = (<span class="string">&#x27;64&#x27;</span>)</span><br><span class="line">proto      : ByteEnumField                       = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">chksum     : XShortField                         = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">src        : SourceIPField                       = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">dst        : DestIPField                         = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">options    : PacketListField                     = (<span class="string">&#x27;[]&#x27;</span>)</span><br></pre></td></tr></table></figure><p>ARP()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hwtype     : XShortField                         = (<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">ptype      : XShortEnumField                     = (<span class="string">&#x27;2048&#x27;</span>)</span><br><span class="line">hwlen      : FieldLenField                       = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">plen       : FieldLenField                       = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">op         : ShortEnumField                      = (<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">hwsrc      : MultipleTypeField (SourceMACField, StrFixedLenField) = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">psrc       : MultipleTypeField (SourceIPField, SourceIP6Field, StrFixedLenField) = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">hwdst      : MultipleTypeField (MACField, StrFixedLenField) = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">pdst       : MultipleTypeField (IPField, IP6Field, StrFixedLenField) = (<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><p>ICMP()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>       : ByteEnumField                       = (<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">code       : MultiEnumField (Depends on <span class="number">8</span>)       = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">chksum     : XShortField                         = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="built_in">id</span>         : XShortField (Cond)                  = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">seq        : XShortField (Cond)                  = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">ts_ori     : ICMPTimeStampField (Cond)           = (<span class="string">&#x27;22263044&#x27;</span>)</span><br><span class="line">ts_rx      : ICMPTimeStampField (Cond)           = (<span class="string">&#x27;22263044&#x27;</span>)</span><br><span class="line">ts_tx      : ICMPTimeStampField (Cond)           = (<span class="string">&#x27;22263044&#x27;</span>)</span><br><span class="line">gw         : IPField (Cond)                      = (<span class="string">&quot;&#x27;0.0.0.0&#x27;&quot;</span>)</span><br><span class="line">ptr        : ByteField (Cond)                    = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">reserved   : ByteField (Cond)                    = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">length     : ByteField (Cond)                    = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">addr_mask  : IPField (Cond)                      = (<span class="string">&quot;&#x27;0.0.0.0&#x27;&quot;</span>)</span><br><span class="line">nexthopmtu : ShortField (Cond)                   = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">unused     : MultipleTypeField (ShortField, IntField, StrFixedLenField) = (<span class="string">&quot;b&#x27;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>传输层：</p><p>TCP()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sport      : ShortEnumField                      = (<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line">dport      : ShortEnumField                      = (<span class="string">&#x27;80&#x27;</span>)</span><br><span class="line">seq        : IntField                            = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">ack        : IntField                            = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">dataofs    : BitField  (<span class="number">4</span> bits)                  = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">reserved   : BitField  (<span class="number">3</span> bits)                  = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">flags      : FlagsField                          = (<span class="string">&#x27;&lt;Flag 2 (S)&gt;&#x27;</span>)</span><br><span class="line">window     : ShortField                          = (<span class="string">&#x27;8192&#x27;</span>)</span><br><span class="line">chksum     : XShortField                         = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">urgptr     : ShortField                          = (<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">options    : TCPOptionsField                     = (<span class="string">&quot;b&#x27;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>UDP()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sport      : ShortEnumField                      = (<span class="string">&#x27;53&#x27;</span>)</span><br><span class="line">dport      : ShortEnumField                      = (<span class="string">&#x27;53&#x27;</span>)</span><br><span class="line"><span class="built_in">len</span>        : ShortField                          = (<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">chksum     : XShortField                         = (<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><p>应用层：</p><p>DHCP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options    : DHCPOptionsField                    = (<span class="string">&quot;b&#x27;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>scapy所有函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">IPID_count          : Identify IP <span class="built_in">id</span> values classes <span class="keyword">in</span> a <span class="built_in">list</span> of packets</span><br><span class="line">arpcachepoison      : Poison target<span class="string">&#x27;s cache with (your MAC,victim&#x27;</span>s IP) couple</span><br><span class="line">arping              : Send ARP who-has requests to determine which hosts are up</span><br><span class="line">arpleak             : Exploit ARP leak flaws, like NetBSD-SA2017-<span class="number">002.</span></span><br><span class="line">bind_layers         : Bind <span class="number">2</span> layers on some specific fields<span class="string">&#x27; values.</span></span><br><span class="line"><span class="string">bridge_and_sniff    : Forward traffic between interfaces if1 and if2, sniff and return</span></span><br><span class="line"><span class="string">chexdump            : Build a per byte hexadecimal representation</span></span><br><span class="line"><span class="string">computeNIGroupAddr  : Compute the NI group Address. Can take a FQDN as input parameter</span></span><br><span class="line"><span class="string">corrupt_bits        :</span></span><br><span class="line"><span class="string">corrupt_bytes       :</span></span><br><span class="line"><span class="string">defrag              : defrag(plist) -&gt; ([not fragmented], [defragmented],</span></span><br><span class="line"><span class="string">defragment          : defragment(plist) -&gt; plist defragmented as much as possible</span></span><br><span class="line"><span class="string">dhcp_request        : Send a DHCP discover request and return the answer</span></span><br><span class="line"><span class="string">dyndns_add          : Send a DNS add message to a nameserver for &quot;name&quot; to have a new &quot;rdata&quot;</span></span><br><span class="line"><span class="string">dyndns_del          : Send a DNS delete message to a nameserver for &quot;name&quot;</span></span><br><span class="line"><span class="string">etherleak           : Exploit Etherleak flaw</span></span><br><span class="line"><span class="string">explore             : Function used to discover the Scapy layers and protocols.</span></span><br><span class="line"><span class="string">fletcher16_checkbytes: Calculates the Fletcher-16 checkbytes returned as 2 byte binary-string.</span></span><br><span class="line"><span class="string">fletcher16_checksum : Calculates Fletcher-16 checksum of the given buffer.</span></span><br><span class="line"><span class="string">fragleak            : --</span></span><br><span class="line"><span class="string">fragleak2           : --</span></span><br><span class="line"><span class="string">fragment            : Fragment a big IP datagram</span></span><br><span class="line"><span class="string">fuzz                :</span></span><br><span class="line"><span class="string">getmacbyip          : Return MAC address corresponding to a given IP address</span></span><br><span class="line"><span class="string">getmacbyip6         : Returns the MAC address corresponding to an IPv6 address</span></span><br><span class="line"><span class="string">hexdiff             :</span></span><br><span class="line"><span class="string">hexdump             : Build a tcpdump like hexadecimal view</span></span><br><span class="line"><span class="string">hexedit             : Run hexedit on a list of packets, then return the edited packets.</span></span><br><span class="line"><span class="string">hexstr              : Build a fancy tcpdump like hex from bytes.</span></span><br><span class="line"><span class="string">import_hexcap       : Imports a tcpdump like hexadecimal view</span></span><br><span class="line"><span class="string">is_promisc          : Try to guess if target is in Promisc mode. The target is provided by its ip.</span></span><br><span class="line"><span class="string">linehexdump         : Build an equivalent view of hexdump() on a single line</span></span><br><span class="line"><span class="string">ls                  : List  available layers, or infos on a given layer class or name.</span></span><br><span class="line"><span class="string">neighsol            : Sends and receive an ICMPv6 Neighbor Solicitation message</span></span><br><span class="line"><span class="string">overlap_frag        : Build overlapping fragments to bypass NIPS</span></span><br><span class="line"><span class="string">promiscping         : Send ARP who-has requests to determine which hosts are in promiscuous mode</span></span><br><span class="line"><span class="string">rdpcap              : Read a pcap or pcapng file and return a packet list</span></span><br><span class="line"><span class="string">report_ports        : portscan a target and output a LaTeX table</span></span><br><span class="line"><span class="string">restart             : Restarts scapy</span></span><br><span class="line"><span class="string">rfc                 :</span></span><br><span class="line"><span class="string">send                :</span></span><br><span class="line"><span class="string">sendp               :</span></span><br><span class="line"><span class="string">sendpfast           : Send packets at layer 2 using tcpreplay for performance</span></span><br><span class="line"><span class="string">sniff               :</span></span><br><span class="line"><span class="string">split_layers        : Split 2 layers previously bound.</span></span><br><span class="line"><span class="string">sr                  :</span></span><br><span class="line"><span class="string">sr1                 :</span></span><br><span class="line"><span class="string">sr1flood            : Flood and receive packets at layer 3 and return only the first answer</span></span><br><span class="line"><span class="string">srbt                : send and receive using a bluetooth socket</span></span><br><span class="line"><span class="string">srbt1               : send and receive 1 packet using a bluetooth socket</span></span><br><span class="line"><span class="string">srflood             : Flood and receive packets at layer 3</span></span><br><span class="line"><span class="string">srloop              :</span></span><br><span class="line"><span class="string">srp                 :</span></span><br><span class="line"><span class="string">srp1                :</span></span><br><span class="line"><span class="string">srp1flood           : Flood and receive packets at layer 2 and return only the first answer</span></span><br><span class="line"><span class="string">srpflood            : Flood and receive packets at layer 2</span></span><br><span class="line"><span class="string">srploop             :</span></span><br><span class="line"><span class="string">tcpdump             : Run tcpdump or tshark on a list of packets.</span></span><br><span class="line"><span class="string">tdecode             :</span></span><br><span class="line"><span class="string">traceroute          : Instant TCP traceroute</span></span><br><span class="line"><span class="string">traceroute6         : Instant TCP traceroute using IPv6</span></span><br><span class="line"><span class="string">traceroute_map      : Util function to call traceroute on multiple targets, then</span></span><br><span class="line"><span class="string">tshark              : Sniff packets and print them calling pkt.summary().</span></span><br><span class="line"><span class="string">wireshark           :</span></span><br><span class="line"><span class="string">wrpcap              : Write a list of packets to a pcap file</span></span><br></pre></td></tr></table></figure><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>构建数据包并且使用它，scapy采用分层的方式去构造数据包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建数据链路层的包</span></span><br><span class="line">ether=Ether()</span><br><span class="line"><span class="comment">#构建ip()数据包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=IP()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip</span><br><span class="line">&lt;IP  |&gt;</span><br><span class="line"><span class="comment">#构建Ether/IP/TCP</span></span><br><span class="line">pkt =Ether()/IP()/TCP()</span><br><span class="line"><span class="comment">#构建HTTP的包</span></span><br><span class="line">pkt = IP()/TCP()/<span class="string">&quot;GET HTTP/1.0\r\n\r\n&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip.show()</span><br><span class="line"><span class="comment">###[ IP ]### 以下是IP类属性的默认值</span></span><br><span class="line">  version   = <span class="number">4</span></span><br><span class="line">  ihl       = <span class="literal">None</span></span><br><span class="line">  tos       = <span class="number">0x0</span> <span class="comment">#8位服务类型TOS</span></span><br><span class="line">  <span class="built_in">len</span>       = <span class="literal">None</span> <span class="comment">#16位总长度（字节）</span></span><br><span class="line">  <span class="built_in">id</span>        = <span class="number">1</span></span><br><span class="line">  flags     = </span><br><span class="line">  frag      = <span class="number">0</span></span><br><span class="line">  ttl       = <span class="number">64</span>  <span class="comment">#ttl是转发路由的数量，每转发一次ttl减去1如果到0则会发送ICMP报告超时</span></span><br><span class="line">  proto     = ip  <span class="comment">#8位协议 (TCP, UDP 或其他)</span></span><br><span class="line">  chksum    = <span class="literal">None</span> <span class="comment">#16位IP首部校验和</span></span><br><span class="line">  src       = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="comment">#源地址  127.0.0.1为本机地址</span></span><br><span class="line">  dst       = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="comment">#目的地址</span></span><br><span class="line">  \options   \</span><br></pre></td></tr></table></figure><p>堆叠层</p><p>这个 <code>/</code> 运算符用作两层之间的合成运算符。这样做时，下层可以根据上层重载一个或多个默认字段。（您仍然可以提供所需的值）。字符串可以用作原始层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip/TCP()</span><br><span class="line">&lt;IP  frag=<span class="number">0</span> proto=tcp |&lt;TCP  |&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Ether()/IP()/TCP()</span><br><span class="line">&lt;Ether  <span class="built_in">type</span>=IPv4 |&lt;IP  frag=<span class="number">0</span> proto=tcp |&lt;TCP  |&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>IP()/TCP()/<span class="string">&quot;GET / HTTP/1.0\n\r\n&quot;</span></span><br><span class="line">&lt;IP  frag=<span class="number">0</span> proto=tcp |&lt;TCP  |&lt;Raw  load=<span class="string">&#x27;GET / HTTP/1.0\n\r\n&#x27;</span> |&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Ether()/IP()/IP()/UDP()</span><br><span class="line">&lt;Ether  <span class="built_in">type</span>=IPv4 |&lt;IP  frag=<span class="number">0</span> proto=<span class="number">4</span> |&lt;IP  frag=<span class="number">0</span> proto=udp |&lt;UDP  |&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>IP(proto=<span class="number">55</span>)/TCP()</span><br><span class="line">&lt;IP  frag=<span class="number">0</span> proto=<span class="number">55</span> |&lt;TCP  |&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="解析数据包"><a href="#解析数据包" class="headerlink" title="解析数据包"></a>解析数据包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw(IP()) <span class="comment">#字节方式显示数据包</span></span><br><span class="line"><span class="string">b&#x27;E\x00\x00\x14\x00\x01\x00\x00@\x00|\xe7\x7f\x00\x00\x01\x7f\x00\x00\x01&#x27;</span> <span class="comment">#八进制展示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>IP(_) <span class="comment">#转换</span></span><br><span class="line">&lt;IP  version=<span class="number">4</span> ihl=<span class="number">5</span> tos=<span class="number">0x0</span> <span class="built_in">len</span>=<span class="number">20</span> <span class="built_in">id</span>=<span class="number">1</span> flags= frag=<span class="number">0</span> ttl=<span class="number">64</span> proto=ip chksum=<span class="number">0x7ce7</span> src=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> dst=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> |&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=Ether()/IP(dst=<span class="string">&quot;www.slashdot.org&quot;</span>)/TCP()/<span class="string">&quot;GET /index.html HTTP/1.0 \n\n&quot;</span> <span class="comment">#Ether是以太网协议</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hexdump(ip) <span class="comment">#字节转换成十六进制</span></span><br><span class="line"><span class="number">0000</span>  <span class="number">30</span> FC <span class="number">68</span> 4F 6A <span class="number">12</span> 9C 2D CD 01 <span class="number">88</span> 7E 08 <span class="number">00</span> <span class="number">45</span> <span class="number">00</span>  <span class="number">0.</span>hOj..-...~..E.</span><br><span class="line"><span class="number">00</span>10  <span class="number">00</span> <span class="number">43</span> <span class="number">00</span> 01 <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> 06 <span class="number">33</span> 3B C0 A8 01 <span class="number">69</span> <span class="number">68</span> <span class="number">12</span>  .C....@<span class="number">.3</span>;...ih.</span><br><span class="line">0020  1D <span class="number">56</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">50</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">50</span> 02  .V...P........P.</span><br><span class="line">0030  <span class="number">20</span> <span class="number">00</span> <span class="number">76</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">47</span> <span class="number">45</span> <span class="number">54</span> <span class="number">20</span> 2F <span class="number">69</span> 6E <span class="number">64</span> <span class="number">65</span> <span class="number">78</span>   .v8..GET /index</span><br><span class="line">0040  2E <span class="number">68</span> <span class="number">74</span> 6D 6C <span class="number">20</span> <span class="number">48</span> <span class="number">54</span> <span class="number">54</span> <span class="number">50</span> 2F <span class="number">31</span> 2E <span class="number">30</span> <span class="number">20</span> 0A  .html HTTP/<span class="number">1.0</span> .</span><br><span class="line">0050  0A                                               .</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=raw(ip) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;0\xfchOj\x12\x9c-\xcd\x01\x88~\x08\x00E\x00\x00C\x00\x01\x00\x00@\x063;\xc0\xa8\x01ih\x12\x1dV\x00\x14\x00P\x00\x00\x00\x00\x00\x00\x00\x00P\x02 \x00v8\x00\x00GET /index.html HTTP/1.0 \n\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=Ether(b) <span class="comment">#转换成Ether协议格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;Ether  dst=<span class="number">30</span>:fc:<span class="number">68</span>:4f:6a:<span class="number">12</span> src=9c:2d:cd:01:<span class="number">88</span>:7e <span class="built_in">type</span>=IPv4 |&lt;IP  version=<span class="number">4</span> ihl=<span class="number">5</span> tos=<span class="number">0x0</span> <span class="built_in">len</span>=<span class="number">67</span> <span class="built_in">id</span>=<span class="number">1</span> flags= frag=<span class="number">0</span> ttl=<span class="number">64</span> proto=tcp chksum=<span class="number">0x333b</span> src</span><br><span class="line">=<span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span> dst=<span class="number">104.18</span><span class="number">.29</span><span class="number">.86</span> |&lt;TCP  sport=ftp_data dport=http seq=<span class="number">0</span> ack=<span class="number">0</span> dataofs=<span class="number">5</span> reserved=<span class="number">0</span> flags=S window=<span class="number">8192</span> chksum=<span class="number">0x7638</span> urgptr=<span class="number">0</span> |&lt;Raw  load=<span class="string">&#x27;GET /index.html HTTP/1.0 \n\n&#x27;</span> |&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.hide_defaults()<span class="comment">#隐藏默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;Ether  dst=<span class="number">30</span>:fc:<span class="number">68</span>:4f:6a:<span class="number">12</span> src=9c:2d:cd:01:<span class="number">88</span>:7e <span class="built_in">type</span>=IPv4 |&lt;IP  ihl=<span class="number">5</span> <span class="built_in">len</span>=<span class="number">67</span> frag=<span class="number">0</span> proto=tcp chksum=<span class="number">0x333b</span> src=<span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span> dst=<span class="number">104.18</span><span class="number">.29</span><span class="number">.86</span> |&lt;TCP</span><br><span class="line">  dataofs=<span class="number">5</span> chksum=<span class="number">0x7638</span> |&lt;Raw  load=<span class="string">&#x27;GET /index.html HTTP/1.0 \n\n&#x27;</span> |&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="读取PCAP文件"><a href="#读取PCAP文件" class="headerlink" title="读取PCAP文件"></a>读取PCAP文件</h2><p>您可以从 pcap 文件中读取数据包并将它们写入 pcap 文件。pcap文件是抓包获取到的文件可以通过scapy进行解析</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221103104931.png?raw=true" alt="blog_images20221103104931.png"></p><p>wireshark对应的是 </p><ul><li>Frame：物理层</li><li>Ethernet：数据链路层</li><li>Internet：网络层Internet Control Message Protocol</li><li>Transmission:传输层</li><li>Hypertext Transfer Protocol ：应用层</li></ul><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark.HTTPS可以利用scapy进行解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dpkt = sniff(iface = <span class="string">&quot;wlan&quot;</span>,count = <span class="number">10</span>)</span><br><span class="line">wrpcap(<span class="string">&quot;mypack.pcap&quot;</span>,dpkt) <span class="comment">#保存pcap文件 pcap文件可以用wireshark打开，wireshark抓取的包保存为.pcap文件也可以被scapy解析</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=rdpcap(<span class="string">&quot;mypack.pcap&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br></pre></td></tr></table></figure><h2 id="图像转存-PDF，PS"><a href="#图像转存-PDF，PS" class="headerlink" title="图像转存(PDF，PS)"></a>图像转存(PDF，PS)</h2><p>如果您安装了 PyX，您可以制作一个数据包或数据包列表的图形 PostScript/PDF 转储（请参见下面丑陋的 PNG 图像。PostScript/PDF 的质量要好得多……）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">423</span>].pdfdump(layer_shift=<span class="number">1</span>)</span><br><span class="line">a[<span class="number">423</span>].psdump(<span class="string">&quot;/tmp/isakmp_pkt.eps&quot;</span>,layer_shift=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://scapy.readthedocs.io/en/latest/_images/isakmp_dump.png" alt="_images/isakmp_dump.png"></p><table><thead><tr><th>命令</th><th>影响</th></tr></thead><tbody><tr><td>raw(pkt)</td><td>以字节的方式来显示数据包</td></tr><tr><td>hexdump(pkt)</td><td>把数据包（八进制）进行十六进制转储</td></tr><tr><td>ls(包)</td><td>有字段值的列表</td></tr><tr><td>pkt.summary()</td><td>以不超过一行的摘要来简单描述数据包</td></tr><tr><td>pkt.show()</td><td>多行数据展示数据包的信息</td></tr><tr><td>pkt.show2()</td><td>与 show 相同，但在组装的数据包上（例如，计算校验和）</td></tr><tr><td>pkt.sprintf()</td><td>用数据包的字段值填充格式字符串</td></tr><tr><td>pkt.decode_payload_as()</td><td>改变有效载荷的解码方式</td></tr><tr><td>pkt.psdump()</td><td>绘制带有解释性剖析的 PostScript 图表</td></tr><tr><td>pkt.pdfdump()</td><td>绘制带有解释性剖析的 PDF</td></tr><tr><td>pkt.command()</td><td>返回一个可以生成数据包的 Scapy 命令</td></tr></tbody></table><h2 id="生成数据包集"><a href="#生成数据包集" class="headerlink" title="生成数据包集"></a>生成数据包集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=IP(dst=<span class="string">&quot;www.slashdot.org/30&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;IP  dst=Net(<span class="string">&quot;www.slashdot.org/30&quot;</span>) |&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[p <span class="keyword">for</span> p <span class="keyword">in</span> a] <span class="comment">#iPV4是32位地址,子网掩码是30位，主机号有两位，所以有四个数据包</span></span><br><span class="line">[&lt;IP  dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.84</span> |&gt;,</span><br><span class="line"> &lt;IP  dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.85</span> |&gt;,</span><br><span class="line"> &lt;IP  dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.86</span> |&gt;,</span><br><span class="line"> &lt;IP  dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.87</span> |&gt;]</span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=IP(ttl=[<span class="number">1</span>,<span class="number">2</span>,(<span class="number">5</span>,<span class="number">9</span>)])<span class="comment">#左闭右闭</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&lt;IP  ttl=[<span class="number">1</span>, <span class="number">2</span>, (<span class="number">5</span>, <span class="number">9</span>)] |&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[p <span class="keyword">for</span> p <span class="keyword">in</span> b]</span><br><span class="line">[&lt;IP  ttl=<span class="number">1</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">2</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">5</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">6</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">7</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">8</span> |&gt;,</span><br><span class="line"> &lt;IP  ttl=<span class="number">9</span> |&gt;]</span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=TCP(dport=[<span class="number">80</span>,<span class="number">443</span>]) <span class="comment">#http端口号是80 https的端口号是443</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;TCP  dport=[<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;https&#x27;</span>] |&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[p <span class="keyword">for</span> p <span class="keyword">in</span> c]</span><br><span class="line">[&lt;TCP  dport=http |&gt;,</span><br><span class="line"> &lt;TCP  dport=https |&gt;]</span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[p <span class="keyword">for</span> p <span class="keyword">in</span> a/c]</span><br><span class="line">[&lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.84</span> |&lt;TCP  dport=http |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.84</span> |&lt;TCP  dport=https |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.85</span> |&lt;TCP  dport=http |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.85</span> |&lt;TCP  dport=https |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.86</span> |&lt;TCP  dport=http |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.86</span> |&lt;TCP  dport=https |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.87</span> |&lt;TCP  dport=http |&gt;&gt;,</span><br><span class="line"> &lt;IP  frag=<span class="number">0</span> proto=tcp dst=<span class="number">104.18</span><span class="number">.28</span><span class="number">.87</span> |&lt;TCP  dport=https |&gt;&gt;]</span><br></pre></td></tr></table></figure><p>ip地址和http组合：ip地址有四个，http有两个，组合有八个</p><p>某些操作（例如从数据包构建字符串）无法对一组数据包起作用。在这些情况下，如果您忘记展开一组数据包，则只有您忘记生成的列表的第一个元素将用于组装数据包。另一方面，可以将数据包集合移动到PacketList对象中，该对象提供对数据包列表的一些操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p=PacketList([p <span class="keyword">for</span> p <span class="keyword">in</span> a/c])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&lt;PacketList: TCP:<span class="number">8</span> UDP:<span class="number">0</span> ICMP:<span class="number">0</span> Other:<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>summary()</td><td>显示每个数据包的摘要列表</td></tr><tr><td>nsummary()</td><td>同上，包号</td></tr><tr><td>conversations()</td><td>显示对话图</td></tr><tr><td>show()</td><td>显示首选表示（通常是 nsummary()）</td></tr><tr><td>filter()</td><td>返回使用 lambda 函数过滤的数据包列表</td></tr><tr><td>hexdump()</td><td>返回所有数据包的十六进制转储</td></tr><tr><td>hexraw()</td><td>返回所有数据包的原始层的十六进制转储</td></tr><tr><td>padding()</td><td>返回带有填充的数据包的十六进制转储</td></tr><tr><td>nzpadding()</td><td>返回具有非零填充的数据包的十六进制转储</td></tr><tr><td>plot()</td><td>绘制应用于数据包列表的 lambda 函数</td></tr><tr><td>make_table()</td><td>根据 lambda 函数显示表格</td></tr></tbody></table><h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><p>现在我们知道如何操作数据包了。让我们看看如何发送它们。send() 函数将在第 3 层（网络层）发送数据包。也就是说，它将为您处理路由和第 2 层（数据链路层）。sendp() 函数将在第 2 层（数据链路层）工作。您可以选择正确的接口和正确的链路层协议。如果return_packets=True 作为参数传递，send() 和 sendp() 也将返回已发送的数据包列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send(pkg, iface=<span class="string">&#x27;以太网 4&#x27;</span>, loop=<span class="number">1</span>, inter=<span class="number">1</span>, timeout=<span class="number">1</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pkg：数据包</span></span><br><span class="line"><span class="string">iface：网口名称（区分大小写，中英文）</span></span><br><span class="line"><span class="string">loop：循环发送</span></span><br><span class="line"><span class="string">inter：每隔1秒发送</span></span><br><span class="line"><span class="string">timeout：超时1秒就丢弃</span></span><br><span class="line"><span class="string">verbose：False不显示详细信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>层级</th><th>描述</th></tr></thead><tbody><tr><td>sr</td><td>3</td><td>发送并接收所有包</td></tr><tr><td>sr1</td><td>3</td><td>发送，接收回复的包 （一个一个收）</td></tr><tr><td>srp</td><td>2</td><td>发送并接收所有包</td></tr><tr><td>srp1</td><td>2</td><td>发送，接收回复的包</td></tr><tr><td>send</td><td>3</td><td>只发送不接收</td></tr><tr><td>sendp</td><td>2</td><td>只发送不接收</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">send(IP(dst=<span class="string">&quot;1.2.3.4&quot;</span>)/ICMP())</span><br><span class="line">sendp(Ether()/IP(dst=<span class="string">&quot;1.2.3.4&quot;</span>,ttl=(<span class="number">1</span>,<span class="number">4</span>)), iface=<span class="string">&quot;eth1&quot;</span>)</span><br><span class="line">sendp(<span class="string">&quot;I&#x27;m travelling on Ethernet&quot;</span>, iface=<span class="string">&quot;eth1&quot;</span>, loop=<span class="number">1</span>, inter=<span class="number">0.2</span>)</span><br><span class="line">sendp(rdpcap(<span class="string">&quot;/tmp/pcapfile&quot;</span>)) <span class="comment"># tcpreplay</span></span><br><span class="line">send(IP(dst=<span class="string">&#x27;127.0.0.1&#x27;</span>), return_packets=<span class="literal">True</span>)</span><br><span class="line">pkt = IP(src=<span class="string">&#x27;10.0.1.123&#x27;</span>, dst=<span class="string">&#x27;11.0.1.111&#x27;</span>) / TCP(sport=<span class="number">12345</span>, dport=<span class="number">5555</span>) / data</span><br><span class="line">send(pkt)  </span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221116155049.png?raw=true" alt="blog_images20221116155049.png"></p><h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>函数 fuzz() 能够更改任何不由其值是随机且其类型适合于该字段的对象<strong>计算的默认值（如校验和）</strong>。这可以快速构建模糊模板并循环发送它们。在下面的例子中，IP层正常，UDP和NTP层被fuzz。UDP 校验和将正确，UDP 目标端口将被 NTP 重载为 123，并且 NTP 版本将被强制为 4。所有其他端口将被随机化。注意：如果你在 IP 层使用 fuzz()，src 和 dst 参数不会是随机的，所以为了做到这一点，请使用 RandIP()。：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(IP(dst=<span class="string">&quot;target&quot;</span>)/fuzz(UDP()/NTP(version=<span class="number">4</span>)),loop=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="注入字节"><a href="#注入字节" class="headerlink" title="注入字节"></a>注入字节</h2><p>在一个数据包中，每个字段都有一个特定的类型。例如，IP 数据包的长度字段<code>len</code>需要一个整数。如果您正在开发 PoC，有时您会想要注入一些不适合该类型的值。这可以使用<code>RawVal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkt = IP(<span class="built_in">len</span>=RawVal(<span class="string">b&quot;NotAnInteger&quot;</span>), src=<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line"><span class="built_in">bytes</span>(pkt)</span><br><span class="line"><span class="string">b&#x27;H\x00NotAnInt\x0f\xb3er\x00\x01\x00\x00@\x00\x00\x00\x7f\x00\x00\x01\x7f\x00\x00\x01\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h2><p>抓包函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">sniff(count=<span class="number">0</span>,</span><br><span class="line">      store=<span class="number">1</span>,</span><br><span class="line">      offline=<span class="literal">None</span>,</span><br><span class="line">      prn=<span class="literal">None</span>,</span><br><span class="line">      <span class="built_in">filter</span>=<span class="literal">None</span>,</span><br><span class="line">      L2socket=<span class="literal">None</span>,</span><br><span class="line">      timeout=<span class="literal">None</span>,</span><br><span class="line">      opened_socket=<span class="literal">None</span>,</span><br><span class="line">      stop_filter=<span class="literal">None</span>,</span><br><span class="line">      iface=<span class="literal">None</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">count:指定最多嗅探多少个符合要求的报文，设置为0时则一直捕获</span></span><br><span class="line"><span class="string">store:指定保存抓取的数据包或者丢弃，1为保存，0为丢弃</span></span><br><span class="line"><span class="string">offline:从pcap文件中读取数据包，而不进行嗅探，默认为None</span></span><br><span class="line"><span class="string">prn:为每个数据包定义一个回调函数，回调函数会在捕获到符合 filter 的报文时被调用，通常使用 lambda 表达式来编写</span></span><br><span class="line"><span class="string">filter:用来筛选抓取的信息，其用法与常见抓包软件WireShark 等相同，遵循 BPF 语法</span></span><br><span class="line"><span class="string">L2socket:使用给定的L2socket</span></span><br><span class="line"><span class="string">timeout:在给定的事件后停止嗅探，默认为None</span></span><br><span class="line"><span class="string">opened_socket:对指定的对象使用.recv进行读取</span></span><br><span class="line"><span class="string">stop_filter:定义一个函数，决定在抓到指定的数据之后停止</span></span><br><span class="line"><span class="string">iface:指定抓包的网卡,不指定则代表所有网卡  eth0,eth1.....</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">sniff(<span class="built_in">filter</span>=<span class="string">&quot;ip src 172.31.100.222 and tcp and tcp port 80&quot;</span>, prn=<span class="keyword">lambda</span> x:x.summary())</span><br><span class="line"></span><br><span class="line">pkt = sniff(<span class="built_in">filter</span>=<span class="string">&quot;host 192.168.2.46&quot;</span>)</span><br><span class="line"><span class="comment">#常见的filter实例</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">host 192.168.2.46【筛选源地址或目的地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dst host 192.168.2.46【筛选目的地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">src host 192.168.2.46【筛选源地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ether host ff:ff:ff:ff:ff:ff【筛选以太网源地址或目的地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ether dst ff:ff:ff:ff:ff:ff【筛选以太网目的地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ether src ff:ff:ff:ff:ff:ff【筛选以太网源地址为192.168.2.46的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dst port 8080【筛选目的地址为8080端口的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">src port 8080【筛选源地址为8080端口的数据包】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">port 8080【筛选源地址和目的地址为8080的数据包，所有port前面都可以加上TCP和UDP】</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>发送和接收数据包 (sr)</p><p>sr() 函数用于发送数据包和接收答案。该函数返回几个数据包和答案，以及未回答的数据包。函数 sr1() 是一种变体，它只返回一个响应发送的数据包（或数据包集）的数据包。数据包必须是第 3 层数据包（IP、ARP 等）。函数 srp() 对第 2 层数据包（以太网、802.3 等）执行相同的操作。如果没有响应，则在达到超时时将分配一个 None 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = sr1(IP(dst=<span class="string">&quot;www.slashdot.org&quot;</span>)/ICMP()/<span class="string">&quot;XXXXXXXXXXX&quot;</span>) <span class="comment">#p为接收数据，一个一个接收</span></span><br><span class="line">p=sr(IP(dst=<span class="string">&quot;172.20.29.5/30&quot;</span>)/TCP(dport=[<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>]),inter=<span class="number">0.5</span>,retry=-<span class="number">2</span>,timeout=<span class="number">1</span>)<span class="comment">#全部接收</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Scapy</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>javaweb开发环境搭建(CentOS版本)</title>
    <link href="http://example.com/2022/11/15/javaweb%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(CentOS%E7%89%88%E6%9C%AC)/"/>
    <id>http://example.com/2022/11/15/javaweb%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(CentOS%E7%89%88%E6%9C%AC)/</id>
    <published>2022-11-15T10:00:00.000Z</published>
    <updated>2022-11-16T08:29:00.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javaweb开发环境搭建-CentOS版本"><a href="#javaweb开发环境搭建-CentOS版本" class="headerlink" title="javaweb开发环境搭建(CentOS版本)"></a>javaweb开发环境搭建(CentOS版本)</h1><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><ol><li>执行以下命令，查看yum源中JDK版本。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list java*</span><br></pre></td></tr></table></figure><ol start="2"><li>执行以下命令，使用yum安装JDK1.8。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><ol start="3"><li>执行以下命令，查看是否安装成功。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol><li>执行以下命令，下载并安装MySQL官方的Yum Repository。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install * --nogpgcheck mysql-community-server</span><br></pre></td></tr></table></figure><p>2.执行以下命令，启动 MySQL 数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure><p>3.执行以下命令，查看MySQL初始密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>4.执行以下命令，输入上条命令中MySQL初始密码，登录数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>5.执行以下命令，修改MySQL默认密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=0;  #修改密码安全策略为低（只校验密码长度，至少8位）。</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;12345678&#x27;;</span><br></pre></td></tr></table></figure><p>6.执行以下命令，授予root用户远程管理权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;12345678&#x27;;</span><br></pre></td></tr></table></figure><p>7.输入exit退出数据库。</p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>1.执行以下命令，下载Tomcat压缩包。如果该镜像失效，<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/">请查看tomcat最新版本</a>，并进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://labfileapp.oss-cn-hangzhou.aliyuncs.com/apache-tomcat-8.5.72.tar.gz</span><br></pre></td></tr></table></figure><p>2.执行以下命令，解压刚刚下载Tomcat包。</p><p>3.执行以下命令，修改Tomcat名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-8.5.72 /usr/local/Tomcat8.5</span><br></pre></td></tr></table></figure><p>4.执行以下命令，为Tomcat授权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/Tomcat8.5/bin/*.sh</span><br></pre></td></tr></table></figure><p>5.执行以下命令，修改Tomcat默认端口号为80。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/Connector port=&quot;8080&quot;/Connector port=&quot;80&quot;/&#x27; /usr/local/Tomcat8.5/conf/server.xml</span><br></pre></td></tr></table></figure><p>6.启动Tomcat。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Tomcat8.5/bin/./startup.sh</span><br></pre></td></tr></table></figure><h2 id="访问Tomcat"><a href="#访问Tomcat" class="headerlink" title="访问Tomcat"></a>访问Tomcat</h2><p>1.打开浏览器，在地址栏中输入ECS公网地址，例如：139.0.0.1</p><p>如果显示如下界面，则表示Tomcat安装配置成功。</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221113202844.png?raw=true" alt="blog_images20221113202844.png"></p><p>2.至此，Java Web开发环境搭建完成。</p>]]></content>
    
    
    <summary type="html">搭建服务器环境</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>常见错误汇总</title>
    <link href="http://example.com/2022/11/14/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>http://example.com/2022/11/14/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</id>
    <published>2022-11-14T10:00:00.000Z</published>
    <updated>2022-11-16T08:23:55.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="ssh登陆报错“WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED“问题原因及解决方法"><a href="#ssh登陆报错“WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED“问题原因及解决方法" class="headerlink" title="ssh登陆报错“WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED“问题原因及解决方法"></a>ssh登陆报错“WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED“问题原因及解决方法</h2><p>问题原因：</p><p>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!<br>翻译过来就是<br>警告：远程主机标识已更改！</p><p>此报错是由于远程的主机的公钥发生了变化导致的。<br>ssh服务是通过公钥和私钥来进行连接的，它会把每个曾经访问过计算机或服务器的公钥（public key），记录在~/.ssh/known_hosts 中，当下次访问曾经访问过的计算机或服务器时，ssh就会核对公钥，如果和上次记录的不同，OpenSSH会发出警告。</p><p>解决办法：</p><p>删除对应ip的在known_hosts相关信息vim /root/.ssh/known_hosts</p>]]></content>
    
    
    <summary type="html">错误汇总</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Pytorch</title>
    <link href="http://example.com/2022/11/10/Pytorch/"/>
    <id>http://example.com/2022/11/10/Pytorch/</id>
    <published>2022-11-10T06:00:00.000Z</published>
    <updated>2022-12-01T11:58:59.718Z</updated>
    
    <content type="html"><![CDATA[<p>pytorch官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p><p><strong>两个常用命令：</strong></p><p>​                <strong>dir():查看包下面包含什么</strong></p><p>​                <strong>help()：查看函数的使用</strong></p><h1 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h1><p>最简单的方法就是安装依赖Python 3.x的<a href="https://conda.io/en/latest/miniconda.html">Miniconda</a>。 如果已安装conda，则可以跳过以下步骤。访问Miniconda网站，根据Python3.x版本确定适合你的系统的版本</p><p>在安装深度学习框架之前，请先检查你的计算机上是否有可用的GPU。 例如，你可以查看计算机是否装有NVIDIA GPU并已安装<a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>。 如果你的机器没有任何GPU，没有必要担心，因为你的CPU在前几章完全够用。 但是，如果你想流畅地学习全部章节，请提早获取GPU并且安装深度学习框架的GPU版本。</p><p>你可以按如下方式安装PyTorch的CPU或GPU版本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==<span class="number">1</span>.<span class="number">11</span>.<span class="number">0</span></span><br><span class="line">pip install torchvision==<span class="number">0</span>.<span class="number">12</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>首先，我们导入<code>torch</code>。请注意，虽然它被称为PyTorch，但是代码中使用<code>torch</code>而不是<code>pytorch</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><p>张量表示由一个数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的<em>向量</em>（vector）； 具有两个轴的张量对应数学上的<em>矩阵</em>（matrix）； 具有两个轴以上的张量没有特殊的数学名称。类似于矩阵，只是换了一个名字。</p><h2 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用arange创建一个一维张量，左闭右开，0-11</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line"><span class="comment">#创建零张量，形状为（2,3,4）</span></span><br><span class="line">torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">#创建全为1的张量 形状为（2,3,4）</span></span><br><span class="line">torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">#创建服从高斯分布（正态分布）的张量，其中的每个元素都从均值为0、标准差为1</span></span><br><span class="line">torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">#通过python列表进行创建</span></span><br><span class="line">torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>查看张量的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure><p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。 因为这里在处理的是一个向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.numel()</span><br></pre></td></tr></table></figure><h2 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h2><p>对于任意具有相同形状的张量， 常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作。在下面的例子中，我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">x + y, x - y, x * y, x / y, x ** y  <span class="comment"># **运算符是求幂运算</span></span><br></pre></td></tr></table></figure><p>“按元素”方式可以应用更多的计算，包括像求幂这样的一元运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure><p>我们也可以把多个张量<em>连结</em>（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)<span class="comment">#dim=时按行连接，等于1时按列连接</span></span><br><span class="line">(tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]),</span><br><span class="line"> tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]))</span><br></pre></td></tr></table></figure><p>有时，我们想通过<em>逻辑运算符</em>构建二元张量。 以<code>X == Y</code>为例： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X == Y</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure><p>对张量中的所有元素进行求和，会产生一个单元素张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><p>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。 在某些情况下，即使形状不同，我们仍然可以通过调用 <em>广播机制</em>（broadcasting mechanism）来执行按元素操作。 这种机制的工作方式如下：首先，通过适当复制元素来扩展一个或两个数组， 以便在转换之后，两个张量具有相同的形状。 其次，对生成的数组执行按元素操作。</p><p>在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">a, b</span><br><span class="line">(tensor([[<span class="number">0</span>],</span><br><span class="line">         [<span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>]]),</span><br><span class="line"> tensor([[<span class="number">0</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure><p>由于<code>a</code>和<code>b</code>分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵<em>广播</em>为一个更大的3×2矩阵，如下所示：矩阵<code>a</code>将复制列， 矩阵<code>b</code>将复制行，然后再按元素相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素。</p><p>如下所示，我们可以用<code>[-1]</code>选择最后一个元素，可以用<code>[1:3]</code>选择第二个和第三个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">X[-<span class="number">1</span>], X[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">#二维张量最后一个元素就是最后一行</span></span><br><span class="line">(tensor([ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]),</span><br><span class="line"> tensor([[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]]))</span><br><span class="line"><span class="comment">#获取多行多列 左闭右开 取0-1行并修改值全为12</span></span><br><span class="line">X[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line">X</span><br><span class="line">tensor([[<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">        [<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure><p>除读取外，我们还可以通过指定索引来将元素写入矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><h2 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h2><p>运行一些操作可能会导致为新结果分配内存。 例如，如果我们用<code>Y = X + Y</code>，我们将取消引用<code>Y</code>指向的张量，而是指向新分配的内存处的张量。</p><p>在下面的例子中，我们用Python的<code>id()</code>函数演示了这一点， 它给我们提供了内存中引用对象的确切地址。 运行<code>Y = Y + X</code>后，我们会发现<code>id(Y)</code>指向另一个位置。 这是因为Python首先计算<code>Y + X</code>，为结果分配新的内存，然后使<code>Y</code>指向内存中的这个新位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y)</span><br><span class="line">Y = Y + X</span><br><span class="line"><span class="built_in">id</span>(Y) == before</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span><span class="comment">#结果</span></span><br></pre></td></tr></table></figure><p>这可能是不可取的，原因有两个：首先，我们不想总是不必要地分配内存。 在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。 通常情况下，我们希望原地执行这些更新。 其次，如果我们不原地更新，其他引用仍然会指向旧的内存位置， 这样我们的某些代码可能会无意中引用旧的参数。幸运的是，执行原地操作非常简单。 我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如<code>Y[:] = &lt;expression&gt;</code>。 为了说明这一点，我们首先创建一个新的矩阵<code>Z</code>，其形状与另一个<code>Y</code>相同， 使用<code>zeros_like</code>来分配一个全0的块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = torch.zeros_like(Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>, <span class="built_in">id</span>(Z))</span><br><span class="line">Z[:] = X + Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>, <span class="built_in">id</span>(Z))</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="built_in">id</span>(Z): <span class="number">140316199714544</span></span><br><span class="line"><span class="built_in">id</span>(Z): <span class="number">140316199714544</span></span><br></pre></td></tr></table></figure><p>如果在后续计算中没有重复使用<code>X</code>， 我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(X)</span><br><span class="line">X += Y</span><br><span class="line"><span class="built_in">id</span>(X) == before</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="转换为其他Python对象"><a href="#转换为其他Python对象" class="headerlink" title="转换为其他Python对象"></a>转换为其他Python对象</h2><p>将深度学习框架定义的张量转换为NumPy张量（<code>ndarray</code>）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">type</span>(A), <span class="built_in">type</span>(B)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">(numpy.ndarray, torch.Tensor)</span><br></pre></td></tr></table></figure><p>要将大小为1的张量转换为Python标量，我们可以调用<code>item</code>函数或Python的内置函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">(tensor([<span class="number">3.5000</span>]), <span class="number">3.5</span>, <span class="number">3.5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h2><p>如果你曾经在餐厅支付餐费，那么你已经知道一些基本的线性代数，比如在数字间相加或相乘。 例如，北京的温度为52∘F（除了摄氏度外，另一种温度计量单位）。 严格来说，我们称仅包含一个数值的叫<em>标量</em>（scalar）。 如果要将此华氏度值转换为更常用的摄氏度， 则可以计算表达式c=59(f−32)，并将f赋为52。 在此等式中，每一项（5、9和32）都是标量值。 符号c和f称为<em>变量</em>（variable），它们表示未知的标量值。</p><p>在本书中，我们采用了数学表示法，其中标量变量由普通小写字母表示（例如，x、y和z）。 我们用R表示所有（连续）<em>实数</em>标量的空间。 我们之后将严格定义<em>空间</em>（space）是什么， 但现在你只要记住表达式x∈R是表示x是一个实值标量的正式形式。 符号∈称为“属于”，它表示“是集合中的成员”。 我们可以用x,y∈{0,1}来表明x和y是值只能为0或1的数字。</p><p>标量由只有一个元素的张量表示。 在下面的代码中，我们实例化两个标量，并执行一些熟悉的算术运算，即加法、乘法、除法和指数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">x + y, x * y, x / y, x**y</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">(tensor(<span class="number">5.</span>), tensor(<span class="number">6.</span>), tensor(<span class="number">1.5000</span>), tensor(<span class="number">9.</span>))</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>你可以将向量视为标量值组成的列表。 我们将这些标量值称为向量的<em>元素</em>（element）或<em>分量</em>（component）。 当向量表示数据集中的样本时，它们的值具有一定的现实意义。 例如，如果我们正在训练一个模型来预测贷款违约风险，我们可能会将每个申请人与一个向量相关联， 其分量与其收入、工作年限、过往违约次数和其他因素相对应。 如果我们正在研究医院患者可能面临的心脏病发作风险，我们可能会用一个向量来表示每个患者， 其分量为最近的生命体征、胆固醇水平、每天运动时间等。 在数学表示法中，我们通常将向量记为粗体、小写的符号 （例如，x、y和z)）。</p><p>我们通过一维张量处理向量。一般来说，张量可以具有任意长度，取决于机器的内存限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>我们可以使用下标来引用向量的任一元素。 例如，我们可以通过xi来引用第i个元素。 注意，元素xi是一个标量，所以我们在引用它时不会加粗。 大量文献认为列向量是向量的默认方向，在本书中也是如此。 在数学中，向量x可以写为：</p><p>向量x可以写为：</p><p>$$<br>x= \begin{matrix}<br>   x1 \<br>    x2 \<br>   … \<br>   xn<br>  \end{matrix} \tag{1}<br>$$<br>其中x1,…,xn是向量的元素。在代码中，我们通过张量的索引来访问任一元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>]</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">tensor(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="长度、维度和形状"><a href="#长度、维度和形状" class="headerlink" title="长度、维度和形状"></a>长度、维度和形状</h2><p>向量只是一个数字数组，就像每个数组都有一个长度一样，每个向量也是如此。 在数学表示法中，如果我们想说一个向量x由n个实值标量组成， 我们可以将其表示为x∈Rn。 向量的长度通常称为向量的<em>维度</em>（dimension）。</p><p>与普通的Python数组一样，我们可以通过调用Python的内置<code>len()</code>函数来访问张量的长度。</p><p><strong>维度：通常的理解是：“点是0维、直线是1维、平面是2维、体是3维</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#一维</span></span><br><span class="line">torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]) <span class="comment">#二维</span></span><br><span class="line">torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]],[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]])<span class="comment">#三维</span></span><br></pre></td></tr></table></figure><p><strong>形状</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过x.shape可以查看张量的形状</span></span><br><span class="line">x.shape</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>长度</strong></p><blockquote><p>一个矩阵的长度主要看他最高维的长度</p></blockquote><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#一维的最高维度是列</span></span><br><span class="line"><span class="comment">#len(x)结果为3</span></span><br><span class="line">x=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]) <span class="comment">#二维的最高维度是行</span></span><br><span class="line"><span class="comment">#len(x)结果为2</span></span><br><span class="line">x=torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]],[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]])<span class="comment">#三维的最高维度是高</span></span><br><span class="line"><span class="comment">#len(x)结果为2</span></span><br></pre></td></tr></table></figure><p><strong>按特定列求和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个三维张量,ones((高,行,列))</span></span><br><span class="line">x=torch.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">#如果axis=0 则是对高求和，消去高的那一维度，得到的二维张量size是[3,4]</span></span><br><span class="line">x.<span class="built_in">sum</span>(axis=<span class="number">0</span>).shape</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">x.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#由于高为2，所以每一个值都是2</span></span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="comment">#同理如果axis=1,那么则是消去行的那一维度，得到的二维张量size是[2,4]</span></span><br><span class="line">x.<span class="built_in">sum</span>(axis=<span class="number">1</span>).shape</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">x.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">tensor([[<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line"><span class="comment">#如果不想消去特定的维度,把参数keepdims设置为True就可以了，消去的那一个维度变成了1，同时axis还可以传入列表，对多个维度进行求和</span></span><br><span class="line">x.<span class="built_in">sum</span>(axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>).shape</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">x.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">tensor([<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>])</span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>正如向量将标量从零阶推广到一阶，矩阵将向量从一阶推广到二阶。 矩阵，我们通常用粗体、大写字母来表示 （例如，X、Y和Z）， 在代码中表示为具有两个轴的张量。</p><p>在数学表示法中，我们使用A∈Rm×n 来表示矩阵A，其由m行和n列的实值标量组成。 我们可以将任意矩阵A∈Rm×n视为一个表格， 其中每个元素aij属于第i行第j列：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221130173553.png?raw=true" alt="blog_images20221130173553.png"></p><p>对于任意A∈Rm×n， A的形状是（m,n）或m×n。 当矩阵具有相同数量的行和列时，其形状将变为正方形； 因此，它被称为<em>方阵</em>（square matrix）。</p><p>当调用函数来实例化张量时， 我们可以通过指定两个分量m和n来创建一个形状为m×n的矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">A</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]])</span><br></pre></td></tr></table></figure><p>我们可以通过行索引（i）和列索引（j）来访问矩阵中的标量元素aij， 例如[A]ij。 如果没有给出矩阵A的标量元素，如在那样， 我们可以简单地使用矩阵A的小写字母索引下标aij 来引用[A]ij。 为了表示起来简单，只有在必要时才会将逗号插入到单独的索引中， 例如a2,3j和[A]2i−1,3。</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221130174651.png?raw=true" alt="blog_images20221130174651.png"></p><p>当我们交换矩阵的行和列时，结果称为矩阵的<em>转置</em>（transpose）。 我们用a⊤来表示矩阵的转置，如果B=A⊤， 则对于任意i和j，都有bij=aji。 因此，在 <a href="https://zh-v2.d2l.ai/chapter_preliminaries/linear-algebra.html#equation-eq-matrix-def">(2.3.2)</a>中的转置是一个形状为n×m的矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure><p>作为方阵的一种特殊类型，<em>对称矩阵</em>（symmetric matrix）A等于其转置：A=A⊤。 这里我们定义一个对称矩阵B：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">B</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="comment">#现在我们将B与它的转置进行比较。</span></span><br><span class="line">B == B.T</span><br><span class="line">tensor([[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>]])</span><br></pre></td></tr></table></figure><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构。 张量（本小节中的“张量”指代数对象）为我们提供了描述具有任意数量轴的n维数组的通用方法。 例如，向量是一阶张量，矩阵是二阶张量。 张量用特殊字体的大写字母表示（例如，X、Y和Z）， 它们的索引机制（例如xijk和[X]1,2i−1,3）与矩阵类似。</p><p>当我们开始处理图像时，张量将变得更加重要，图像以n维数组形式出现， 其中3个轴对应于高度、宽度，以及一个<em>通道</em>（channel）轴， 用于表示颜色通道（红色、绿色和蓝色）。 现在，我们先将高阶张量暂放一边，而是专注学习其基础知识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">X</span><br><span class="line">tensor([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">         [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">         [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]]</span><br></pre></td></tr></table></figure><h2 id="张量算法的基本性质"><a href="#张量算法的基本性质" class="headerlink" title="张量算法的基本性质"></a>张量算法的基本性质</h2><p>标量、向量、矩阵和任意数量轴的张量（本小节中的“张量”指代数对象）有一些实用的属性。 例如，你可能已经从按元素操作的定义中注意到，任何按元素的一元运算都不会改变其操作数的形状。 同样，给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量。 例如，将两个相同形状的矩阵相加，会在这两个矩阵上执行元素加法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">B = A.clone()  <span class="comment"># 通过分配新内存，将A的一个副本分配给B</span></span><br><span class="line">A, A + B</span><br><span class="line">(tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         [<span class="number">12.</span>, <span class="number">13.</span>, <span class="number">14.</span>, <span class="number">15.</span>],</span><br><span class="line">         [<span class="number">16.</span>, <span class="number">17.</span>, <span class="number">18.</span>, <span class="number">19.</span>]]),</span><br><span class="line"> tensor([[ <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>],</span><br><span class="line">         [ <span class="number">8.</span>, <span class="number">10.</span>, <span class="number">12.</span>, <span class="number">14.</span>],</span><br><span class="line">         [<span class="number">16.</span>, <span class="number">18.</span>, <span class="number">20.</span>, <span class="number">22.</span>],</span><br><span class="line">         [<span class="number">24.</span>, <span class="number">26.</span>, <span class="number">28.</span>, <span class="number">30.</span>],</span><br><span class="line">         [<span class="number">32.</span>, <span class="number">34.</span>, <span class="number">36.</span>, <span class="number">38.</span>]]))</span><br></pre></td></tr></table></figure><p>具体而言，两个矩阵的按元素乘法称为<em>Hadamard积</em>（Hadamard product）（数学符号⊙）。 对于矩阵B∈Rm×n， 其中第i行和第j列的元素是bij。 矩阵A和B的Hadamard积为：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221201194456.png?raw=true" alt="blog_images20221201194456.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A * B</span><br><span class="line">tensor([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">4.</span>,   <span class="number">9.</span>],</span><br><span class="line">        [ <span class="number">16.</span>,  <span class="number">25.</span>,  <span class="number">36.</span>,  <span class="number">49.</span>],</span><br><span class="line">        [ <span class="number">64.</span>,  <span class="number">81.</span>, <span class="number">100.</span>, <span class="number">121.</span>],</span><br><span class="line">        [<span class="number">144.</span>, <span class="number">169.</span>, <span class="number">196.</span>, <span class="number">225.</span>],</span><br><span class="line">        [<span class="number">256.</span>, <span class="number">289.</span>, <span class="number">324.</span>, <span class="number">361.</span>]])</span><br></pre></td></tr></table></figure><p>将张量乘以或加上一个标量不会改变张量的形状，其中张量的每个元素都将与标量相加或相乘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">a + X, (a * X).shape</span><br><span class="line">(tensor([[[ <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">          [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">          [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line"></span><br><span class="line">         [[<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">          [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>],</span><br><span class="line">          [<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>]]]),</span><br><span class="line"> torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>我们可以对任意张量进行的一个有用的操作是计算其元素的和。 在数学表示法中，我们使用∑符号表示求和。 为了表示长度为d的向量中元素的总和，可以记为∑i=1dxi。 在代码中，我们可以调用计算求和的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line">x, x.<span class="built_in">sum</span>()</span><br><span class="line">(tensor([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]), tensor(<span class="number">6.</span>))</span><br></pre></td></tr></table></figure><p>我们可以表示任意形状张量的元素和。 例如，矩阵A中元素的和可以记为∑i=1m∑j=1naij。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.shape, A.<span class="built_in">sum</span>()</span><br><span class="line">(torch.Size([<span class="number">5</span>, <span class="number">4</span>]), tensor(<span class="number">190.</span>))</span><br></pre></td></tr></table></figure><p>默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。 我们还可以指定张量沿哪一个轴来通过求和降低维度。 以矩阵为例，为了通过求和所有行的元素来降维（轴0），我们可以在调用函数时指定<code>axis=0</code>。 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis0, A_sum_axis0.shape</span><br><span class="line">(tensor([<span class="number">40.</span>, <span class="number">45.</span>, <span class="number">50.</span>, <span class="number">55.</span>]), torch.Size([<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>指定<code>axis=1</code>将通过汇总所有列的元素降维（轴1）。因此，输入轴1的维数在输出形状中消失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">A_sum_axis1, A_sum_axis1.shape</span><br><span class="line">(tensor([ <span class="number">6.</span>, <span class="number">22.</span>, <span class="number">38.</span>, <span class="number">54.</span>, <span class="number">70.</span>]), torch.Size([<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><p>沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># SameasA.sum()</span></span><br><span class="line">tensor(<span class="number">190.</span>)</span><br></pre></td></tr></table></figure><p>同样，计算平均值的函数也可以沿指定轴降低张量的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.mean(axis=<span class="number">0</span>), A.<span class="built_in">sum</span>(axis=<span class="number">0</span>) / A.shape[<span class="number">0</span>]</span><br><span class="line">(tensor([ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]), tensor([ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]))</span><br></pre></td></tr></table></figure><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>我们已经学习了按元素操作、求和及平均值。 另一个最基本的操作之一是点积。 给定两个向量x,y∈Rd， 它们的<em>点积</em>（dot product）x⊤y （或⟨x,y⟩） 是相同位置的按元素乘积的和：x⊤y=∑i=1dxiyi。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>, dtype = torch.float32)</span><br><span class="line">x, y, torch.dot(x, y)</span><br><span class="line">(tensor([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]), tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]), tensor(<span class="number">6.</span>))</span><br></pre></td></tr></table></figure><p>注意，我们可以通过执行按元素乘法，然后进行求和来表示两个向量的点积：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.sum(x * y)</span><br><span class="line">tensor(6.)</span><br></pre></td></tr></table></figure><p>点积在很多场合都很有用。 例如，给定一组由向量x∈Rd表示的值， 和一组由w∈Rd表示的权重。 x中的值根据权重w的加权和， 可以表示为点积x⊤w。 当权重为非负数且和为1（即(∑i=1dwi=1)）时， 点积表示<em>加权平均</em>（weighted average）。 将两个向量规范化得到单位长度后，点积表示它们夹角的余弦。 我们将在本节的后面正式介绍<em>长度</em>（length）的概念。</p><h1 id="Pytorch读取数据"><a href="#Pytorch读取数据" class="headerlink" title="Pytorch读取数据"></a>Pytorch读取数据</h1><h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>提供一种方式去获取数据以及label</p><p>功能：</p><ul><li>如何获取每一个数据及其label</li><li>告诉我们总共有多少数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir  <span class="comment">#根路径</span></span><br><span class="line">        self.label_dir = label_dir <span class="comment">#图片路径</span></span><br><span class="line">        self.path = os.path.join(root_dir, label_dir)<span class="comment">#合成路径</span></span><br><span class="line">        self.img_path = os.listdir(self.path)<span class="comment">#获取图片名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx] <span class="comment">#根据索引获取列表里面图片名称</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)<span class="comment">#获取图片路径</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)<span class="comment">#打开图片</span></span><br><span class="line">        label = self.label_dir<span class="comment">#设置标签</span></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root_dir = <span class="string">&quot;../Pytorch/hymenoptera_data/train&quot;</span></span><br><span class="line">    ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">    bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">    ants_data = MyData(root_dir, ants_label_dir)</span><br><span class="line">    bees_data = MyData(root_dir, bees_label_dir)</span><br><span class="line">    trans_data = ants_data + bees_data</span><br><span class="line">    img_list_path = os.listdir(os.path.join(root_dir, bees_label_dir))<span class="comment">#获取图片名称</span></span><br><span class="line">    ants_label = <span class="string">&quot;bees_label&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> img_list_path:</span><br><span class="line">        filename = i.split(<span class="string">&#x27;.jpg&#x27;</span>)[<span class="number">0</span>]<span class="comment">#把.jpg去掉</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(root_dir, ants_label, <span class="string">&quot;&#123;&#125;.txt&quot;</span>.<span class="built_in">format</span>(filename)), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&quot;bees&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>为后面的网络提供不同的数据形式，组合数据集和采样器，并在给定数据集上提供可迭代对象。</p><p>:类:“~ torch.utils.data。DataLoader ‘支持地图风格和可迭代风格的数据集，具有单进程或多进程加载、自定义加载顺序和可选的自动批处理(排序)和内存固定</p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset (Dataset):加载的数据集</span><br><span class="line">batch_size：每次加载多少数据</span><br><span class="line">shuffle：设置为True 以在每次读取的时候重新洗牌数据(默认值:&#x27; &#x27; False &#x27; &#x27;)。</span><br></pre></td></tr></table></figure><h1 id="TensorBoard使用"><a href="#TensorBoard使用" class="headerlink" title="TensorBoard使用"></a>TensorBoard使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;../Pytorch/hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img_array = np.array(img)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="comment"># for i in range(100):</span></span><br><span class="line"><span class="comment">#     writer.add_scalar(&quot;y=x&quot;, i, i)</span></span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, img_array, <span class="number">2</span>, dataformats=<span class="string">&#x27;HWC&#x27;</span>)</span><br><span class="line">writer.close()</span><br><span class="line"><span class="comment"># tensorboard --logdir=logs 打开tensorboard terminal执行此命令</span></span><br></pre></td></tr></table></figure><p><strong>比较常用的TensorBoard</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">img_path = <span class="string">&quot;../Pytorch/hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="comment"># ToTensor</span></span><br><span class="line">tensor = transforms.ToTensor()</span><br><span class="line">img_tensor = tensor(image)</span><br><span class="line">writer.add_image(<span class="string">&quot;ToTensor&quot;</span>, img_tensor)</span><br><span class="line"><span class="comment"># Normalize 规格化</span></span><br><span class="line">normalize = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">img_nor = normalize(img_tensor)</span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize&quot;</span>, img_nor)</span><br><span class="line"><span class="comment"># Resize 改变大小</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line">img_resize = trans_resize(image)</span><br><span class="line">img_resize = tensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize)</span><br><span class="line"><span class="comment"># Compose 用于组合各种转换器</span></span><br><span class="line">resize = transforms.Resize(<span class="number">512</span>)</span><br><span class="line">compose = transforms.Compose([resize, tensor])</span><br><span class="line">img_compose = compose(image)</span><br><span class="line">writer.add_image(<span class="string">&quot;Compose&quot;</span>, img_compose)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Pytorch</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2022/11/09/python/"/>
    <id>http://example.com/2022/11/09/python/</id>
    <published>2022-11-09T10:00:00.000Z</published>
    <updated>2022-11-22T08:52:58.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符是编程时使用的名字，用于给变量、函数、语句块等命名，Python 中标识符由字母、数字、下划线组成，不能以数字开头，区分大小写。</p><p>以下划线开头的标识符有特殊含义，单下划线开头的标识符，如：<em>xxx ，表示不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 导入；双下划线开头的标识符，如：xx，表示私有成员；双下划线开头和结尾的标识符，如：xx，表示 Python 中内置标识，如：init</em>_() 表示类的构造函数。</p><h1 id="python关键字"><a href="#python关键字" class="headerlink" title="python关键字"></a>python关键字</h1><table><thead><tr><th>and</th><th>exec</th><th>not</th><th>assert</th><th>finally</th><th>or</th></tr></thead><tbody><tr><td><strong>break</strong></td><td><strong>for</strong></td><td><strong>pass</strong></td><td><strong>class</strong></td><td><strong>from</strong></td><td><strong>print</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>global</strong></td><td><strong>raise</strong></td><td><strong>def</strong></td><td><strong>if</strong></td><td><strong>return</strong></td></tr><tr><td><strong>del</strong></td><td><strong>import</strong></td><td><strong>try</strong></td><td><strong>elif</strong></td><td><strong>in</strong></td><td><strong>while</strong></td></tr><tr><td><strong>else</strong></td><td><strong>is</strong></td><td><strong>with</strong></td><td><strong>except</strong></td><td><strong>lambda</strong></td><td><strong>yield</strong></td></tr></tbody></table><h1 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h1><p>Python2 中默认编码为 ASCII，假如内容为汉字，不指定编码便不能正确的输出及读取，比如我们想要指定编码为 UTF-8，Python 中通过在开头加入 # – coding: UTF-8 – 进行指定。</p><p>Python3 中默认编码为 UTF-8，因此在使用 Python3 时，我们通常不需指定编码。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Python 中单行注释使用 <code>#</code>，多行注释使用三个单引号（<code>&#39;&#39;&#39;</code>）或三个双引号（<code>&quot;&quot;&quot;</code>）</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><strong>整数</strong>：可以为任意大小、包含负数</li><li><strong>浮点数</strong>：就是小数</li><li><strong>字符串</strong>：以单引号 <code>&#39;</code>、双引号<code>&quot;</code>、三引号 <code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>括起来的文本</li><li><strong>布尔</strong>：只有 <code>True</code>、<code>False</code> 两种值</li><li><strong>空值</strong>：用 <code>None</code> 表示</li><li><strong>变量</strong>：是可变的</li><li><strong>常量</strong>：不可变</li></ul><h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><h2 id="abs-绝对值函数"><a href="#abs-绝对值函数" class="headerlink" title="abs()绝对值函数"></a>abs()绝对值函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h2><p>接收一个可迭代对象，如果对象里的所有元素的bool运算值都是True，那么返回True，否则False。如果all函数中的可迭代对象是空的，直接返回True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any()"></a>any()</h2><p>接收一个可迭代对象，如果迭代对象里有一个元素的bool运算值是True，那么返回True，否则False。与all()是一对兄弟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h2><p>调用对象的<code>__repr__()</code>方法，获得该方法的返回值。<code>__repr__()</code>方法是由对象所属类型实现的方法。不可以简单地理解为print或echo。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s = “haha”</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ascii</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;haha&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ascii</span>(a)</span><br><span class="line"><span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="bin-、oct-、hex"><a href="#bin-、oct-、hex" class="headerlink" title="bin()、oct()、hex()"></a>bin()、oct()、hex()</h2><p>三个函数是将十进制数分别转换为2/8/16进制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(i)</span><br><span class="line"><span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(i)</span><br><span class="line"><span class="string">&#x27;0o12&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(i)</span><br><span class="line"><span class="string">&#x27;0xa&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="bool"><a href="#bool" class="headerlink" title="bool()"></a>bool()</h2><p>测试一个对象或表达式的执行结果是True还是False。这个在布尔数据类型章节中已经很详细的介绍过了。Ps:实际上bool是一个类，不是函数，bool()的返回值是一个布尔类型的实例。builtins中的很多函数，其实都是类，比如bytes()，str()等等。只是因为称呼的习惯，我们叫它函数，严格意义上说，这是不对的，大家心里有数就可以，后面就不再重复说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">1</span>==<span class="number">2</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="built_in">abs</span>(-<span class="number">1</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="literal">None</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="bytearray"><a href="#bytearray" class="headerlink" title="bytearray"></a>bytearray</h2><p>实例化一个bytearray类型的对象。参数可以是字符串、整数或者可迭代对象。bytearray是Python内置的一种可变的序列数据类型，具有大多数bytes类型同样的方法。</p><p>当参数是字符串的时候，需要指定编码类型。</p><p>当参数是整数时，会创建以该整数为长度，包含同样个数空的bytes对象的数组。</p><p>当参数是个可迭代的对象时，该对象必须是一个取值范围<code>0 &lt;= x &lt; 256</code>的整数序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">bytearray</span>(<span class="string">&quot;asdff&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">bytearray</span>(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">bytearray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\x01\x02\x03&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">bytearray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">300</span>])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#12&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    d = <span class="built_in">bytearray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">300</span>])</span><br><span class="line">ValueError: byte must be <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>)</span><br></pre></td></tr></table></figure><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes()"></a>bytes()</h2><p>将对象转换成字节类型。例如：<code>s = &#39;张三&#39;;m = bytes(s,encoding=&#39;utf-8&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(i)</span><br><span class="line"><span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;haha&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(s)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#24&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">bytes</span>(s)</span><br><span class="line">TypeError: string argument without an encoding</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(s, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;haha&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(s, encoding=<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;haha&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>将对象转换成字符串类型，同样也可以指定编码方式。例如：<code>str(bytes对象，encoding=&#39;utf-8&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i =  <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(i)</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&quot;haha&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(b)      <span class="comment"># 注意！</span></span><br><span class="line"><span class="string">&quot;b&#x27;haha&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(b,encoding=<span class="string">&quot;gb2312&quot;</span>)</span><br><span class="line"><span class="string">&#x27;haha&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br></pre></td></tr></table></figure><p>Bytes和string之间的互相转换，更多使用的是encode()和decode()方法。</p><h2 id="callable"><a href="#callable" class="headerlink" title="callable()"></a>callable()</h2><p>判断对象是否可以被调用。如果某个对象具有<code>__call__</code>方法，那它就能被调用。 例如，<code>def f1(): pass</code>,那么<code>callable(f1)</code>返回True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(f1)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(a)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_obj = Foo(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(f_obj)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Foo)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="chr"><a href="#chr" class="headerlink" title="chr()"></a>chr()</h2><p>返回某个十进制数对应的ASCII字符，例如：<code>chr(99) = ‘c’</code>。它可以配合<code>random.randint(65，90)</code>随机方法，生成随机字符，用于生产随机验证码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    a = random.randint(<span class="number">65</span>,<span class="number">90</span>)</span><br><span class="line">    c = <span class="built_in">chr</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h2 id="ord"><a href="#ord" class="headerlink" title="ord()"></a>ord()</h2><p>与chr()相反，返回某个ASCII字符对应的十进制数，例如，<code>ord(&#39;A&#39;) = 65</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="classmethod-、staticmethod-和property"><a href="#classmethod-、staticmethod-和property" class="headerlink" title="classmethod()、staticmethod()和property()"></a>classmethod()、staticmethod()和property()</h2><p>类机制中，用于生成类方法、静态方法和属性的函数。</p><h2 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h2><p>将字符串编译成Python能识别或执行的代码。 也可以将文件读成字符串再编译。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  = <span class="string">&quot;print(&#x27;helloworld&#x27;)&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">compile</span>(s,<span class="string">&quot;&lt;string&gt;&quot;</span>,<span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">&lt;code <span class="built_in">object</span> &lt;module&gt; at <span class="number">0x000001B23E6BE660</span>, file <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#14&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    r()</span><br><span class="line">TypeError: <span class="string">&#x27;code&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(r)</span><br><span class="line">helloworld</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(r)</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h2 id="complex"><a href="#complex" class="headerlink" title="complex()"></a>complex()</h2><p>通过数字或字符串生成复数类型对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="string">&#x27;3+4j&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>+<span class="number">4j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="string">&#x27;3 +4j&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#2&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="string">&#x27;3 +4j&#x27;</span>)</span><br><span class="line">ValueError: <span class="built_in">complex</span>() arg <span class="keyword">is</span> a malformed string</span><br></pre></td></tr></table></figure><p>使用字符串的时候，+号左右不能有空白。</p><h2 id="delattr-、setattr-、getattr-、hasattr"><a href="#delattr-、setattr-、getattr-、hasattr" class="headerlink" title="delattr()、setattr()、getattr()、hasattr()"></a>delattr()、setattr()、getattr()、hasattr()</h2><p>类机制中，分别用来删除、设置、获取和判断属性。后面会有详解。</p><h2 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h2><p>显示对象所有的属性和方法。最棒的辅助函数之一！</p><h2 id="int-、float-、list-、dict-、set-、tuple"><a href="#int-、float-、list-、dict-、set-、tuple" class="headerlink" title="int()、float()、list()、dict()、set()、tuple()"></a>int()、float()、list()、dict()、set()、tuple()</h2><p>与bool()、str()、bytes()一样，它们都是实例化对应数据类型的类。</p><h2 id="divmod"><a href="#divmod" class="headerlink" title="divmod()"></a>divmod()</h2><p>除法，同时返回商和余数的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h2><p>枚举函数，在迭代对象的时候，额外提供一个序列号的输出。注意：<code>enumerate(li,1)</code>中的1表示从1开始序号，默认从0开始。注意，第二个参数才是你想要的序号开始，不是第一个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&quot;k1&quot;</span>:<span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k2&quot;</span>:<span class="string">&quot;v2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k3&quot;</span>:<span class="string">&quot;v3&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, key <span class="keyword">in</span> <span class="built_in">enumerate</span>(dic, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i,<span class="string">&quot;\t&quot;</span>,key)</span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>将字符串直接解读并执行。例如：<code>s = &quot;6*8&quot;</code>，s是一个字符串，<code>d = eval(s)</code>， d的结果是48。</p><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p>执行字符串或compile方法编译过的字符串，没有返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;this is a test&#x27;)&quot;</span>)</span><br><span class="line">this <span class="keyword">is</span> a test</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;print(&#x27;this is a test&#x27;)&quot;</span>)</span><br><span class="line">this <span class="keyword">is</span> a test</span><br></pre></td></tr></table></figure><h2 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h2><p>执行format()，其实就是调用该对象所属类的<code>__format__</code>方法。类似print功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(<span class="string">&quot;324324&quot;</span>)</span><br><span class="line"><span class="string">&#x27;324324&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset()"></a>frozenset()</h2><p>返回一个不能增加和修改的集合类型对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">frozenset</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h2><p>列出当前环境下所有的全局变量。注意要与global关键字区分！在本节的开始，我们就已经展示了它的用法。</p><h2 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h2><p>为不可变对象，例如字符串生成哈希值的函数！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="string">&quot;i am jack&quot;</span>)</span><br><span class="line"><span class="number">5602200374213231465</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(<span class="number">100000</span>)</span><br><span class="line"><span class="number">100000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#4&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">hash</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,])</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">2528502973977326415</span></span><br></pre></td></tr></table></figure><h2 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h2><p>返回对象的帮助文档。谁用谁知道！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(a)</span><br><span class="line">Help on <span class="built_in">list</span> <span class="built_in">object</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span>(<span class="title class_ inherited__">object</span>)</span><br><span class="line"> |  <span class="built_in">list</span>() -&gt; new empty <span class="built_in">list</span></span><br><span class="line"> |  <span class="built_in">list</span>(iterable) -&gt; new <span class="built_in">list</span> initialized <span class="keyword">from</span> iterable<span class="string">&#x27;s items</span></span><br><span class="line"><span class="string"> ...</span></span><br></pre></td></tr></table></figure><h2 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h2><p>返回对象的内存地址,常用来查看变量引用的变化，对象是否相同等。常用功能之一！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">1456845856</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="number">1456365792</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">37116704</span></span><br></pre></td></tr></table></figure><h2 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h2><p>接收用户输入，返回一个输入的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">input</span>(<span class="string">&quot;Please input a number:  &quot;</span>)</span><br><span class="line">Please <span class="built_in">input</span> a number:  <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;100&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h2><p>判断一个对象是否是某个类的实例。比type()方法适用面更广。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&quot;haha&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">1</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h2><p>issubclass(a，b),判断a是否是b的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Goo</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Goo, Foo)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h2><p>制造一个迭代器，使其具备next()能力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(lis)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#8&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">next</span>(lis)</span><br><span class="line">TypeError: <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="built_in">iter</span>(lis)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x0000000002B4A128</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h2><p>返回对象的长度。不能再常用的函数之一了。</p><h2 id="locals"><a href="#locals" class="headerlink" title="locals()"></a>locals()</h2><p>返回当前可用的局部变量。</p><h2 id="max-min"><a href="#max-min" class="headerlink" title="max()/min():"></a>max()/min():</h2><p>返回给定集合里的最大或者最小的元素。可以指定排序的方法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst=[<span class="string">&#x27;abcdhush8&#x27;</span>,<span class="string">&#x27;abc9iujtwertwert&#x27;</span>,<span class="string">&#x27;abcdjlas&#x27;</span>,<span class="string">&#x27;abcdj897h&#x27;</span>]</span><br><span class="line">a = <span class="built_in">min</span>(lst,key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="memoryview-obj"><a href="#memoryview-obj" class="headerlink" title="memoryview(obj)"></a>memoryview(obj)</h2><p>返回obj的内存视图对象。obj只能是bytes或bytesarray类型。memoryview对象的使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = <span class="built_in">memoryview</span>(<span class="string">b&#x27;abcefg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v[<span class="number">1</span>]</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v[-<span class="number">1</span>]</span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">&lt;memory at <span class="number">0x7f3ddc9f4350</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(v[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"><span class="string">b&#x27;bce&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h2><p>通过调用迭代器的<code>__next__()</code>方法，获取下一个元素。</p><h2 id="object"><a href="#object" class="headerlink" title="object()"></a>object()</h2><p>该方法不接收任何参数，返回一个没有任何功能的对象。object是Python所有类的基类。</p><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>打开文件的方法。在Python2里，还有一个file()方法，Python3中被废弃了。后面章节会详细介绍open()的用法。</p><h2 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h2><p>幂函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><p>这个还用介绍吗？</p><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>没错，这是Python内置的函数，前面已经介绍了。</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>调用对象所属类的<code>__repr__</code>方法，与print功能类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;hashdfh&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;hashdfh&#x27;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="reversed"><a href="#reversed" class="headerlink" title="reversed()"></a>reversed()</h2><p>反转，逆序对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">reversed</span>            <span class="comment"># reversed本身是个类</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;reversed&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 获得一个列表反转器</span></span><br><span class="line">&lt;list_reverseiterator <span class="built_in">object</span> at <span class="number">0x0000022E322B5128</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;list_reverseiterator <span class="built_in">object</span> at <span class="number">0x0000022E32359668</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a)         <span class="comment"># 使用list方法将它转换为一个列表</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><p>四舍五入．</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1.5</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1.4</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>返回一个切片类型的对象。slice是一个类，一种Python的数据类型。Python将对列表等序列数据类型的切片功能单独拿出来设计了一个slice类，可在某些场合下使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;slice&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[s]          <span class="comment"># 注意用法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h2><p>求和．</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)          <span class="comment"># 需要传入一个可迭代的对象</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#15&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">TypeError: <span class="built_in">sum</span> expected at most <span class="number">2</span> arguments, got <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])            <span class="comment"># 传入一个列表</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;)          <span class="comment"># 突发奇想，作死传入一个字典</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h2><p>调用父类。面向对象中类的机制相关。后面介绍。</p><h2 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h2><p>显示对象所属的数据类型。常用方法！前面已经展示过。</p><h2 id="vars"><a href="#vars" class="headerlink" title="vars()"></a>vars()</h2><p>与dir()方法类似，不过dir()方法返回的是key，vars()方法返回key的同时还把value一起打印了。</p><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>映射函数。使用指定的函数，处理可迭代对象，并将结果保存在一个map对象中，本质上和大数据的mapreduce中的map差不多。</p><p>使用格式：<code>obj = map(func, iterable)</code>,func是某个函数名，iterable是一个可迭代对象。</p><p>细心的同学可能发现了，我除了组合一些成对的或者同类系列的内置函数。还有map()函数，连同后面的filter()、zip()、sorted()和<code>__import__()</code>函数都没有介绍。因为这几个内置函数功能非常强大，使用场景非常多，Python非常贴心地帮我们实现并内置了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">data = <span class="built_in">map</span>(<span class="keyword">lambda</span> x :x*<span class="number">100</span>,li)  <span class="comment"># 这里直接使用了一个匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))       <span class="comment"># 返回值是一个map对象，它是个迭代器。</span></span><br><span class="line">data = <span class="built_in">list</span>(data)       <span class="comment"># 可以用list方法将map对象中的元素全部生成出来，保存到一个列表里。</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;map&#x27;</span>&gt;</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>过滤器，用法和map类似。在函数中设定过滤的条件，逐一循环对象中的元素，将返回值为True时的元素留下（注意，不是留下返回值！），形成一个filter类型的迭代器。</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>阅读: 27233   <a href="https://www.liujiangblog.com/course/python/40#comments">评论</a>：10</p><hr><p>你会不会有些好奇Python为什么可以直接使用一些内建函数，而不用显式的导入它们？比如 str()、int()、dir()、id()、type()，max()，min()，len()等，许多许多非常好用，快捷方便的函数。</p><p>因为这些函数都是一个叫做<code>builtins</code>模块中定义的函数，而<code>builtins</code>模块默认在Python环境启动的时候就自动导入，所以你可以直接使用这些函数。</p><p>我们可以在IDLE里查证一番：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; globals()</span><br><span class="line">&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dir(__builtins__)</span><br><span class="line">[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, &#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, &#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, &#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, &#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, &#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, &#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, &#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, &#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, &#x27;WindowsError&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;_&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;abs&#x27;, &#x27;all&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, &#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, &#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, &#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, &#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;]</span><br></pre></td></tr></table></figure><p>globals()函数可以查看当前状态下，全局变量有哪些，其中最后一个<code>&#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;</code>就是我们说的builtins模块。再使用dir()函数查看它的成员属性，巴拉巴拉一大堆。</p><p>builtins模块里有接近80个内置函数，60多个内置异常，还有几个内置常数，特殊名称以及模块相关的属性。</p><p>Python通过这个近80个内置函数，为我们提供了丰富、强大、高效、快速的解决方案，大多数时候，我们根本不需要导入第三方库，甚至标准库都不需要。不需要自己造轮子，简简单单地使用Python的内置函数就好了！</p><table><thead><tr><th>内置函数</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abs()</td><td>dict()</td><td>help()</td><td>min()</td><td>setattr()</td></tr><tr><td>all()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()</td></tr><tr><td>any()</td><td>divmod()</td><td>id()</td><td>object()</td><td>sorted()</td></tr><tr><td>ascii()</td><td>enumerate()</td><td>input()</td><td>oct()</td><td>staticmethod()</td></tr><tr><td>bin()</td><td>eval()</td><td>int()</td><td>open()</td><td>str()</td></tr><tr><td>bool()</td><td>exec()</td><td>isinstance()</td><td>ord()</td><td>sum()</td></tr><tr><td>bytearray()</td><td>filter()</td><td>issubclass()</td><td>pow()</td><td>super()</td></tr><tr><td>bytes()</td><td>float()</td><td>iter()</td><td>print()</td><td>tuple()</td></tr><tr><td>callable()</td><td>format()</td><td>len()</td><td>property()</td><td>type()</td></tr><tr><td>chr()</td><td>frozenset()</td><td>list()</td><td>range()</td><td>vars()</td></tr><tr><td>classmethod()</td><td>getattr()</td><td>locals()</td><td>repr()</td><td>zip()</td></tr><tr><td>compile()</td><td>globals()</td><td>map()</td><td>reversed()</td><td><code>__import__()</code></td></tr><tr><td>complex()</td><td>hasattr()</td><td>max()</td><td>round()</td><td></td></tr><tr><td>delattr()</td><td>hash()</td><td>memoryview()</td><td>set()</td><td></td></tr></tbody></table><p>由于Python内置函数的强大、丰富、方便，在此特地用单独的章节进行介绍。因为内容编排的原因，小80个条目中有一部分在前面已经介绍过，有一部分留待后面介绍。</p><h3 id="abs-："><a href="#abs-：" class="headerlink" title="abs()："></a>abs()：</h3><p>绝对值函数。如abs（-1）= 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f(-1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; abs=id</span><br><span class="line">&gt;&gt;&gt; abs(1)</span><br><span class="line">1869788224</span><br></pre></td></tr></table></figure><p>以abs()函数为例，展示两个特性。一是，内置函数是可以被赋值给其他变量的，同样也可以将其他对象赋值给内置函数，这时就完全变了。所以，内置函数不是Python关键字，要注意对它们的保护，不要使用和内置函数重名的变量名，这会让代码混乱，容易发生难以排查的错误。</p><h3 id="all-1"><a href="#all-1" class="headerlink" title="all()"></a>all()</h3><p>接收一个可迭代对象，如果对象里的所有元素的bool运算值都是True，那么返回True，否则False。不要小瞧了这个函数，用好了，有化腐朽为神奇的特效。</p><p>另外，官方文档说明：如果all函数中的可迭代对象是空的，直接返回True。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; all([1,1,1])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; all([1,1,0])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; all([])</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="any-1"><a href="#any-1" class="headerlink" title="any()"></a>any()</h3><p>接收一个可迭代对象，如果迭代对象里有一个元素的bool运算值是True，那么返回True，否则False。与all()是一对兄弟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; any([0,0,1])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; any([0,0,0])</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="ascii-1"><a href="#ascii-1" class="headerlink" title="ascii()"></a>ascii()</h3><p>调用对象的<code>__repr__()</code>方法，获得该方法的返回值。<code>__repr__()</code>方法是由对象所属类型实现的方法。不可以简单地理解为print或echo。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s = “haha”</span><br><span class="line">&gt;&gt;&gt; ascii(s)</span><br><span class="line">&quot;&#x27;haha&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; ascii(a)</span><br><span class="line">&#x27;[1, 2, 3]&#x27;</span><br></pre></td></tr></table></figure><h3 id="bin-、oct-、hex-1"><a href="#bin-、oct-、hex-1" class="headerlink" title="bin()、oct()、hex()"></a>bin()、oct()、hex()</h3><p>三个函数是将十进制数分别转换为2/8/16进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = 10</span><br><span class="line">&gt;&gt;&gt; bin(i)</span><br><span class="line">&#x27;0b1010&#x27;</span><br><span class="line">&gt;&gt;&gt; oct(i)</span><br><span class="line">&#x27;0o12&#x27;</span><br><span class="line">&gt;&gt;&gt; hex(i)</span><br><span class="line">&#x27;0xa&#x27;</span><br></pre></td></tr></table></figure><h3 id="bool-1"><a href="#bool-1" class="headerlink" title="bool()"></a>bool()</h3><p>测试一个对象或表达式的执行结果是True还是False。这个在布尔数据类型章节中已经很详细的介绍过了。Ps:实际上bool是一个类，不是函数，bool()的返回值是一个布尔类型的实例。builtins中的很多函数，其实都是类，比如bytes()，str()等等。只是因为称呼的习惯，我们叫它函数，严格意义上说，这是不对的，大家心里有数就可以，后面就不再重复说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bool(1==2)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; bool(abs(-1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(None)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="bytearray-1"><a href="#bytearray-1" class="headerlink" title="bytearray"></a>bytearray</h3><p>实例化一个bytearray类型的对象。参数可以是字符串、整数或者可迭代对象。bytearray是Python内置的一种可变的序列数据类型，具有大多数bytes类型同样的方法。</p><p>当参数是字符串的时候，需要指定编码类型。</p><p>当参数是整数时，会创建以该整数为长度，包含同样个数空的bytes对象的数组。</p><p>当参数是个可迭代的对象时，该对象必须是一个取值范围<code>0 &lt;= x &lt; 256</code>的整数序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = bytearray(&quot;asdff&quot;,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">&gt;&gt;&gt; b = bytearray(10)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">bytearray(b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;)</span><br><span class="line">&gt;&gt;&gt; d = bytearray([1,2,3])</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">bytearray(b&#x27;\x01\x02\x03&#x27;)</span><br><span class="line">&gt;&gt;&gt; d = bytearray([1,2,300])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d = bytearray([1,2,300])</span><br><span class="line">ValueError: byte must be in range(0, 256)</span><br></pre></td></tr></table></figure><h3 id="bytes-1"><a href="#bytes-1" class="headerlink" title="bytes()"></a>bytes()</h3><p>将对象转换成字节类型。例如：<code>s = &#39;张三&#39;;m = bytes(s,encoding=&#39;utf-8&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i=2</span><br><span class="line">&gt;&gt;&gt; bytes(i)</span><br><span class="line">b&#x27;\x00\x00&#x27;</span><br><span class="line">&gt;&gt;&gt; s = &#x27;haha&#x27;</span><br><span class="line">&gt;&gt;&gt; bytes(s)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    bytes(s)</span><br><span class="line">TypeError: string argument without an encoding</span><br><span class="line">&gt;&gt;&gt; bytes(s, encoding=&quot;utf-8&quot;)</span><br><span class="line">b&#x27;haha&#x27;</span><br><span class="line">&gt;&gt;&gt; bytes(s, encoding=&quot;GBK&quot;)</span><br><span class="line">b&#x27;haha&#x27;</span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str()"></a>str()</h3><p>将对象转换成字符串类型，同样也可以指定编码方式。例如：<code>str(bytes对象，encoding=&#39;utf-8&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i =  2</span><br><span class="line">&gt;&gt;&gt; str(i)</span><br><span class="line">&#x27;2&#x27;</span><br><span class="line">&gt;&gt;&gt; b = b&quot;haha&quot;</span><br><span class="line">&gt;&gt;&gt; str(b)      # 注意！</span><br><span class="line">&quot;b&#x27;haha&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; str(b,encoding=&quot;gb2312&quot;)</span><br><span class="line">&#x27;haha&#x27;</span><br><span class="line">&gt;&gt;&gt; str([1,2,3,])</span><br><span class="line">&#x27;[1, 2, 3]&#x27;</span><br></pre></td></tr></table></figure><p>Bytes和string之间的互相转换，更多使用的是encode()和decode()方法。</p><h3 id="callable-1"><a href="#callable-1" class="headerlink" title="callable()"></a>callable()</h3><p>判断对象是否可以被调用。如果某个对象具有<code>__call__</code>方法，那它就能被调用。 例如，<code>def f1(): pass</code>,那么<code>callable(f1)</code>返回True。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f1():</span><br><span class="line">    pass</span><br><span class="line">&gt;&gt;&gt; callable(f1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a = &quot;123&quot;</span><br><span class="line">&gt;&gt;&gt; callable(a)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; class Foo:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age        </span><br><span class="line">&gt;&gt;&gt; f_obj = Foo(&quot;jack&quot;,20)</span><br><span class="line">&gt;&gt;&gt; callable(f_obj)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(Foo)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="chr-1"><a href="#chr-1" class="headerlink" title="chr()"></a>chr()</h3><p>返回某个十进制数对应的ASCII字符，例如：<code>chr(99) = ‘c’</code>。它可以配合<code>random.randint(65，90)</code>随机方法，生成随机字符，用于生产随机验证码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">for i in range(10):</span><br><span class="line">    a = random.randint(65,90)</span><br><span class="line">    c = chr(a)</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure><h3 id="ord-1"><a href="#ord-1" class="headerlink" title="ord()"></a>ord()</h3><p>与chr()相反，返回某个ASCII字符对应的十进制数，例如，<code>ord(&#39;A&#39;) = 65</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&quot;A&quot;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&quot;\n&quot;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="classmethod-、staticmethod-和property-1"><a href="#classmethod-、staticmethod-和property-1" class="headerlink" title="classmethod()、staticmethod()和property()"></a>classmethod()、staticmethod()和property()</h3><p>类机制中，用于生成类方法、静态方法和属性的函数。在面向对象章节会有详细介绍。</p><h3 id="compile-1"><a href="#compile-1" class="headerlink" title="compile()"></a>compile()</h3><p>将字符串编译成Python能识别或执行的代码。 也可以将文件读成字符串再编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s  = &quot;print(&#x27;helloworld&#x27;)&quot;</span><br><span class="line">&gt;&gt;&gt; r = compile(s,&quot;&lt;string&gt;&quot;,&quot;exec&quot;)</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">&lt;code object &lt;module&gt; at 0x000001B23E6BE660, file &quot;&lt;string&gt;&quot;, line 1&gt;</span><br><span class="line">&gt;&gt;&gt; r()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    r()</span><br><span class="line">TypeError: &#x27;code&#x27; object is not callable</span><br><span class="line">&gt;&gt;&gt; exec(r)</span><br><span class="line">helloworld</span><br><span class="line">&gt;&gt;&gt; eval(r)</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h3 id="complex-1"><a href="#complex-1" class="headerlink" title="complex()"></a>complex()</h3><p>通过数字或字符串生成复数类型对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; complex(1,2)</span><br><span class="line">(1+2j)</span><br><span class="line">&gt;&gt;&gt; complex(&#x27;3+4j&#x27;)</span><br><span class="line">(3+4j)</span><br><span class="line">&gt;&gt;&gt; complex(&#x27;3 +4j&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    complex(&#x27;3 +4j&#x27;)</span><br><span class="line">ValueError: complex() arg is a malformed string</span><br></pre></td></tr></table></figure><p>使用字符串的时候，+号左右不能有空白。</p><h3 id="delattr-、setattr-、getattr-、hasattr-1"><a href="#delattr-、setattr-、getattr-、hasattr-1" class="headerlink" title="delattr()、setattr()、getattr()、hasattr()"></a>delattr()、setattr()、getattr()、hasattr()</h3><p>类机制中，分别用来删除、设置、获取和判断属性。后面会有详解。</p><h3 id="dir-1"><a href="#dir-1" class="headerlink" title="dir()"></a>dir()</h3><p>显示对象所有的属性和方法。最棒的辅助函数之一！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;builtins&#x27;, &#x27;r&#x27;, &#x27;s&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dir([1,2,])</span><br><span class="line">[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__iadd__&#x27;, &#x27;__imul__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;append&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;count&#x27;, &#x27;extend&#x27;, &#x27;index&#x27;, &#x27;insert&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;]</span><br></pre></td></tr></table></figure><h3 id="int-、float-、list-、dict-、set-、tuple-1"><a href="#int-、float-、list-、dict-、set-、tuple-1" class="headerlink" title="int()、float()、list()、dict()、set()、tuple()"></a>int()、float()、list()、dict()、set()、tuple()</h3><p>与bool()、str()、bytes()一样，它们都是实例化对应数据类型的类。</p><h3 id="divmod-1"><a href="#divmod-1" class="headerlink" title="divmod()"></a>divmod()</h3><p>除法，同时返回商和余数的元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(10,3)</span><br><span class="line">(3, 1)</span><br><span class="line">&gt;&gt;&gt; divmod(11,4)</span><br><span class="line">(2, 3)</span><br></pre></td></tr></table></figure><h3 id="enumerate-1"><a href="#enumerate-1" class="headerlink" title="enumerate()"></a>enumerate()</h3><p>枚举函数，在迭代对象的时候，额外提供一个序列号的输出。注意：<code>enumerate(li,1)</code>中的1表示从1开始序号，默认从0开始。注意，第二个参数才是你想要的序号开始，不是第一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    &quot;k1&quot;:&quot;v1&quot;,</span><br><span class="line">    &quot;k2&quot;:&quot;v2&quot;,</span><br><span class="line">    &quot;k3&quot;:&quot;v3&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i, key in enumerate(dic, 1):</span><br><span class="line">    print(i,&quot;\t&quot;,key)</span><br></pre></td></tr></table></figure><h3 id="eval-1"><a href="#eval-1" class="headerlink" title="eval()"></a>eval()</h3><p>将字符串直接解读并执行。例如：<code>s = &quot;6*8&quot;</code>，s是一个字符串，<code>d = eval(s)</code>， d的结果是48。</p><h3 id="exec-1"><a href="#exec-1" class="headerlink" title="exec()"></a>exec()</h3><p>执行字符串或compile方法编译过的字符串，没有返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exec(&quot;print(&#x27;this is a test&#x27;)&quot;)</span><br><span class="line">this is a test</span><br><span class="line">&gt;&gt;&gt; eval(&quot;print(&#x27;this is a test&#x27;)&quot;)</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure><h3 id="format-1"><a href="#format-1" class="headerlink" title="format()"></a>format()</h3><p>执行format()，其实就是调用该对象所属类的<code>__format__</code>方法。类似print功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; format(&quot;324324&quot;)</span><br><span class="line">&#x27;324324&#x27;</span><br><span class="line">&gt;&gt;&gt; format([1,2,3])</span><br><span class="line">&#x27;[1, 2, 3]&#x27;</span><br></pre></td></tr></table></figure><h3 id="frozenset-1"><a href="#frozenset-1" class="headerlink" title="frozenset()"></a>frozenset()</h3><p>返回一个不能增加和修改的集合类型对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = frozenset(a)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">frozenset(&#123;1, 2, 3&#125;)</span><br><span class="line">&gt;&gt;&gt; dir(b)</span><br><span class="line">[&#x27;__and__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__or__&#x27;, &#x27;__rand__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__ror__&#x27;, &#x27;__rsub__&#x27;, &#x27;__rxor__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__sub__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__xor__&#x27;, &#x27;copy&#x27;, &#x27;difference&#x27;, &#x27;intersection&#x27;, &#x27;isdisjoint&#x27;, &#x27;issubset&#x27;, &#x27;issuperset&#x27;, &#x27;symmetric_difference&#x27;, &#x27;union&#x27;]</span><br></pre></td></tr></table></figure><h3 id="globals-1"><a href="#globals-1" class="headerlink" title="globals()"></a>globals()</h3><p>列出当前环境下所有的全局变量。注意要与global关键字区分！在本节的开始，我们就已经展示了它的用法。</p><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash()"></a>hash()</h3><p>为不可变对象，例如字符串生成哈希值的函数！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(&quot;i am jack&quot;)</span><br><span class="line">5602200374213231465</span><br><span class="line">&gt;&gt;&gt; hash(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(100000)</span><br><span class="line">100000</span><br><span class="line">&gt;&gt;&gt; hash([1,2,3,])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    hash([1,2,3,])</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br><span class="line">&gt;&gt;&gt; hash((1,2,3))</span><br><span class="line">2528502973977326415</span><br></pre></td></tr></table></figure><h3 id="help-1"><a href="#help-1" class="headerlink" title="help()"></a>help()</h3><p>返回对象的帮助文档。谁用谁知道！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; help(a)</span><br><span class="line">Help on list object:</span><br><span class="line"></span><br><span class="line">class list(object)</span><br><span class="line"> |  list() -&gt; new empty list</span><br><span class="line"> |  list(iterable) -&gt; new list initialized from iterable&#x27;s items</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="id-1"><a href="#id-1" class="headerlink" title="id()"></a>id()</h3><p>返回对象的内存地址,常用来查看变量引用的变化，对象是否相同等。常用功能之一！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(0)</span><br><span class="line">1456845856</span><br><span class="line">&gt;&gt;&gt; id(True)</span><br><span class="line">1456365792</span><br><span class="line">&gt;&gt;&gt; a = &quot;Python&quot;</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">37116704</span><br></pre></td></tr></table></figure><h3 id="input-1"><a href="#input-1" class="headerlink" title="input()"></a>input()</h3><p>接收用户输入，返回一个输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = input(&quot;Please input a number:  &quot;)</span><br><span class="line">Please input a number:  100</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;100&#x27;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="isinstance-1"><a href="#isinstance-1" class="headerlink" title="isinstance()"></a>isinstance()</h3><p>判断一个对象是否是某个类的实例。比type()方法适用面更广。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(&quot;haha&quot;, str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(1, str)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="issubclass-1"><a href="#issubclass-1" class="headerlink" title="issubclass()"></a>issubclass()</h3><p>issubclass(a，b),判断a是否是b的子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo:</span><br><span class="line">    pass</span><br><span class="line">&gt;&gt;&gt; class Goo(Foo):</span><br><span class="line">    pass</span><br><span class="line">&gt;&gt;&gt; issubclass(Goo, Foo)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="iter-1"><a href="#iter-1" class="headerlink" title="iter()"></a>iter()</h3><p>制造一个迭代器，使其具备next()能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lis = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; next(lis)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(lis)</span><br><span class="line">TypeError: &#x27;list&#x27; object is not an iterator</span><br><span class="line">&gt;&gt;&gt; i = iter(lis)</span><br><span class="line">&gt;&gt;&gt; i</span><br><span class="line">&lt;list_iterator object at 0x0000000002B4A128&gt;</span><br><span class="line">&gt;&gt;&gt; next(i)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="len-1"><a href="#len-1" class="headerlink" title="len()"></a>len()</h3><p>返回对象的长度。不能再常用的函数之一了。</p><h3 id="locals-1"><a href="#locals-1" class="headerlink" title="locals()"></a>locals()</h3><p>返回当前可用的局部变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; locals()</span><br><span class="line">&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;a&#x27;: &#x27;100&#x27;, &#x27;lis&#x27;: [1, 2, 3], &#x27;i&#x27;: &lt;list_iterator object at 0x0000000002B4A128&gt;, &#x27;dic&#x27;: &#123;&#x27;k1&#x27;: &#x27;v1&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="max-min-1"><a href="#max-min-1" class="headerlink" title="max()/min():"></a>max()/min():</h3><p>返回给定集合里的最大或者最小的元素。可以指定排序的方法！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst=[&#x27;abcdhush8&#x27;,&#x27;abc9iujtwertwert&#x27;,&#x27;abcdjlas&#x27;,&#x27;abcdj897h&#x27;]</span><br><span class="line">a = min(lst,key=len)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h3 id="memoryview-obj-1"><a href="#memoryview-obj-1" class="headerlink" title="memoryview(obj)"></a>memoryview(obj)</h3><p>返回obj的内存视图对象。obj只能是bytes或bytesarray类型。memoryview对象的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; v = memoryview(b&#x27;abcefg&#x27;)</span><br><span class="line">&gt;&gt;&gt; v[1]</span><br><span class="line">98</span><br><span class="line">&gt;&gt;&gt; v[-1]</span><br><span class="line">103</span><br><span class="line">&gt;&gt;&gt; v[1:4]</span><br><span class="line">&lt;memory at 0x7f3ddc9f4350&gt;</span><br><span class="line">&gt;&gt;&gt; bytes(v[1:4])</span><br><span class="line">b&#x27;bce&#x27;</span><br></pre></td></tr></table></figure><h3 id="next-1"><a href="#next-1" class="headerlink" title="next()"></a>next()</h3><p>通过调用迭代器的<code>__next__()</code>方法，获取下一个元素。</p><h3 id="object-1"><a href="#object-1" class="headerlink" title="object()"></a>object()</h3><p>该方法不接收任何参数，返回一个没有任何功能的对象。object是Python所有类的基类。</p><h3 id="open-1"><a href="#open-1" class="headerlink" title="open()"></a>open()</h3><p>打开文件的方法。在Python2里，还有一个file()方法，Python3中被废弃了。后面章节会详细介绍open()的用法。</p><h3 id="pow-1"><a href="#pow-1" class="headerlink" title="pow()"></a>pow()</h3><p>幂函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(3, 2)</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="print-1"><a href="#print-1" class="headerlink" title="print()"></a>print()</h3><p>这个还用介绍吗？</p><h3 id="range-1"><a href="#range-1" class="headerlink" title="range()"></a>range()</h3><p>没错，这是Python内置的函数，前面已经介绍了。</p><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr()"></a>repr()</h3><p>调用对象所属类的<code>__repr__</code>方法，与print功能类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;hashdfh&quot;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">&quot;&#x27;hashdfh&#x27;&quot;</span><br></pre></td></tr></table></figure><h3 id="reversed-1"><a href="#reversed-1" class="headerlink" title="reversed()"></a>reversed()</h3><p>反转，逆序对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reversed            # reversed本身是个类</span><br><span class="line">&lt;class &#x27;reversed&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; reversed([1,2,3,4,5])   # 获得一个列表反转器</span><br><span class="line">&lt;list_reverseiterator object at 0x0000022E322B5128&gt;</span><br><span class="line">&gt;&gt;&gt; a = reversed([1,2,3,4,5])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;list_reverseiterator object at 0x0000022E32359668&gt;</span><br><span class="line">&gt;&gt;&gt; list(a)         # 使用list方法将它转换为一个列表</span><br><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><h3 id="round-1"><a href="#round-1" class="headerlink" title="round()"></a>round()</h3><p>四舍五入．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(1.5)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; round(1.4)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h3><p>返回一个切片类型的对象。slice是一个类，一种Python的数据类型。Python将对列表等序列数据类型的切片功能单独拿出来设计了一个slice类，可在某些场合下使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = slice(1, 10, 2)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">slice(1, 10, 2)</span><br><span class="line">&gt;&gt;&gt; type(s)</span><br><span class="line">&lt;class &#x27;slice&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; lis = [i for i in range(10)]</span><br><span class="line">&gt;&gt;&gt; lis</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; lis[s]          # 注意用法</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><h3 id="sum-1"><a href="#sum-1" class="headerlink" title="sum()"></a>sum()</h3><p>求和．</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(1,2,3)          # 需要传入一个可迭代的对象</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    sum(1,2,3)</span><br><span class="line">TypeError: sum expected at most 2 arguments, got 3</span><br><span class="line">&gt;&gt;&gt; sum([1,2,3])            # 传入一个列表</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; sum(&#123;1:1,2:2&#125;)          # 突发奇想，作死传入一个字典</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="super-1"><a href="#super-1" class="headerlink" title="super()"></a>super()</h3><p>调用父类。面向对象中类的机制相关。后面介绍。</p><h3 id="type-1"><a href="#type-1" class="headerlink" title="type()"></a>type()</h3><p>显示对象所属的数据类型。常用方法！前面已经展示过。</p><h3 id="vars-1"><a href="#vars-1" class="headerlink" title="vars()"></a>vars()</h3><p>与dir()方法类似，不过dir()方法返回的是key，vars()方法返回key的同时还把value一起打印了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; vars()</span><br><span class="line">&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;a&#x27;: &lt;list_reverseiterator object at 0x0000022E32359668&gt;, &#x27;s&#x27;: &#x27;ha&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="map-1"><a href="#map-1" class="headerlink" title="map()"></a>map()</h2><p>映射函数。使用指定的函数，处理可迭代对象，并将结果保存在一个map对象中，本质上和大数据的mapreduce中的map差不多。</p><p>使用格式：<code>obj = map(func, iterable)</code>,func是某个函数名，iterable是一个可迭代对象。</p><p>细心的同学可能发现了，我除了组合一些成对的或者同类系列的内置函数。还有map()函数，连同后面的filter()、zip()、sorted()和<code>__import__()</code>函数都没有介绍。因为这几个内置函数功能非常强大，使用场景非常多，Python非常贴心地帮我们实现并内置了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">li = [1,2,3]</span><br><span class="line">data = map(lambda x :x*100,li)  # 这里直接使用了一个匿名函数</span><br><span class="line"></span><br><span class="line">print(type(data))       # 返回值是一个map对象，它是个迭代器。</span><br><span class="line">data = list(data)       # 可以用list方法将map对象中的元素全部生成出来，保存到一个列表里。</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">&lt;class &#x27;map&#x27;&gt;</span><br><span class="line">[100, 200, 300]</span><br></pre></td></tr></table></figure><h2 id="filter-1"><a href="#filter-1" class="headerlink" title="filter()"></a>filter()</h2><p>过滤器，用法和map类似。在函数中设定过滤的条件，逐一循环对象中的元素，将返回值为True时的元素留下（注意，不是留下返回值！），形成一个filter类型的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">data = <span class="built_in">filter</span>(f1,li)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;filter&#x27;</span>&gt;</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">result = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;<span class="number">33</span>,li)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line">----------------------------------------------</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[<span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">y = [a <span class="keyword">for</span> a <span class="keyword">in</span> li <span class="keyword">if</span> a &gt; <span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h2><p>组合对象。将对象逐一配对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list_2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">s = <span class="built_in">zip</span>(list_1,list_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(s))</span><br><span class="line">--------------------------------</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><p>排序方法。有key和reverse两个重要参数。</p><p>基础用法: 直接对序列进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])</span><br><span class="line">[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p><strong>指定排序的关键字</strong>。关键字必须是一个可调用的对象。例如下面的例子，规则是谁的绝对值大，谁就排在后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;Python&#x27;</span> <span class="comment">#python字符串可以用下标和切片去访问</span></span><br></pre></td></tr></table></figure><p>Python 使用了 <code>ord()</code> 函数返回单个字符的编码，<code>chr()</code> 函数把编码转成相应字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(s))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">65</span>))</span><br></pre></td></tr></table></figure><p>之前我们说过可以通过反斜杠 <code>\</code> 将一行语句分多行显示，其实就是 <code>\</code> 来转义字符，一些常见的转义字符如下表所示</p><table><thead><tr><th align="left">转义字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\</code></td><td align="left">在行尾使用时，用作续行符</td></tr><tr><td align="left">\b</td><td align="left">退格（Backspace）</td></tr><tr><td align="left">\000</td><td align="left">空</td></tr><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\v</td><td align="left">纵向制表符</td></tr><tr><td align="left">\t</td><td align="left">横向制表符</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr></tbody></table><p>字符串运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">连接符</td></tr><tr><td align="left">*</td><td align="left">重复输出</td></tr><tr><td align="left">[]</td><td align="left">通过索引获取字符串中字符</td></tr><tr><td align="left">[ : ]</td><td align="left">获取字符串中的一部分</td></tr><tr><td align="left">in</td><td align="left">字符串中是否包含指定字符</td></tr><tr><td align="left">not in</td><td align="left">字符串中是否不包含指定字符</td></tr><tr><td align="left">r/R</td><td align="left">字符串原样输出</td></tr></tbody></table><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>当我们需要输出的内容中含有变量时，比如：<code>Hello xxx</code>，<code>xxx</code> 为变量，此时便需要一种格式化字符串的方式，Python 使用 <code>%</code> 格式化字符串，常用占位符如下表所示：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">%s</td><td align="left">格式化字符串</td></tr><tr><td align="left">%d</td><td align="left">格式化整数</td></tr><tr><td align="left">%f</td><td align="left">格式化浮点数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello %s&#x27;</span> % <span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们也可以使用字符串的 <code>format()</code> 方法进行格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>格式化字符串面值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我叫<span class="subst">&#123;name&#125;</span>, 今年<span class="subst">&#123;age&#125;</span>岁。&quot;</span>)</span><br><span class="line"><span class="comment"># 我叫小明, 今年18岁。</span></span><br></pre></td></tr></table></figure><p><strong>模板字符串</strong></p><p>Python提供的<code>Template类</code>也可以用来格式化字符串，它位于<strong>string</strong>包。使用Template类时，实现实例化一个Template对象。然后调用<code>substitute</code>或<code>safe_substitute</code>用传入的参数替换模板字符串中的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = Template(<span class="string">&quot;我叫$name, 今年$age岁。&quot;</span>)</span><br><span class="line">s = t.substitute(name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">s = t.substitute(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.capitalize() 格式化字符串的方法即将字符串的首字母转换为大写</span></span><br><span class="line">s=<span class="string">&#x27;development&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize())</span><br><span class="line"><span class="comment">#2.center(width,fillchar=&#x27; &#x27;) 字符串长度居中</span></span><br><span class="line">In [<span class="number">1</span>]: s=<span class="string">&#x27;air&#x27;</span></span><br><span class="line">In [<span class="number">2</span>]: s.center(<span class="number">11</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;****air****&#x27;</span></span><br><span class="line"><span class="comment"># 3.count() 统计字符或字符串出现的次数</span></span><br><span class="line">In [<span class="number">3</span>]: s=<span class="string">&#x27;hahahahahahahaha&#x27;</span></span><br><span class="line">In [<span class="number">4</span>]: s.count(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">8</span></span><br><span class="line"><span class="comment">#4.endswith() 判断字符串是不是以XXX结尾</span></span><br><span class="line"><span class="comment">#5.startswith() 判断字符串是不是以XXX开头</span></span><br><span class="line"><span class="comment">#6.index() 查询字符或字符串在字符串中第一次出现的位置，如果没有则抛出异常</span></span><br><span class="line"><span class="comment">#7.rindex() 从右往左查询字符或字符串在字符串中第一次出现的位置，如果没有则抛出异常</span></span><br><span class="line"><span class="comment">#8.find() 查询字符或字符串在字符串中第一次出现的位置，如果没有则会返回-1</span></span><br><span class="line"><span class="comment">#9.rfind() 从右往左查询字符或字符串在字符串中第一次出现的位置，如果没有则会返回-1</span></span><br><span class="line"><span class="comment">#10.encode() 将字符串转换为字节数据的方法</span></span><br><span class="line"><span class="comment">#11.decode() 将字节数据转换为字符数据的方法</span></span><br><span class="line"><span class="comment">#12.format() 格式化字符串</span></span><br><span class="line"><span class="comment">#13.islower() 判断字母是否全为小写</span></span><br><span class="line"><span class="comment">#14.isupper() 判断字母是否全为大写</span></span><br><span class="line"><span class="comment">#15.istitle() 判断是否为标题</span></span><br><span class="line"><span class="comment">#16.isspace() 判断是否为空格</span></span><br><span class="line"><span class="comment">#17.isdigit() 判断是否为数字</span></span><br><span class="line"><span class="comment">#18.isalnum() 判断是否为有效字符（数字、字母、下划线）</span></span><br><span class="line"><span class="comment">#19.isalpha() 判断是否全为字母</span></span><br><span class="line"><span class="comment">#20.title() 将字符串转换为标题</span></span><br><span class="line"><span class="comment">#21.lower() 将字符全部转换为小写</span></span><br><span class="line"><span class="comment">#22.upper() 将字符全部转换为大写</span></span><br><span class="line"><span class="comment">#23.split() 将字符串按照特定的格式进行分割，返回值是一个列表</span></span><br><span class="line"><span class="comment">#24.join() 按照特定的符号将一个可迭代对象拼接成字符串</span></span><br><span class="line">In [<span class="number">5</span>]: s=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">In [<span class="number">6</span>]: <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment">#25.strip() 清除字符串两侧空格   strip(&#x27;\n&#x27;) 清除字符串两侧换行</span></span><br><span class="line"><span class="comment">#26.lstrip() 清除字符串左边空格</span></span><br><span class="line"><span class="comment">#27.rstrip() 清除字符串右边空格</span></span><br><span class="line"><span class="comment">#28.replace(old,new) 用新的字符代替旧的字符</span></span><br><span class="line"><span class="comment">#29.ljust() 左对齐</span></span><br><span class="line"><span class="comment">#30.rjust() 右对齐</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>Python 中的序列是一块可存放多个值的连续内存空间，所有值按一定顺序排列，每个值所在位置都有一个编号，称其为索引，我们可以通过索引访问其对应值。</p><p>序列索引支持非负数和负数，索引为非负数，从 <code>0</code> 开始</p><blockquote><p>元素1  元素2  元素3  元素4 ………………….元素n<br> 0             1        2         3      ………………….   n-1</p></blockquote><p>索引为负数由右向左计数，从 <code>-1</code> 开始</p><blockquote><p>元素1  元素2  元素3  元素4 ………………….元素n<br>  -n      -(n-1)   -(n-2)  -(n-3)  …………………    -1</p></blockquote><p>切片</p><p>切片操作可以访问一定范围内的元素，语法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sname[start : end : step]</span><br></pre></td></tr></table></figure><ul><li><p>sname：表示序列的名称；</p></li><li><p>start：开始索引位置（包括该位置），默认为 0；</p></li><li><p>end：表示切片的结束索引位置（不包括该位置），默认为序列的长度；</p></li><li><p>step：步长。</p></li><li><p>```python<br>str = ‘Python’<br>print(str[:3])<br>print(str[3:])<br>print(str[:])<br>#结果如下<br>Pyt<br>hon<br>Python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">相加</span><br><span class="line"></span><br><span class="line">Python 支持类型相同的序列使用 `+` 作相加操作，该操作不会去除重复的元素。以字符串为例，如下所示：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">str1 = &#x27;Python&#x27;</span><br><span class="line">str2 = &#x27;Python&#x27;</span><br><span class="line">print(&#x27;str1 + str2 --&gt; &#x27;,str1 + str2)</span><br><span class="line">#结果</span><br><span class="line">str1 + str2 --&gt;  PythonPython</span><br></pre></td></tr></table></figure></li></ul><p>Python 使用 <code>in</code> 关键字检查某元素是否为序列的成员，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val <span class="keyword">in</span> seq <span class="comment">#返回布尔类型</span></span><br></pre></td></tr></table></figure><ul><li>val：要检查的元素；</li><li>seq：指定的序列。</li></ul><p>内置函数</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">len()</td><td align="left">计算序列的长度</td></tr><tr><td align="left">max()</td><td align="left">找出序列中的最大元素</td></tr><tr><td align="left">min()</td><td align="left">找出序列中的最小元素</td></tr><tr><td align="left">list()</td><td align="left">将序列转换为列表</td></tr><tr><td align="left">str()</td><td align="left">将序列转换为字符串</td></tr><tr><td align="left">sum()</td><td align="left">计算元素的和</td></tr><tr><td align="left">sorted()</td><td align="left">对元素进行排序</td></tr><tr><td align="left">enumerate()</td><td align="left">将序列组合为一个索引序列，多用在 for 循环中</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index= %d&quot;</span> % index + <span class="string">&quot;value=%d&quot;</span> % value) <span class="comment">#可以访问下标和元素</span></span><br></pre></td></tr></table></figure><h1 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a>列表与元组</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Python 中没有数组，而是加入了功能更强大的列表（list），列表可以存储任何类型的数据，同一个列表中的数据类型还可以不同；列表是序列结构，可以进行序列结构的基本操作：索引、切片、加、乘、检查成员。</p><p><strong>创建</strong></p><p>列表中所有元素都放在一个中括号 <code>[]</code> 中，相邻元素之间用逗号 <code>,</code> 分隔，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>= [<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>访问</strong></p><p>通过索引访问列表中的值，还可以使用切片来访问</p><p><strong>更新</strong></p><p>除了对列表中现有元素进行修改外，还可以使用 <code>append()</code> 向列表中添加新元素</p><p>可以根据索引或者切片去修改原有的值，append是往列表后面再添加一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="comment"># 修改列表中第二个元素</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment"># 向列表中添加新元素</span></span><br><span class="line">l.append(<span class="string">&#x27;Hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>使用 <code>del</code> 删除列表中元素</p><p>del根据下标或者切片去删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="comment"># 删除列表中第二个元素</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span><span class="comment">#删除全部元素</span></span><br><span class="line"><span class="built_in">list</span>.clear()<span class="comment">#清空集合</span></span><br></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#count()统计列表中某个元素出现的次数</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l.count(&#x27;d&#x27;) --&gt;&quot;</span>, l.count(<span class="string">&#x27;d&#x27;</span>))</span><br><span class="line"><span class="comment"># index()查找某个元素在列表中首次出现的位置（即索引）</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l.index(&#x27;d&#x27;) --&gt;&quot;</span>, l.index(<span class="string">&#x27;d&#x27;</span>))</span><br><span class="line"><span class="comment">#remove()移除列表中某个值的首次匹配项</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">l.remove(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l --&gt;&quot;</span>, l)</span><br><span class="line"><span class="comment"># sort()对列表中元素进行排序</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">l.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;l --&gt;&#x27;</span>, l)</span><br><span class="line"><span class="comment">#copy()复制列表</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">lc = l.copy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lc --&gt;&#x27;</span>, lc)</span><br><span class="line"><span class="comment">#max() min()返回列表最大最小值</span></span><br><span class="line"><span class="built_in">max</span>=<span class="built_in">max</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（tuple）与列表类似，但元组是不可变的，可简单将其看作是不可变的列表，元组常用于保存不可修改的内容。</p><p><strong>创建</strong></p><p>元组中所有元素都放在一个小括号 <code>()</code> 中，相邻元素之间用逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>访问</strong></p><p>与列表一样</p><p><strong>修改</strong></p><p>元组中元素不能被修改，我们要用重新赋值的方式操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">t = (<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t --&gt;&#x27;</span>, t)</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>元组中的元素不能被删除，我们只能删除整个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="keyword">del</span> t</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t --&gt;&#x27;</span>, t)</span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len()计算元组中元素个数</span></span><br><span class="line">t = (<span class="number">1024</span>, <span class="number">0.5</span>, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(t) --&gt;&#x27;</span>, <span class="built_in">len</span>(t))</span><br><span class="line"><span class="comment">#max() 和 min()返回元组中元素最大、最小值</span></span><br><span class="line">t = (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;max(t) --&gt;&#x27;</span>, <span class="built_in">max</span>(t))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;min(t) --&gt;&#x27;</span>, <span class="built_in">min</span>(t))</span><br><span class="line"><span class="comment"># tuple()将列表转换为元组</span></span><br><span class="line">l = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">t = <span class="built_in">tuple</span>(l)</span><br></pre></td></tr></table></figure><h1 id="字典与集合"><a href="#字典与集合" class="headerlink" title="字典与集合"></a>字典与集合</h1><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典（dict）是 Python 的数据结构，因为都叫字典，我们不用想也知道它们是十分相似的，它们的内容都是以键-值（key-value）的方式存在的。dict 拥有良好的查询速度，dict 中的值可以是任意 Python 对象，多次对一个 key 赋 value，后面的 value 会把前面的 value 覆盖。</p><p><strong>创建字典</strong></p><p>字典的内容在花括号 <code>&#123;&#125;</code> 内，键-值（key-value）之间用冒号 <code>:</code> 分隔，键值对之间用逗号 <code>,</code> 分隔，比如创建字典 d，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 dict 函数</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">l = [(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)]</span><br><span class="line">d = <span class="built_in">dict</span>(l)</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空字典</span></span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line">d = &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>添加</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&quot;owner&quot;</span>] = <span class="string">&quot;tyson&quot;</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="built_in">dict</span>.update(&#123;<span class="string">&quot;country&quot;</span>: <span class="string">&quot;china&quot;</span>&#125;)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="built_in">dict</span>.update(temp = <span class="string">&quot;无语中&quot;</span>, <span class="built_in">help</span> = <span class="string">&quot;帮助&quot;</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">my_temp_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王员外&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">book_dict.update(**my_temp_dict)</span><br></pre></td></tr></table></figure><p><strong>访问</strong></p><p>字典中的值通过 key 进行访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;小明&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 get 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>修改</strong></p><p>修改操作，通过key进行查询然后赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;age&#x27;</span>] = <span class="string">&#x27;20&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;20&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>清空集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;小明&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">del</span> d[键值] <span class="comment">#根据键值去删除元素</span></span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）与字典相同均存储 key，但也只存储 key，因 key 不可重复，所以 set 的中的值不可重复，也是无序的。</p><p><strong>创建</strong></p><p>集合使用花括号 <code>&#123;&#125;</code> 或者 <code>set()</code> 函数创建，如果创建空集合只能使用 <code>set()</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 set 函数</span></span><br><span class="line">s = <span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空集合</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><p>集合中重复的元素会被自动过滤掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>添加元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">set</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.update(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.add(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果 注意update和add区别</span></span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;ABC&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><p>删除元素使用 remove 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>清空集合使用 <code>clear</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure><p>获取集合的长度，同样使用 <code>len</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><p>time 模块提供了很多与时间相关的类和函数，下面我们介绍一些常用的。</p><h2 id="struct-time-类"><a href="#struct-time-类" class="headerlink" title="struct_time 类"></a>struct_time 类</h2><p>time 模块的 struct_time 类代表一个时间对象，可以通过索引和属性名访问值。对应关系如下所示：</p><table><thead><tr><th align="left">索引</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year（年）</td><td align="left">如：1945</td></tr><tr><td align="left">1</td><td align="left">tm_mon（月）</td><td align="left">1 ~ 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday（日）</td><td align="left">1 ~ 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour（时）</td><td align="left">0 ~ 23</td></tr><tr><td align="left">4</td><td align="left">tm_min（分）</td><td align="left">0 ~ 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec（秒）</td><td align="left">0 ~ 61</td></tr><tr><td align="left">6</td><td align="left">tm_wday（周）</td><td align="left">0 ~ 6</td></tr><tr><td align="left">7</td><td align="left">tm_yday（一年内第几天）</td><td align="left">1 ~ 366</td></tr><tr><td align="left">8</td><td align="left">tm_isdst（夏时令）</td><td align="left">-1、0、1</td></tr></tbody></table><p>tm_sec 范围为 0 ~ 61，值 60 表示在闰秒的时间戳中有效，并且由于历史原因支持值 61。</p><p>localtime() 表示当前时间，返回类型为 struct_time 对象，示例如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(time.tm_year) <span class="comment">#结果：2022</span></span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="left">函数（常量）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">time()</td><td align="left">返回当前时间的时间戳</td></tr><tr><td align="left">gmtime([secs])</td><td align="left">将时间戳转换为格林威治天文时间下的 struct_time，可选参数 secs 表示从 epoch 到现在的秒数，默认为当前时间</td></tr><tr><td align="left">localtime([secs])</td><td align="left">与 gmtime() 相似，返回当地时间下的 struct_time</td></tr><tr><td align="left">mktime(t)</td><td align="left">localtime() 的反函数</td></tr><tr><td align="left">asctime([t])</td><td align="left">接收一个 struct_time 表示的时间，返回形式为：Mon Dec  2 08:53:47 2019 的字符串</td></tr><tr><td align="left">ctime([secs])</td><td align="left">ctime(secs) 相当于 asctime(localtime(secs))</td></tr><tr><td align="left">strftime(format[, t])</td><td align="left">格式化日期，接收一个 struct_time 表示的时间，并返回以可读字符串表示的当地时间</td></tr><tr><td align="left">sleep(secs)</td><td align="left">暂停执行调用线程指定的秒数</td></tr><tr><td align="left">altzone</td><td align="left">本地 DST 时区的偏移量，以 UTC 为单位的秒数</td></tr><tr><td align="left">timezone</td><td align="left">本地（非 DST）时区的偏移量，UTC 以西的秒数（西欧大部分地区为负，美国为正，英国为零）</td></tr><tr><td align="left">tzname</td><td align="left">两个字符串的元组：第一个是本地非 DST 时区的名称，第二个是本地 DST 时区的名称</td></tr></tbody></table><h2 id="格式化日期函数strftime"><a href="#格式化日期函数strftime" class="headerlink" title="格式化日期函数strftime"></a>格式化日期函数strftime</h2><p>strftime 函数日期格式化符号说明如下所示：</p><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">本地化的缩写星期中每日的名称</td></tr><tr><td align="left">%A</td><td align="left">本地化的星期中每日的完整名称</td></tr><tr><td align="left">%b</td><td align="left">本地化的月缩写名称</td></tr><tr><td align="left">%B</td><td align="left">本地化的月完整名称</td></tr><tr><td align="left">%c</td><td align="left">本地化的适当日期和时间表示</td></tr><tr><td align="left">%d</td><td align="left">十进制数 [01,31] 表示的月中日</td></tr><tr><td align="left">%H</td><td align="left">十进制数 [00,23] 表示的小时（24小时制）</td></tr><tr><td align="left">%I</td><td align="left">十进制数 [01,12] 表示的小时（12小时制）</td></tr><tr><td align="left">%j</td><td align="left">十进制数 [001,366] 表示的年中日</td></tr><tr><td align="left">%m</td><td align="left">十进制数 [01,12] 表示的月</td></tr><tr><td align="left">%M</td><td align="left">十进制数 [00,59] 表示的分钟</td></tr><tr><td align="left">%p</td><td align="left">本地化的 AM 或 PM</td></tr><tr><td align="left">%S</td><td align="left">十进制数 [00,61] 表示的秒</td></tr><tr><td align="left">%U</td><td align="left">十进制数 [00,53] 表示的一年中的周数（星期日作为一周的第一天）</td></tr><tr><td align="left">%w</td><td align="left">十进制数 [0(星期日),6] 表示的周中日</td></tr><tr><td align="left">%W</td><td align="left">十进制数 [00,53] 表示的一年中的周数（星期一作为一周的第一天）</td></tr><tr><td align="left">%x</td><td align="left">本地化的适当日期表示</td></tr><tr><td align="left">%X</td><td align="left">本地化的适当时间表示</td></tr><tr><td align="left">%y</td><td align="left">十进制数 [00,99] 表示的没有世纪的年份</td></tr><tr><td align="left">%Y</td><td align="left">十进制数表示的带世纪的年份</td></tr><tr><td align="left">%z</td><td align="left">时区偏移以格式 +HHMM 或 -HHMM 形式的 UTC/GMT 的正或负时差指示，其中 H 表示十进制小时数字，M 表示小数分钟数字 [-23:59, +23:59]</td></tr><tr><td align="left">%Z</td><td align="left">时区名称</td></tr><tr><td align="left">%%</td><td align="left">字面的 ‘%’ 字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.localtime()</span><br><span class="line">strftime = time.strftime(<span class="string">&quot;%Y年%m月%d日 %H:%M:%S&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(strftime)</span><br></pre></td></tr></table></figure><h2 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h2><p>datatime 模块重新封装了 time 模块，提供了更多接口，变得更加直观和易于调用。</p><h3 id="date-类"><a href="#date-类" class="headerlink" title="date 类"></a>date 类</h3><p>date 类表示一个由年、月、日组成的日期，格式为：datetime.date(year, month, day)。</p><ul><li>year 范围为：[1, 9999]</li><li>month 范围为：[1, 12]</li><li>day 范围为 [1, 给定年月对应的天数]。</li></ul><p>类方法和属性如下所示：</p><table><thead><tr><th align="left">方法（属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">today()</td><td align="left">返回当地的当前日期</td></tr><tr><td align="left">fromtimestamp(timestamp)</td><td align="left">根据给定的时间戮，返回本地日期</td></tr><tr><td align="left">min</td><td align="left">date 所能表示的最小日期</td></tr><tr><td align="left">max</td><td align="left">date 所能表示的最大日期</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.date.today())</span><br><span class="line"><span class="built_in">print</span>(datetime.date.fromtimestamp(time.time()))</span><br><span class="line"><span class="built_in">print</span>(datetime.date.<span class="built_in">min</span>)</span><br><span class="line"><span class="built_in">print</span>(datetime.date.<span class="built_in">max</span>)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">10</span>-<span class="number">24</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">10</span>-<span class="number">24</span></span><br><span class="line">0001-01-01</span><br><span class="line"><span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span></span><br></pre></td></tr></table></figure><p>实例方法和属性如下所示：</p><table><thead><tr><th align="left">方法（属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">replace(year, month, day)</td><td align="left">生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性</td></tr><tr><td align="left">timetuple()</td><td align="left">返回日期对应的 struct_time 对象</td></tr><tr><td align="left">weekday()</td><td align="left">返回一个整数代表星期几，星期一为 0，星期天为 6</td></tr><tr><td align="left">isoweekday()</td><td align="left">返回一个整数代表星期几，星期一为 1，星期天为 7</td></tr><tr><td align="left">isocalendar()</td><td align="left">返回格式为 (year，month，day) 的元组</td></tr><tr><td align="left">isoformat()</td><td align="left">返回格式如 YYYY-MM-DD 的字符串</td></tr><tr><td align="left">strftime(format)</td><td align="left">返回自定义格式的字符串</td></tr><tr><td align="left">year</td><td align="left">年</td></tr><tr><td align="left">month</td><td align="left">月</td></tr><tr><td align="left">day</td><td align="left">日</td></tr></tbody></table><p>使用示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">td = datetime.date.today()</span><br><span class="line"><span class="built_in">print</span>(td.replace(year=<span class="number">1945</span>, month=<span class="number">8</span>, day=<span class="number">15</span>))</span><br><span class="line"><span class="built_in">print</span>(td.timetuple())</span><br><span class="line"><span class="built_in">print</span>(td.weekday())</span><br><span class="line"><span class="built_in">print</span>(td.isoweekday())</span><br><span class="line"><span class="built_in">print</span>(td.isocalendar())</span><br><span class="line"><span class="built_in">print</span>(td.isoformat())</span><br><span class="line"><span class="built_in">print</span>(td.strftime(<span class="string">&#x27;%Y %m %d %H:%M:%S %f&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(td.year)</span><br><span class="line"><span class="built_in">print</span>(td.month)</span><br><span class="line"><span class="built_in">print</span>(td.day)</span><br></pre></td></tr></table></figure><h3 id="time-类"><a href="#time-类" class="headerlink" title="time 类"></a>time 类</h3><p>time 类表示由时、分、秒、微秒组成的时间，格式为：time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)。</p><ul><li>hour 范围为：[0, 24)</li><li>minute 范围为：[0, 60)</li><li>second 范围为：[0, 60)</li><li>microsecond 范围为：[0, 1000000)</li><li>fold 范围为：[0, 1]</li></ul><p>实例方法和属性如下所示：</p><table><thead><tr><th align="left">方法（属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">isoformat()</td><td align="left">返回 HH:MM:SS 格式的字符串</td></tr><tr><td align="left">replace(hour, minute, second, microsecond, tzinfo, * fold=0)</td><td align="left">创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性</td></tr><tr><td align="left">strftime(format)</td><td align="left">返回自定义格式的字符串</td></tr><tr><td align="left">hour</td><td align="left">时</td></tr><tr><td align="left">minute</td><td align="left">分</td></tr><tr><td align="left">second</td><td align="left">秒</td></tr><tr><td align="left">microsecond</td><td align="left">微秒</td></tr><tr><td align="left">tzinfo</td><td align="left">时区</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">t = datetime.time(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(t.isoformat())</span><br><span class="line"><span class="built_in">print</span>(t.replace(hour=<span class="number">9</span>, minute=<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(t.strftime(<span class="string">&#x27;%I:%M:%S %p&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(t.hour)</span><br><span class="line"><span class="built_in">print</span>(t.minute)</span><br><span class="line"><span class="built_in">print</span>(t.second)</span><br><span class="line"><span class="built_in">print</span>(t.microsecond)</span><br><span class="line"><span class="built_in">print</span>(t.tzinfo)</span><br></pre></td></tr></table></figure><h3 id="datetime-类"><a href="#datetime-类" class="headerlink" title="datetime 类"></a>datetime 类</h3><p>datetime 包括了 date 与 time 的所有信息，格式为：datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)，参数范围值参考 date 类与 time 类。</p><p>类方法和属性如下所示：</p><table><thead><tr><th align="left">方法（属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">today()</td><td align="left">返回当地的当前时间</td></tr><tr><td align="left">now(tz=None)</td><td align="left">类似于 today()，可选参数 tz 可指定时区</td></tr><tr><td align="left">utcnow()</td><td align="left">返回当前 UTC 时间</td></tr><tr><td align="left">fromtimestamp(timestamp, tz=None)</td><td align="left">根据时间戳返回对应时间</td></tr><tr><td align="left">utcfromtimestamp(timestamp)</td><td align="left">根据时间戳返回对应 UTC 时间</td></tr><tr><td align="left">combine(date, time)</td><td align="left">根据 date 和 time 返回对应时间</td></tr><tr><td align="left">min</td><td align="left">datetime 所能表示的最小日期</td></tr><tr><td align="left">max</td><td align="left">datetime 所能表示的最大日期</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.today())</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.utcnow())</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.fromtimestamp(time.time()))</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.utcfromtimestamp(time.time()))</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.combine(datetime.date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">1</span>), datetime.time(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)))</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.<span class="built_in">min</span>)</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>实例方法和属性如下所示：</p><table><thead><tr><th align="left">方法（属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">date()</td><td align="left">返回具有同样 year,month,day 值的 date 对象</td></tr><tr><td align="left">time()</td><td align="left">返回具有同样 hour, minute, second, microsecond 和 fold 值的 time 对象</td></tr><tr><td align="left">replace(year, month, day=self.day, hour, minute, second, microsecond, tzinfo, * fold=0)</td><td align="left">生成一个新的日期对象，用参数指定的年，月，日，时，分，秒…代替原有对象中的属性</td></tr><tr><td align="left">weekday()</td><td align="left">返回一个整数代表星期几，星期一为 0，星期天为 6</td></tr><tr><td align="left">isoweekday()</td><td align="left">返回一个整数代表星期几，星期一为 1，星期天为 7</td></tr><tr><td align="left">isocalendar()</td><td align="left">返回格式为 (year，month，day) 的元组</td></tr><tr><td align="left">isoformat()</td><td align="left">返回一个以 ISO 8601 格式表示日期和时间的字符串 YYYY-MM-DDTHH:MM:SS.ffffff</td></tr><tr><td align="left">strftime(format)</td><td align="left">返回自定义格式的字符串</td></tr><tr><td align="left">year</td><td align="left">年</td></tr><tr><td align="left">month</td><td align="left">月</td></tr><tr><td align="left">day</td><td align="left">日</td></tr><tr><td align="left">hour</td><td align="left">时</td></tr><tr><td align="left">minute</td><td align="left">分</td></tr><tr><td align="left">second</td><td align="left">秒</td></tr><tr><td align="left">microsecond</td><td align="left">微秒</td></tr><tr><td align="left">tzinfo</td><td align="left">时区</td></tr></tbody></table><p>使用示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">td = datetime.datetime.today()</span><br><span class="line"><span class="built_in">print</span>(td.date())</span><br><span class="line"><span class="built_in">print</span>(td.time())</span><br><span class="line"><span class="built_in">print</span>(td.replace(day=<span class="number">11</span>, second=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(td.weekday())</span><br><span class="line"><span class="built_in">print</span>(td.isoweekday())</span><br><span class="line"><span class="built_in">print</span>(td.isocalendar())</span><br><span class="line"><span class="built_in">print</span>(td.isoformat())</span><br><span class="line"><span class="built_in">print</span>(td.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S .%f&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(td.year)</span><br><span class="line"><span class="built_in">print</span>(td.month)</span><br><span class="line"><span class="built_in">print</span>(td.month)</span><br><span class="line"><span class="built_in">print</span>(td.hour)</span><br><span class="line"><span class="built_in">print</span>(td.minute)</span><br><span class="line"><span class="built_in">print</span>(td.second)</span><br><span class="line"><span class="built_in">print</span>(td.microsecond)</span><br><span class="line"><span class="built_in">print</span>(td.tzinfo)</span><br></pre></td></tr></table></figure><h2 id="calendar-模块"><a href="#calendar-模块" class="headerlink" title="calendar 模块"></a>calendar 模块</h2><p>calendar 模块提供了很多可以处理日历的函数。</p><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">setfirstweekday(weekday)</td><td align="left">设置每一周的开始(0 表示星期一，6 表示星期天)</td></tr><tr><td align="left">firstweekday()</td><td align="left">返回当前设置的每星期的第一天的数值</td></tr><tr><td align="left">isleap(year)</td><td align="left">如果 year 是闰年则返回 True ,否则返回 False</td></tr><tr><td align="left">leapdays(y1, y2)</td><td align="left">返回 y1 至 y2 （包含 y1 和 y2 ）之间的闰年的数量</td></tr><tr><td align="left">weekday(year, month, day)</td><td align="left">返回指定日期的星期值</td></tr><tr><td align="left">monthrange(year, month)</td><td align="left">返回指定年份的指定月份第一天是星期几和这个月的天数</td></tr><tr><td align="left">month(theyear, themonth, w=0, l=0)</td><td align="left">返回月份日历</td></tr><tr><td align="left">prcal(year, w=0, l=0, c=6, m=3)</td><td align="left">返回年份日历</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">calendar.setfirstweekday(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(calendar.firstweekday())</span><br><span class="line"><span class="built_in">print</span>(calendar.isleap(<span class="number">2019</span>))</span><br><span class="line"><span class="built_in">print</span>(calendar.leapdays(<span class="number">1945</span>, <span class="number">2019</span>))</span><br><span class="line"><span class="built_in">print</span>(calendar.weekday(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(calendar.monthrange(<span class="number">2019</span>, <span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(calendar.month(<span class="number">2019</span>, <span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(calendar.prcal(<span class="number">2019</span>))</span><br></pre></td></tr></table></figure><h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>Calendar 对象提供了一些日历数据格式化的方法，实例方法如下所示：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">iterweekdays()</td><td align="left">返回一个迭代器，迭代器的内容为一星期的数字</td></tr><tr><td align="left">itermonthdates(year, month)</td><td align="left">返回一个迭代器，迭代器的内容为年 、月的日期</td></tr></tbody></table><p>使用示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> Calendar</span><br><span class="line"></span><br><span class="line">c = Calendar()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(c.iterweekdays()))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c.itermonthdates(<span class="number">2019</span>, <span class="number">12</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="TextCalendar-类"><a href="#TextCalendar-类" class="headerlink" title="TextCalendar 类"></a>TextCalendar 类</h3><p>TextCalendar 为 Calendar子类，用来生成纯文本日历。实例方法如下所示：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">formatmonth(theyear, themonth, w=0, l=0)</td><td align="left">返回一个多行字符串来表示指定年、月的日历</td></tr><tr><td align="left">formatyear(theyear, w=2, l=1, c=6, m=3)</td><td align="left">返回一个 m 列日历，可选参数 w, l, 和 c 分别表示日期列数， 周的行数， 和月之间的间隔</td></tr></tbody></table><p>使用示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> TextCalendar</span><br><span class="line"></span><br><span class="line">tc = TextCalendar()</span><br><span class="line"><span class="built_in">print</span>(tc.formatmonth(<span class="number">2019</span>, <span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(tc.formatyear(<span class="number">2019</span>))</span><br></pre></td></tr></table></figure><h3 id="HTMLCalendar类"><a href="#HTMLCalendar类" class="headerlink" title="HTMLCalendar类"></a>HTMLCalendar类</h3><p>HTMLCalendar 类可以生成 HTML 日历。实例方法如下所示：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">formatmonth(theyear, themonth, withyear=True)</td><td align="left">返回一个 HTML 表格作为指定年、月的日历</td></tr><tr><td align="left">formatyear(theyear, width=3)</td><td align="left">返回一个 HTML 表格作为指定年份的日历</td></tr><tr><td align="left">formatyearpage(theyear, width=3, css=’calendar.css’, encoding=None)</td><td align="left">返回一个完整的 HTML 页面作为指定年份的日历</td></tr></tbody></table><p>使用示例如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> HTMLCalendar</span><br><span class="line">hc = HTMLCalendar()<span class="built_in">print</span>(hc.formatmonth(<span class="number">2019</span>, <span class="number">12</span>))<span class="built_in">print</span>(hc.formatyear(<span class="number">2019</span>))<span class="built_in">print</span>(hc.formatyearpage(<span class="number">2019</span>))</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>简单来说函数就是一段实现特定功能的代码，使用函数可以提高代码的重复利用率。Python 中有很多内置函数，比如之前常用的 print 函数，当内置函数不足以满足我们的需求时，我们还可以自定义函数。</p><p>自定义函数</p><p>Python 使用 def 关键字来声明函数，格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>):</span><br><span class="line">函数体</span><br><span class="line"><span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure><p>如果要定义一个无任何功能的空函数，函数体只写 <code>pass</code> 即可。格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当我们不确定参数的个数时，可以使用不定长参数，在参数名前加 <code>*</code> 进行声明，格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">*参数名</span>):</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>我们还可以使用 <code>lambda</code> 定义匿名函数，格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数 : 表达式</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_empty</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_print</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sum</span>(<span class="params">x, y</span>):</span><br><span class="line">    s = x + y</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;s--&gt;&#x27;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不定长参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_variable</span>(<span class="params">*params</span>):</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        <span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">my_sub = <span class="keyword">lambda</span> x, y: x - y</span><br></pre></td></tr></table></figure><h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><p><strong>模块</strong></p><p>Python 中一个以 <code>.py</code> 结尾的文件就是一个模块，模块中定义了变量、函数等来实现一些类似的功能。Python 有很多自带的模块（标准库）和第三方模块，一个模块可以被其他模块引用，实现了代码的复用性。</p><p><strong>包</strong></p><p>包是存放模块的文件夹，包中包含 <code>__init__.py</code> 和其他模块，<code>__init__.py</code> 可为空也可定义属性和方法，在 Python3.3 之前的版本，一个文件夹中只有包含 <code>__init__.py</code>，其他程序才能从该文件夹引入相应的模块、函数等，之后的版本没有 <code>__init__.py</code> 也能正常导入，简单来说就是 Python3.3 之前的版本，<code>__init__.py</code> 是包的标识，是必须要有的，之后的版本可以没有。</p><p><strong>创建包</strong></p><p>使用 PyCharm 创建包，步骤为：①打开 PyCharm 选中项目 ②右击鼠标选中 <code>New</code> 选项，然后再选中 <code>Python Package</code> 后单击鼠标，此时弹出创建窗口，如下所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIq3U5HM6kmaOenNbcA3lILbKynyT83lXA8owxzEM27wDSoqErGicglWpYNiaiaQvOqF3vlb0GTMZP0qA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>们填好名字后点击 <code>OK</code> 按钮即可。创建好后我们会发现 PyCharm 已经自动帮我们创建了空文件 <code>__init__.py</code>。</p><p><strong>创建模块</strong></p><p>使用 PyCharm 创建模块，步骤为：①选中刚刚创建的包  ②右击鼠标选中 <code>New</code> 选项，然后再选中 <code>Python File</code> 后单击鼠标，此时弹出创建窗口，如下所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIq3U5HM6kmaOenNbcA3lILbBibfI2ZXppOicEA2qhC8zq3eQtgaDTaT6MaM79aicZe8wpKNYDKW4AKNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>我们填好名字后点击 <code>OK</code> 按钮即可。</p><p>我们创建包和模块的最终目录结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package</span><br><span class="line">|- pg1</span><br><span class="line">|- - __init__.py</span><br><span class="line">|- - a.py</span><br><span class="line">|- - b.py</span><br><span class="line">|- pg2</span><br><span class="line">|- - __init__.py</span><br><span class="line">|- - c.py</span><br><span class="line">|- - d.py</span><br></pre></td></tr></table></figure><p>a.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p>b.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>c.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">c</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>d.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><p>从包中引入模块有如下两种方式：</p><p>import …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 包名1.包名2...模块名</span><br></pre></td></tr></table></figure><p>from … import …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from 包名1.包名2... import 模块名</span><br><span class="line">from 包名1.包名2...模块名 import 变量名/函数名</span><br></pre></td></tr></table></figure><p>下面我们使用创建好的包和模块演示一下，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># a 模块中引入 b 模块</span></span><br><span class="line"><span class="keyword">import</span> pg1.b</span><br><span class="line"><span class="keyword">from</span> pg1 <span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment"># a 模块中引入 c 模块</span></span><br><span class="line"><span class="keyword">import</span> pg2.c</span><br><span class="line"><span class="keyword">from</span> pg2 <span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># a 模块中引入 c 模块和 d 模块</span></span><br><span class="line"><span class="keyword">import</span> pg2.c,pg2.d</span><br><span class="line"><span class="keyword">from</span> pg2 <span class="keyword">import</span> c,d</span><br><span class="line"></span><br><span class="line"><span class="comment"># a 模块中引入包 pg2 下的所有模块</span></span><br><span class="line"><span class="keyword">from</span> pg2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># a 模块中引入 d 模块中函数 d()</span></span><br><span class="line"><span class="keyword">from</span> pg2.d <span class="keyword">import</span> d</span><br><span class="line"><span class="comment"># 调用函数 d()</span></span><br><span class="line">d()</span><br></pre></td></tr></table></figure><h1 id="python类和对象"><a href="#python类和对象" class="headerlink" title="python类和对象"></a>python类和对象</h1><p>python对象中的类成员</p><ul><li>字段</li><li>方法</li><li>属性</li></ul><p>字段</p><p>字段包括：普通字段和静态字段，使用和定义都是不一样，其最本质的区别就是内存中保存的位置不同。</p><blockquote><p>普通字段属于对象<br>静态字段属于类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;ren&#x27;</span> <span class="comment">#静态字段</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#普通字段</span></span><br><span class="line">        self.name = <span class="string">&#x27;mingzi&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.<span class="built_in">type</span> = <span class="string">&#x27;woman&#x27;</span></span><br><span class="line">p.name = <span class="string">&#x27;man&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Person.<span class="built_in">type</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br></pre></td></tr></table></figure><p>方法</p><p>方法包括：普通方法、静态方法和类方法。</p><ul><li>普通方法：由对象调用；包含一个self参数；执行普通方法时，自动将调用该方法的对象赋值给self；</li><li>类方法：由类调用； 包含一个cls参数；执行类方法时，自动将调用该方法的类复制给cls；使用@classmethod装饰器</li><li>静态方法：由类调用；没有默认参数；使用@staticmethod装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">name</span>):</span><br><span class="line">       self.name=name</span><br><span class="line">       </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.count += <span class="number">1</span>       <span class="comment"># 可以通过类名修改类属性</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.count</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_func</span>():      <span class="comment"># 静态方法 可以通过类名直接调用该方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;普通函数&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>属性</p><p>python中的属性就是普通方法的变种，就是将一个方法伪装成一个属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;is A func&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_AAA</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_AAA</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete_AAA</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;delete的时候运行我啊&#x27;</span>)</span><br></pre></td></tr></table></figure><p>继承</p><p>Python 支持类的继承，而且支持多继承，语法格式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类</span>(父类<span class="number">1</span>，父类<span class="number">2.</span>....):</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#例如</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 波斯猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersianCat</span>(<span class="title class_ inherited__">Cat</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;正在吃&#x27;</span>+food)</span><br><span class="line"><span class="comment">#加菲猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarfieldCat</span>(<span class="title class_ inherited__">Cat</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, speed</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;正在以&#x27;</span>+speed+<span class="string">&#x27;的速度奔跑&#x27;</span>)</span><br><span class="line"><span class="comment"># 单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCat</span>(<span class="title class_ inherited__">PersianCat</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCat</span>(PersianCat, GarfieldCat):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">sc = SingleCat(<span class="string">&#x27;波斯猫1号&#x27;</span>)</span><br><span class="line">sc.eat(<span class="string">&#x27;鱼&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mc = MultiCat(<span class="string">&#x27;波斯加菲猫1号&#x27;</span>)</span><br><span class="line">mc.eat(<span class="string">&#x27;鱼&#x27;</span>)</span><br><span class="line">mc.run(<span class="string">&#x27;50迈&#x27;</span>)</span><br><span class="line"><span class="comment">#如果继承的父类方法不能满足我们的需求，这时子类可以重写父类方法，如下所示：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCat</span>(<span class="title class_ inherited__">PersianCat</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food </span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;正在吃&#x27;</span>+food, <span class="string">&#x27;十分钟后&#x27;</span>, self.name+<span class="string">&#x27;吃饱了&#x27;</span>)</span><br><span class="line">sc = SingleCat(<span class="string">&#x27;波斯猫1号&#x27;</span>)</span><br><span class="line">sc.eat(<span class="string">&#x27;鱼&#x27;</span>)</span><br></pre></td></tr></table></figure><p>抽象类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc <span class="comment">#利用abc模块实现抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shuiguo</span>(metaclass=abc.ABCMeta):</span><br><span class="line">    </span><br><span class="line">    all_type=<span class="string">&#x27;sg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment">#定义抽象方法，无需实现功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment">#定义抽象方法，无需实现功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>(<span class="title class_ inherited__">shuiguo</span>): <span class="comment">#子类继承抽象类，可是必须定义read和write方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是苹果&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;好吃&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span>(<span class="title class_ inherited__">shuiguo</span>): <span class="comment">#子类继承抽象类，可是必须定义read和write方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是梨子&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;yunfeizhike&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apple =Apple()</span><br><span class="line"></span><br><span class="line">pear=Pear()</span><br><span class="line"></span><br><span class="line">apple.func()</span><br><span class="line">pear.name()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pear.all_type)</span><br><span class="line"><span class="built_in">print</span>(apple.all_type)</span><br></pre></td></tr></table></figure><h1 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h1><p>在编程工作中文件操作还是比较常见的，基本文件操作包括：创建、读、写、关闭等，Python 中内置了一些文件操作函数，我们使用 Python 操作文件还是很方便的。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>Python 使用 <code>open()</code> 函数创建或打开文件，语法格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#当有with关键字的时候我们通常写</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>() <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#执行文件操作且不需要执行close函数去关闭流，with会自动帮我们做好</span></span><br></pre></td></tr></table></figure><p>参数说明如下所示：</p><ul><li><strong>file</strong>：表示将要打开的文件的路径，也可以是要被封装的整数类型文件描述符。</li><li><strong>mode</strong>：是一个可选字符串，用于指定打开文件的模式，默认值是 <code>&#39;r&#39;</code>（以文本模式打开并读取）。可选模式如下：</li></ul><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">读取（默认）</td></tr><tr><td align="left">w</td><td align="left">写入，并先截断文件</td></tr><tr><td align="left">x</td><td align="left">排它性创建，如果文件已存在则失败</td></tr><tr><td align="left">a</td><td align="left">写入，如果文件存在则在末尾追加</td></tr><tr><td align="left">b</td><td align="left">二进制模式</td></tr><tr><td align="left">t</td><td align="left">文本模式（默认）</td></tr><tr><td align="left">+</td><td align="left">更新磁盘文件（读取并写入）</td></tr></tbody></table><ul><li><strong>buffering</strong>：是一个可选的整数，用于设置缓冲策略。</li><li><strong>encoding</strong>：用于解码或编码文件的编码的名称。</li><li><strong>errors</strong>：是一个可选的字符串，用于指定如何处理编码和解码错误（不能在二进制模式下使用）。</li><li><strong>newline</strong>：区分换行符。</li><li><strong>closefd</strong>：如果 closefd 为 False 并且给出了文件描述符而不是文件名，那么当文件关闭时，底层文件描述符将保持打开状态；如果给出文件名，closefd 为 True （默认值），否则将引发错误。</li><li><strong>opener</strong>：可以通过传递可调用的 opener 来使用自定义开启器。</li></ul><p>以 txt 格式文件为例，我们不手动创建文件，通过代码方式来创建，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行完上述代码，就为我们创建好了 test.txt 文件。</p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a><strong>写入</strong></h2><p>上面我们创建的文件 test.txt 没有任何内容，我们向这个文件中写入一些信息，对于写操作，Python 文件对象提供了两个函数，如下所示：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">write(str)</td><td align="left">将字符串写入文件，返回写入字符长度</td></tr><tr><td align="left">writelines(s)</td><td align="left">向文件写入一个字符串列表</td></tr></tbody></table><p>我们使用这两个函数向文件中写入一些信息，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wf = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">wf.write(<span class="string">&#x27;Tom\n&#x27;</span>)</span><br><span class="line">wf.writelines([<span class="string">&#x27;Hello\n&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>])</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">wf.close</span><br></pre></td></tr></table></figure><p>上面我们使用了 close() 函数进行关闭操作，如果打开的文件忘记了关闭，可能会对程序造成一些隐患，为了避免这个问题的出现，可以使用 <code>with as</code> 语句，通过这种方式，程序执行完成后会自动关闭已经打开的文件。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">    wf.write(<span class="string">&#x27;Tom\n&#x27;</span>)</span><br><span class="line">    wf.writelines([<span class="string">&#x27;Hello\n&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a><strong>读取</strong></h2><p>之前我们已经向文件中写入了一些内容，现在我们读取一下，对于文件的读操作，Python 文件对象提供了三个函数，如下所示：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">read(size)</td><td align="left">读取指定的字节数，参数可选，无参或参数为负时读取所有</td></tr><tr><td align="left">readline()</td><td align="left">读取一行</td></tr><tr><td align="left">readlines()</td><td align="left">读取所有行并返回列表</td></tr></tbody></table><p>我们使用上面三个函数读取一下之前写入的内容，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> rf:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;readline--&gt;&#x27;</span>, rf.readline())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;read--&gt;&#x27;</span>, rf.read(<span class="number">6</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;readlines--&gt;&#x27;</span>, rf.readlines())</span><br></pre></td></tr></table></figure><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>Python 提供了两个与文件对象位置相关的函数，如下所示：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tell()</td><td align="left">返回文件对象在文件中的当前位置</td></tr><tr><td align="left">file.seek(offset[, whence])</td><td align="left">将文件对象移动到指定的位置；offset 表示移动的偏移量；whence 为可选参数，值为 0 表示从文件开头起算（默认值）、值为 1 表示使用当前文件位置、值为 2 表示使用文件末尾作为参考点</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;rb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b&#x27;123456789&#x27;</span>)</span><br><span class="line">    <span class="comment"># 文件对象位置</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())</span><br><span class="line">    <span class="comment"># 移动到文件的第四个字节</span></span><br><span class="line">    f.seek(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 读取一个字节，文件对象向后移动一位</span></span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(f.tell())</span><br><span class="line">    <span class="comment"># 移动到倒数第二个字节</span></span><br><span class="line">    f.seek(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.tell())</span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h1><p>我们都知道 os 中文就是操作系统的意思，顾名思义，Python 的 os 模块提供了各种操作系统的接口，这些接口主要是用来操作文件和目录。</p><p>Python 中所有依赖于操作系统的内置模块统一设计方式为：对于不同操作系统可用的相同功能使用相同的接口，这样大大增加了代码的可移植性；当然，通过 os 模块操作某一系统的扩展功能也是可以的，但这样做会损害代码的可移植性。</p><p><strong>常用函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入os</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os.getcwd()查看当前路径。</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line"><span class="comment">#os.listdir(path)返回指定目录下包含的文件和目录名列表。</span></span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&#x27;E:/&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.abspath(path)返回路径 path 的绝对路径。</span></span><br><span class="line"><span class="comment"># 当前路径（相对路径方式）</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.split(path)将路径 path 拆分为目录和文件两部分，返回结果为元组类型。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.split(<span class="string">&#x27;E:/tmp.txt&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.join(path, *paths)将一个或多个 path（文件或目录） 进行拼接。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;E:/&#x27;</span>, <span class="string">&#x27;tmp.txt&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.getmtime(path)返回 path（文件或目录）的最后修改时间。</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.utcfromtimestamp(os.path.getmtime(<span class="string">&#x27;E:/tmp.txt&#x27;</span>)))</span><br><span class="line"><span class="comment">#os.path.exists(path)判断 path（文件或目录）是否存在，存在返回 True，否则返回 False。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;E:/tmp.txt&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.isdir(path)判断 path 是否为目录。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">&#x27;E:/&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.isfile(path)判断 path 是否为文件。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&#x27;E:/tmp.txt&#x27;</span>))</span><br><span class="line"><span class="comment">#os.path.getsize(path)返回 path 的大小，以字节为单位，若 path 是目录则返回 0。</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">&#x27;E:/tmp.txt&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">&#x27;E:/work&#x27;</span>))</span><br><span class="line"><span class="comment">#os.mkdir()创建一个目录。</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;E:/test&#x27;</span>)</span><br><span class="line"><span class="comment">#os.makedirs()创建多级目录。目录 test1、test2 均不存在，此时使用 os.mkdir() 创建会报错，也就是说 os.mkdir() 创建目录时要保证末级目录之前的目录是存在的。</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;E:/test1/test2&#x27;</span>)</span><br><span class="line"><span class="comment">#os.chdir(path)将当前工作目录更改为 path。</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line">os.chdir(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line"><span class="comment">#os.system(command)调用 shell 脚本。</span></span><br><span class="line"><span class="built_in">print</span>(os.system(<span class="string">&#x27;ping www.baidu.com&#x27;</span>))</span><br><span class="line"><span class="comment">#如果出现乱码，可以通过修改编码解决，比如：我在 Windows 下 PyCharm 中出现乱码问题，可以将 PyCharm 中编码修改为 GBK 解决。</span></span><br></pre></td></tr></table></figure><h1 id="python异常和错误"><a href="#python异常和错误" class="headerlink" title="python异常和错误"></a>python异常和错误</h1><p>程序中的错误我们通常称为 bug ，工作中我们不仅需要改自己程序中的 bug ，还需要改别人程序中的 bug ，新项目有 bug 要改，老项目也有 bug 要改，可以说 bug 几乎贯穿一个程序员的职业生涯… 我们通常将 bug 分为 Error（错误） 和 Exception（异常），我们下面来具体学习下 Python 中的 错误 和 异常。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>错误 通常是指程序中的 语法错误 或 逻辑错误，来通过两个 Python 例子看一下：</p><p><strong>语法错误示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print前面少了 : </span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello python&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们编写程序通常使用开发工具编写，比如：我使用 Pycharm 工具编写 Python 程序，像这种语法错误，在编写程序时，编译器就会检测出来并提示我们，因此，我们编写好的程序几乎不会出现这种问题。</p><p><strong>逻辑错误示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 是不能作为被除数的</span></span><br><span class="line">a  = <span class="number">5</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a/b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果：ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure><p>逻辑错误编译器是不会提示我们的，因此，我们编写程序时，对一些基本常识要有一定了解，从而，避免出现逻辑错误。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误，运行期检测到的错误被称为异常；大多数的异常都不会被程序处理，都以错误信息的形式展现。</p><h3 id="Python-内置异常"><a href="#Python-内置异常" class="headerlink" title="Python 内置异常"></a>Python 内置异常</h3><p>我们先来看一下异常层次结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure><p>通过上面的异常层次结构，我们可以清晰的看出，BaseException为所有异常的基类，其下面分为：SystemExit、KeyboardInterrupt、GeneratorExit、Exception 四类异常，Exception 为所有非系统退出类异常的基类，Python 提倡继承 Exception 或其子类派生新的异常；Exception 下包含我们常见的多种异常如：MemoryError（内存溢出）、BlockingIOError（IO异常）、SyntaxError（语法错误异常）… 详细说明可以查看下面列表：</p><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入/输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块/对象失败</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明/初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Python 程序捕捉异常使用 try/except 语句，先看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#1、被除数为 0，未捕获异常</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNum</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"><span class="built_in">print</span>(getNum(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#输出结果：ZeroDivisionError: division by zero</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、捕获异常</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error: IOError argument.&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error: ZeroDivisionError argument.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(getNum(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">Error: ZeroDivisionError argument.</span></span><br><span class="line"><span class="string">None</span></span><br></pre></td></tr></table></figure><p>try 语句的工作方式为：</p><ul><li>首先，执行 try 子句 （在 try 和 except 关键字之间的部分）；</li><li>如果没有异常发生， except 子句 在 try 语句执行完毕后就被忽略了；</li><li>如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略；</li><li>如果异常匹配于 except 关键字后面指定的异常类型，就执行对应的except子句，然后继续执行 try 语句之后的代码；</li><li>如果发生了一个异常，在 except 子句中没有与之匹配的分支，它就会传递到上一级 try 语句中；</li><li>如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。</li></ul><p><strong>try/except 语句还可以带有一个 else、finally子句，示例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;try --&gt; &#x27;</span>,<span class="number">10</span> / n)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;except --&gt; Error: ZeroDivisionError argument.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;else --&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally --&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1、调用：getNum(0)</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">except --&gt; Error: ZeroDivisionError argument.</span></span><br><span class="line"><span class="string">finally --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、调用：getNum(1)</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">try --&gt;  10.0</span></span><br><span class="line"><span class="string">else --&gt;</span></span><br><span class="line"><span class="string">finally --&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，else 子句只能出现在所有 except 子句之后，只有在没有出现异常时执行；finally 子句放在最后，无论是否出现异常都会执行。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>使用 raise 语句允许强制抛出一个指定的异常，要抛出的异常由 raise 的唯一参数标识，它必需是一个异常实例或异常类（继承自 Exception 的类），如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>正常来说，Python 提供的异常类型已经满足我们的使用了,但是有时候我们有定制性的需求，我们可以自定义异常类，继承自 Error 或 Exception 类就可以了，看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自定义异常类 MyExc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExc</span>(<span class="title class_ inherited__">Exception</span>):  <span class="comment">#继承Exception类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;被除数不能为0&#x27;</span></span><br><span class="line"><span class="comment">#自定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            exc = MyExc(n)</span><br><span class="line">            <span class="built_in">print</span>(exc)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1、调用 getNum(1)，输出结果为：</span></span><br><span class="line"><span class="string">10.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、调用 getNum(0)，输出结果为：</span></span><br><span class="line"><span class="string">被除数不能为0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个自定义的异常例子中，当参数 n 不为 0 时，则正常，当 n 等于 0，则抛出异常，自定义异常在实际应用中很少用到，了解即可。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>起初 Python 中并未内置枚举（enum）类型，枚举是在 Python3.4 添加的新功能，此时我们可能会有一个疑问：Python3.4 之前的版本还能不能使用枚举呢？</p><p>答案是可以使用，但是不能直接使用，使用之前需要先用 <code>pip install enum</code> 安装。</p><p><strong>什么是枚举？</strong></p><p>枚举可看作是一系列符号名称的集合，集合中每一个元素要保证唯一性和不可变，因此我们可以对枚举中元素进行恒等比较，通俗来讲枚举就是一系列常量的集合，枚举是可迭代的。</p><p><strong>枚举有什么作用？</strong></p><p>我们先来思考一个问题：不使用枚举我们如何定义常量呢？</p><p>常用的做法是采用变量名大写的方式来定义，这种方式虽然简单，但问题在于我们定义的仍然是变量、是可以被修改的，而常量是什么呢？简单来说就是不可变的量，枚举就有不可变的特性，<strong>所以枚举的主要作用就是用来定义常量的</strong>。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><p>枚举语法与 class 语法相同，面向对象中已经介绍过 class 了，枚举的定义可以通过继承 Enum 的方式来实现， 看一下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeekDay</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Mon = <span class="number">0</span></span><br><span class="line">    Tue = <span class="number">1</span></span><br><span class="line">    Wed = <span class="number">2</span></span><br><span class="line">    Thu = <span class="number">3</span></span><br><span class="line">    Fri = <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>枚举成员及属性的访问如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 枚举成员</span></span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon)</span><br><span class="line"><span class="comment"># 枚举成员名称</span></span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon.name)</span><br><span class="line"><span class="comment"># 枚举成员值</span></span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon.value)</span><br></pre></td></tr></table></figure><p>枚举的迭代也很简单，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式 1</span></span><br><span class="line"><span class="keyword">for</span> day <span class="keyword">in</span> WeekDay:</span><br><span class="line">    <span class="comment"># 枚举成员</span></span><br><span class="line">    <span class="built_in">print</span>(day)</span><br><span class="line">    <span class="comment"># 枚举成员名称</span></span><br><span class="line">    <span class="built_in">print</span>(day.name)</span><br><span class="line">    <span class="comment"># 枚举成员值</span></span><br><span class="line">    <span class="built_in">print</span>(day.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(WeekDay))</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>枚举成员及属性可以使用 is 进行对象比较，还可以使用 == 进行值比较，看下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(WeekDay.Mon <span class="keyword">is</span> WeekDay.Thu)</span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon == WeekDay.Mon)</span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon.name == WeekDay.Mon.name)</span><br><span class="line"><span class="built_in">print</span>(WeekDay.Mon.value == WeekDay.Mon.value)</span><br></pre></td></tr></table></figure><p>枚举成员不能进行大小比较，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>WeekDay.Mon &lt; WeekDay.Thu</span><br><span class="line">TypeError: <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">not</span> supported between instances of <span class="string">&#x27;WeekDay&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;WeekDay&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="确保枚举值唯一"><a href="#确保枚举值唯一" class="headerlink" title="确保枚举值唯一"></a>确保枚举值唯一</h2><p>我们定义枚举时，成员名称是不可以重复的，但成员值是可以重复的，如果想要保证成员值不可重复，可以通过装饰器 <code>@unique</code> 来实现，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeekDay</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">Mon = <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>迭代</strong></p><p>我们知道 Python 中有一些对象可以通过 <code>for</code> 来循环遍历，比如：列表、元组、字符等，以字符串为例，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;Hello&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>可迭代对象</p><p>可迭代对象需具有 <code>__iter__()</code> 方法，它们均可使用 <code>for</code> 循环遍历，我们可以使用 <code>isinstance()</code> 方法来判断一个对象是否为可迭代对象，看下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable))<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, Iterable))<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">1024</span>, Iterable))<span class="comment">#False</span></span><br></pre></td></tr></table></figure><p><strong>迭代器</strong></p><p>迭代器需要具有 <code>__iter__()</code> 和 <code>__next__()</code> 两个方法，这两个方法共同组成了迭代器协议，通俗来讲迭代器就是一个可以记住遍历位置的对象，迭代器一定是可迭代的，反之不成立。</p><ul><li><code>__iter__()</code>：返回迭代器对象本身</li><li><code>__next__()</code>：返回下一项数据</li></ul><p>迭代器对象本质是一个数据流，它通过不断调用 <code>__next__()</code> 方法或被内置的 <code>next()</code> 方法调用返回下一项数据，当没有下一项数据时抛出 <code>StopIteration</code> 异常迭代结束。上面我们说的 <code>for</code> 循环语句的实现便是利用了迭代器。</p><p>我们试着自己来实现一个迭代器，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.s = <span class="string">&#x27;程序之间&#x27;</span></span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.i &lt; <span class="number">4</span>:</span><br><span class="line">            n = self.s[self.i]</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">mi = <span class="built_in">iter</span>(MyIterator())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mi:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是用来创建迭代器的工具，其写法与标准函数类似，不同之处在于返回时使用 yield 语句，我们再来熟悉一下：</p><blockquote><p>yield 是一个关键字，作用和 return 差不多，差别在于 yield 返回的是一个生成器（在 Python 中，一边循环一边计算的机制，称为生成器），它的作用是：有利于减小服务器资源，在列表中所有数据存入内存，而生成器相当于一种方法而不是具体的信息，用多少取多少，占用内存小。</p></blockquote><p>生成器的创建方式有很多种，比如：使用 <code>yield</code> 语句、生成器表达式（可以简单的理解为是将列表的 <code>[]</code> 换成了 <code>()</code>，特点是更加简洁，但不够灵活）。看下示例：</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#生成len(data)-1，len(data)-2，len(data)-3......0 左闭右开</span></span><br><span class="line">        <span class="keyword">yield</span> data[i]<span class="comment">#返回data[i]</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">&#x27;Hello&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"><span class="comment">#range(start,stop,step) 开始位置,结束位置,步长</span></span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">lis = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line">gen = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> g <span class="keyword">in</span> gen:</span><br><span class="line">    <span class="built_in">print</span>(g)</span><br></pre></td></tr></table></figure><h1 id="装饰器-详解"><a href="#装饰器-详解" class="headerlink" title="装饰器(详解)"></a>装饰器(详解)</h1><p>首先我们来了解下闭包，什么是闭包呢？看一下维基百科给出的解析：</p><blockquote><p>闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p>看了上面的解释，你可能已经懂了，也可能还是有点懵 B。不过都没关系，我们再以 Python 为例更通俗的解释一下：比如我们调用一个带有返回值的函数 x，此时函数 x 为我们返回一个函数 y，这个函数 y 就被称作闭包，这么一说是不是豁然开朗了。需要注意一点就是闭包并不是 Python 特有的，很多语言都有闭包的概念。具体示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">x</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">id</span>, <span class="string">&#x27;name:&#x27;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">y = x(<span class="string">&#x27;ityard&#x27;</span>)</span><br><span class="line">y(<span class="string">&#x27;程序之间&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们会发现闭包与类有一些相似，比如：它们都能实现数据的封装、方法的复用等；此外，通过使用闭包可以避免使用全局变量，还能将函数与其所操作的数据关连起来。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p> 装饰器本质上是一个Python函数(其实就是闭包)，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。</p><p>装饰器可以基于函数实现也可基于类实现，其使用方式基本是固定的，看一下基本步骤：</p><ul><li>定义装饰函数（类）</li><li>定义业务函数</li><li>在业务函数上添加 <code>@装饰函数（类）名</code></li></ul><p>下面请看具体示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给函数加上装饰器一般的写法</span></span><br><span class="line"><span class="comment"># 为函数添加一个统计运行时长的功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">how_much_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        t_end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;一共花费了&#123;0&#125;秒时间&quot;</span>.<span class="built_in">format</span>(t_end - t_start, ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">    <span class="comment"># 将增加的新功能代码以及被装饰函数运行代码func()一同打包返回，返回的是一个内部函数，这个被返回的函数就是装饰器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_5s</span>():</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d秒结束了&quot;</span> % (<span class="number">5</span>,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_6s</span>():</span><br><span class="line">    time.sleep(<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d秒结束了&quot;</span> % (<span class="number">6</span>,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep_5s = how_much_time(sleep_5s)</span><br><span class="line"><span class="comment"># 因为sleep_5s函数的功能就是睡5秒钟，虽然增加了统计运行时间的功能，但是他本身功能没变(还是睡5秒钟)，所以仍然用原来函数名接收增加功能了的自己</span></span><br><span class="line">sleep_6s = how_much_time(sleep_6s)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=sleep_5s)</span><br><span class="line">t2 = threading.Thread(target=sleep_6s)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"><span class="comment"># 5秒结束了</span></span><br><span class="line"><span class="comment"># 一共花费了5.014161109924316秒时间</span></span><br><span class="line"><span class="comment"># 6秒结束了</span></span><br><span class="line"><span class="comment"># 一共花费了6.011810302734375秒时间</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#标准语法糖写法</span></span><br><span class="line"><span class="comment"># 为函数添加一个统计运行时长的功能以及日志记录功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">how_much_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;how_much_time函数开始了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        t_end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;一共花费了&#123;0&#125;秒时间&quot;</span>.<span class="built_in">format</span>(t_end - t_start, ))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mylog</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;mylog函数开始了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_1</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_1</span><br><span class="line"> </span><br><span class="line"><span class="meta">@mylog</span></span><br><span class="line"><span class="meta">@how_much_time</span></span><br><span class="line"><span class="comment"># 等价于mylog(how_much_time(sleep_5s))</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_5s</span>():</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d秒结束了&quot;</span> % (<span class="number">5</span>,))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sleep_5s()</span><br><span class="line"><span class="comment">#how_much_time函数开始了</span></span><br><span class="line"><span class="comment">#mylog函数开始了</span></span><br><span class="line"><span class="comment">#start</span></span><br><span class="line"><span class="comment">#5秒结束了</span></span><br><span class="line"><span class="comment">#一共花费了5.012601613998413秒时间</span></span><br><span class="line"><span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>Python 中还支持多个装饰器同时使用，使用方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为函数添加一个统计运行时长的功能以及日志记录功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> <span class="comment">#执行顺序为：</span></span><br><span class="line">    <span class="comment">#1.how_much_time  print(&quot;mylog函数开始了&quot;)</span></span><br><span class="line">    <span class="comment">#2.mylog  print(&quot;how_much_time函数开始了&quot;)</span></span><br><span class="line">    <span class="comment">#3.how_much_time  def inner()</span></span><br><span class="line">    <span class="comment">#4.mylog def inner_1()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">how_much_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;how_much_time函数开始了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        t_end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;一共花费了&#123;0&#125;秒时间&quot;</span>.<span class="built_in">format</span>(t_end - t_start, ))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mylog</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;mylog函数开始了&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_1</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_1</span><br><span class="line"> </span><br><span class="line"><span class="meta">@mylog</span></span><br><span class="line"><span class="meta">@how_much_time</span></span><br><span class="line"><span class="comment"># 等价于mylog(how_much_time(sleep_5s))</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_5s</span>():</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d秒结束了&quot;</span> % (<span class="number">5</span>,))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sleep_5s()</span><br><span class="line"><span class="comment">#how_much_time函数开始了</span></span><br><span class="line"><span class="comment">#mylog函数开始了</span></span><br><span class="line"><span class="comment">#start</span></span><br><span class="line"><span class="comment">#5秒结束了</span></span><br><span class="line"><span class="comment">#一共花费了5.012601613998413秒时间</span></span><br><span class="line"><span class="comment">#end</span></span><br></pre></td></tr></table></figure><p><strong>python带参数的装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myblog</span>(<span class="params"><span class="built_in">type</span></span>)：</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>==<span class="string">&#x27;文件&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>：</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;控制台&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">      <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于类"><a href="#基于类" class="headerlink" title="基于类"></a>基于类</h2><p>装饰器除了基于函数实现，还可以基于类实现，看下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数名是 %s &#x27;</span> % func.__name__)</span><br><span class="line">        self.__func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.__func()</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello ...&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><h1 id="python语法糖"><a href="#python语法糖" class="headerlink" title="python语法糖"></a>python语法糖</h1>]]></content>
    
    
    <summary type="html">Python</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据挖掘</title>
    <link href="http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</id>
    <published>2022-10-21T08:00:00.000Z</published>
    <updated>2022-10-21T08:09:38.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是数据挖掘？"><a href="#什么是数据挖掘？" class="headerlink" title="什么是数据挖掘？"></a>什么是数据挖掘？</h1><p>数据挖掘（英语：data mining）是一个跨学科的计算机科学分支 。它是用人工智能、机器学习、统计学和数据库的交叉方法在相对较大型的数据集中发现模式的计算过程。</p><p>数据挖掘过程的总体目标是从一个数据集中提取信息，并将其转换成可理解的结构，以进一步使用。除了原始分析步骤，它还涉及到数据库和数据管理方面、数据预处理、模型与推断方面考量、兴趣度度量、复杂度的考虑，以及发现结构、可视化及在线更新等后处理。数据挖掘是“数据库知识发现”（Knowledge-Discovery in Databases, KDD）的分析步骤，本质上属于机器学习的范畴。</p><p>数据挖掘有以下这些不同的定义：</p><ol><li>从资料中提取出隐含的过去未知的有价值的潜在信息</li><li>一门从大量资料或数据库中提取有用信息的科学</li></ol><h1 id="数据挖掘解决的问题"><a href="#数据挖掘解决的问题" class="headerlink" title="数据挖掘解决的问题"></a>数据挖掘解决的问题</h1><h2 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h2><p>聚类问题不属于预测性的问题，它主要解决的是把一群对象划分成若干个组的问题。划分的依据是聚类问题的核心。所谓“物以类聚，人以群分”，故得名聚类。</p><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>分类问题属于预测性的问题，但是它跟普通预测问题的区别在于其预测的结果是类别（如 A、B、C 三类）而不是一个具体的数值（如 55、65、75……）。</p><p>举个例子，你和朋友在路上走着，迎面走来一个人，你对朋友说：我猜这个人是个上海人，那么这个问题就属于分类问题；如果你对朋友说：我猜这个人的年龄在 30 岁左右，那么这个问题就属于后面要说到的预测问题。</p><h2 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h2><p>此处说的预测问题指的是狭义的预测，并不包含前面阐述的分类问题，因为分类问题也属于预测。一般来说我们谈预测问题主要指预测变量的取值为连续数值型的情况（也就是回归问题）。</p><h2 id="关联问题"><a href="#关联问题" class="headerlink" title="关联问题"></a>关联问题</h2><p>关联问题最常见的一个场景就是推荐，比如，你在京东或者淘宝购物的时候，在选中一个商品之后，往往会给你推荐几种其他商品组合，这种功能就可以使用关联挖掘来实现。</p><h1 id="数据挖掘常用的方法"><a href="#数据挖掘常用的方法" class="headerlink" title="数据挖掘常用的方法"></a>数据挖掘常用的方法</h1><p><strong>分类</strong></p><p>分类是找出<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>中一组数据对象的共同特点并按照分类模式将其划分为不同的类，其目的是通过分类模型，将数据库中的数据项映射到某个给定的类别。</p><p>它可以应用到客户的分类、客户的属性和特征分析、客户满意度分析、客户的购买趋势预测等，如一个汽车零售商将客户按照对汽车的喜好划分成不同的类，这样营销人员就可以将新型汽车的广告手册直接邮寄到有这种喜好的客户手中，从而大大增加了商业机会。</p><p><strong>回归分析</strong></p><p>回归分析方法反映的是事务数据库中属性值在时间上的特征，产生一个将数据项映射到一个实值预测变量的函数，发现变量或属性间的依赖关系，其主要研究问题包括数据序列的趋势特征、数据序列的预测以及数据间的相关关系等。</p><p>它可以应用到市场营销的各个方面，如客户寻求、保持和预防客户流失活动、产品生命周期分析、销售趋势预测及有针对性的促销活动等。</p><p><strong>聚类</strong></p><p>聚类分析是把一组数据按照相似性和差异性分为几个类别，其目的是使得属于同一类别的数据间的相似性尽可能大，不同类别中的数据间的相似性尽可能小。</p><p>它可以应用到客户群体的分类、客户背景分析、客户购买趋势预测、市场的细分等。</p><p><strong>关联规则</strong></p><p>关联规则是描述数据库中数据项之间所存在的关系的规则，即根据一个事务中某些项的出现可导出另一些项在同一事务中也出现，即隐藏在数据间的关联或相互关系。</p><p>在客户关系管理中，通过对企业的客户数据库里的大量数据进行挖掘，可以从大量的记录中发现有趣的关联关系，找出影响市场营销效果的关键因素，为产品定位、定价与定制客户群，客户寻求、细分与保持，市场营销与推销，营销风险评估和诈骗预测等决策支持提供参考依据。</p><p><strong>特征分析</strong></p><p>特征分析是从数据库中的一组数据中提取出关于这些数据的特征式，这些特征式表达了该数据集的总体特征。如营销人员通过对客户流失因素的特征提取，可以得到导致客户流失的一系列原因和主要特征，利用这些特征可以有效地预防客户的流失。</p><p><strong>变化和偏差分析</strong></p><p>偏差包括很大一类潜在有趣的知识，如分类中的反常实例，模式的例外，观察结果对期望的偏差等，其目的是寻找观察结果与参照量之间有意义的差别。在企业危机管理及其预警中，管理者更感兴趣的是那些意外规则。意外规则的挖掘可以应用到各种异常信息的发现、分析、识别、评价和预警等方面。</p><p><strong>Web页挖掘</strong></p><p>随着Internet的迅速发展及Web 的全球普及， 使得Web上的信息量无比丰富，通过对Web的挖掘，可以利用Web 的海量数据进行分析，收集政治、经济、政策、科技、金融、各种市场、竞争对手、供求信息、客户等有关的信息，集中精力分析和处理那些对企业有重大或潜在重大影响的外部环境信息和内部经营信息，并根据分析结果找出企业管理过程中出现的各种问题和可能引起危机的先兆，对这些信息进行分析和处理，以便识别、分析、评价和管理危机。</p><h1 id="数据挖掘过程"><a href="#数据挖掘过程" class="headerlink" title="数据挖掘过程"></a>数据挖掘过程</h1><p>数据挖掘(data mining)又译为资料探勘、数据采矿，是指从大量的、不完全的、有噪声的、模糊的、随机的数据中提取隐含在其中的、人们事先不知道的但又潜在有用的信息和知识的过程。</p><p>数据挖掘的具体过程描述如下：</p><ul><li>数据：进行数据挖掘首先要有数据，可以根据任务的目的选择数据集，并筛选自己需要的数据，或者根据实际情况构造自己需要的数据。</li><li>预处理：确定数据集后，就要对数据进行预处理，使数据能够为我们所用。数据预处理可以提高数据质量，包括准确性、完整性和一致性。进行数据预处理的方法有数据清理、数据集成、数据规约和数据变换等。</li><li>变换：进行数据预处理后，对数据进行变换，将数据转换成一个分析模型，这个分析模型是针对数据挖掘算法建立的。建立一个真正适合数据挖掘算法的分析模型是数据挖掘成功的关键。</li><li>数据挖掘：对经过转换的数据进行挖掘，除了选择合适的挖掘算法外，其余一切工作都能自动地完成。</li><li>解释/评估：解释并评估结果，最终得到知识。其使用的分析方法一般视数据挖掘操作而定，通常会用到可视化技术。</li></ul><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160914.png?raw=true" alt="blog_images20221021160914.png"></p>]]></content>
    
    
    <summary type="html">数据挖掘</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据可视化</title>
    <link href="http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2022-10-21T07:00:00.000Z</published>
    <updated>2022-10-21T08:07:39.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib-是什么"><a href="#Matplotlib-是什么" class="headerlink" title="Matplotlib 是什么"></a>Matplotlib 是什么</h1><p>Matplotlib 是一款用于数据可视化的 Python 软件包，支持跨平台运行，它能够根据 NumPy ndarray 数组来绘制 2D 图像，它使用简单、代码清晰易懂，深受广大技术爱好者喜爱。</p><p>这里推荐 matplotlib 文档学习网站</p><p><strong>工具包</strong></p><p>Matplotlib 附带了几个附加工具包 (opens new window)， 包括 3d 绘图工具 mplot3d， 轴辅助工具 axes_grid1 和轴辅助工具 axisartist。</p><p><strong>第三方包</strong></p><p>大量的第三方软件包 (opens new window)扩展并建立在 Matplotlib 功能的基础上，包括几个更高级别的绘图界面（seaborn (opens new window)， holoviews (opens new window)， ggplot (opens new window)，…）以及两个投影和制图工具包（basemap (opens new window)和 cartopy (opens new window)）</p><h1 id="下载-matplotlib"><a href="#下载-matplotlib" class="headerlink" title="下载 matplotlib"></a>下载 matplotlib</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install matplotlib #conda下载</span><br><span class="line">pip install matplotlib #pip下载</span><br></pre></td></tr></table></figure><h1 id="认识-Matploblib"><a href="#认识-Matploblib" class="headerlink" title="认识 Matploblib"></a>认识 Matploblib</h1><p>Matplotlib 生成的图形主要由以下几个部分构成：</p><ul><li>Figure：指整个图形，您可以把它理解成一张画布，它包括了所有的元素，比如标题、轴线等；</li><li>Axes：绘制 2D 图像的实际区域，也称为轴域区，或者绘图区；</li><li>Axis：指坐标系中的垂直轴与水平轴，包含轴的长度大小（图中轴长为 7）、轴标签（指 x 轴，y 轴）和刻度标签；</li><li>Artist：您在画布上看到的所有元素都属于 Artist 对象，比如文本对象（title、xlabel、ylabel）、Line2D 对象（用于绘制 2D 图像）等。</li></ul><h2 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h2><p>在任何绘图之前，我们需要一个 Figure 对象，可以理解成我们需要一张画板才能开始绘图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><p>figure 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">figure(num=<span class="literal">None</span>,  <span class="comment"># autoincrement if None, else integer from 1-N</span></span><br><span class="line">           figsize=<span class="literal">None</span>,  <span class="comment"># defaults to rc figure.figsize</span></span><br><span class="line">           dpi=<span class="literal">None</span>,  <span class="comment"># defaults to rc figure.dpi</span></span><br><span class="line">           facecolor=<span class="literal">None</span>,  <span class="comment"># defaults to rc figure.facecolor</span></span><br><span class="line">           edgecolor=<span class="literal">None</span>,  <span class="comment"># defaults to rc figure.edgecolor</span></span><br><span class="line">           frameon=<span class="literal">True</span>,</span><br><span class="line">           FigureClass=Figure,</span><br><span class="line">           clear=<span class="literal">False</span>,</span><br><span class="line">           **kwargs</span><br><span class="line">           ):</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>figsize</td><td>指定画布的大小，(宽度,高度)，单位为英寸。</td></tr><tr><td>dpi</td><td>指定绘图对象的分辨率，即每英寸多少个像素，默认值为 80。</td></tr><tr><td>facecolor</td><td>背景颜色。</td></tr><tr><td>dgecolor</td><td>边框颜色。</td></tr><tr><td>frameon</td><td>是否显示边框。</td></tr></tbody></table><h2 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a>Axes</h2><p>在拥有 Figure 对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加 Axes。也可以理解成为真正可以作画的纸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=[<span class="number">0.5</span>, <span class="number">4.5</span>], ylim=[-<span class="number">2</span>, <span class="number">8</span>], title=<span class="string">&#x27;An Example Axes&#x27;</span>,</span><br><span class="line">       ylabel=<span class="string">&#x27;Y-Axis&#x27;</span>, xlabel=<span class="string">&#x27;X-Axis&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesimage-20221020212335502.png?raw=true" alt="blog_imagesimage-20221020212335502.png"></p><p>对于上面的 fig.add_subplot(111)就是添加 Axes 的，参数的解释的在画板的第 1 行第 1 列的第一个位置生成一个 Axes 对象来准备作画。也可以通过 fig.add_subplot(2, 2, 1)的方式生成 Axes，前面两个参数确定了面板的划分，例如 2， 2 会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个 Axes。如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021111542.png?raw=true" alt="blog_images20221021111542.png"></p><h2 id="Multiple-Axes"><a href="#Multiple-Axes" class="headerlink" title="Multiple Axes"></a>Multiple Axes</h2><p>可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。</p><p>subplots 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subplot(nrows,ncols,sharex,sharey,subplot_kw,**fig_kw)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>nrows</td><td>行数</td></tr><tr><td>ncols</td><td>列数</td></tr><tr><td>sharex</td><td>所有 subplot 的 x 轴刻度</td></tr><tr><td>sharey</td><td>所有 subplot 的 y 轴刻度</td></tr><tr><td>subplot_kw</td><td>用户创建各个 subplot 的关键字字典</td></tr><tr><td>**fig_kw</td><td>其他关键字如 figsize</td></tr></tbody></table><h2 id="Matplotlib-subplot2grid"><a href="#Matplotlib-subplot2grid" class="headerlink" title="Matplotlib subplot2grid"></a>Matplotlib subplot2grid</h2><p><code>matplotlib.pyplot</code> 模块提供了 subplot2grid() ，该函数能够在画布的特定位置创建 axes 对象（即绘图区域）。不仅如此，它还可以使用不同数量的行、列来创建跨度不同的绘图区域。与 subplot() 和 subplots() 函数不同，subplot2gird() 函数以非等分的形式对画布进行切分，并按照绘图区域的大小来展示最终绘图结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot2grid(shape, location, rowspan, colspan)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>shape：把该参数值规定的网格区域作为绘图区域；</li><li>location：在给定的位置绘制图形，初始位置 (0,0) 表示第 1 行第 1 列；</li><li>rowsapan/colspan：这两个参数用来设置让子区跨越几行几列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#使用 colspan指定列，使用rowspan指定行</span></span><br><span class="line">a1 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>),colspan = <span class="number">2</span>)</span><br><span class="line">a2 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">2</span>), rowspan = <span class="number">3</span>)</span><br><span class="line">a3 = plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),rowspan = <span class="number">2</span>, colspan = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">a2.plot(x, x*x)</span><br><span class="line">a2.set_title(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line">a1.plot(x, np.exp(x))</span><br><span class="line">a1.set_title(<span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line">a3.plot(x, np.log(x))</span><br><span class="line">a3.set_title(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021132324.png?raw=true" alt="blog_images20221021132324.png"></p><h2 id="Axes-Vs-pyplot"><a href="#Axes-Vs-pyplot" class="headerlink" title="Axes Vs .pyplot"></a>Axes Vs .pyplot</h2><p>相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], color=<span class="string">&#x27;lightblue&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">plt.show()<span class="comment">#总结pyplot只适合快速作图而axes适合复杂作图</span></span><br></pre></td></tr></table></figure><h2 id="解决-matplotlib-常见问题"><a href="#解决-matplotlib-常见问题" class="headerlink" title="解决 matplotlib 常见问题"></a>解决 matplotlib 常见问题</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021124926.png?raw=true" alt="blog_images20221021124926.png"></p><p>原本要输出的中文变成了方框。<br><strong>原因是 matplotlib 是由外国人写的，不支持中文显示</strong></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在代码中加入这两行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决中文问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment"># 用来正常显示负号</span></span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font = FontProperties(fname=<span class="string">r&quot;c:\windows\fonts\simsun.ttc&quot;</span>, size=<span class="number">14</span>)<span class="comment">#设置汉字格式</span></span><br><span class="line">axs0_ylabel_text = axs[<span class="number">0</span>][<span class="number">0</span>].set_ylabel(<span class="string">u&#x27;玩视频游戏所消耗时间占&#x27;</span>, fontproperties=font)<span class="comment">#在需要显示中文的坐标或者标签上传入font字体</span></span><br></pre></td></tr></table></figure><h2 id="Matplotlib-pyplot-接口汇总"><a href="#Matplotlib-pyplot-接口汇总" class="headerlink" title="Matplotlib.pyplot 接口汇总"></a>Matplotlib.pyplot 接口汇总</h2><p><strong>绘图类型</strong></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Bar</td><td>绘制条形图</td></tr><tr><td>Barh</td><td>绘制水平条形图</td></tr><tr><td>Boxplot</td><td>绘制箱型图</td></tr><tr><td>Hist</td><td>绘制直方图</td></tr><tr><td>his2d</td><td>绘制 2D 直方图</td></tr><tr><td>Pie</td><td>绘制饼状图</td></tr><tr><td>Plot</td><td>在坐标轴上画线或者标记</td></tr><tr><td>Polar</td><td>绘制极坐标图</td></tr><tr><td>Scatter</td><td>绘制 x 与 y 的散点图</td></tr><tr><td>Stackplot</td><td>绘制堆叠图</td></tr><tr><td>Stem</td><td>用来绘制二维离散数据绘制（又称为“火柴图”）</td></tr><tr><td>Step</td><td>绘制阶梯图</td></tr><tr><td>Quiver</td><td>绘制一个二维按箭头</td></tr></tbody></table><p><strong>image 函数</strong></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Imread</td><td>从文件中读取图像的数据并形成数组。</td></tr><tr><td>Imsave</td><td>将数组另存为图像文件。</td></tr><tr><td>Imshow</td><td>在数轴区域内显示图像。</td></tr></tbody></table><p><strong>Axis</strong></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Axes</td><td>在画布(Figure)中添加轴</td></tr><tr><td>Text</td><td>向轴添加文本</td></tr><tr><td>Title</td><td>设置当前轴的标题</td></tr><tr><td>Xlabel</td><td>设置 x 轴标签</td></tr><tr><td>Xlim</td><td>获取或者设置 x 轴区间大小</td></tr><tr><td>Xscale</td><td>设置 x 轴缩放比例</td></tr><tr><td>Xticks</td><td>获取或设置 x 轴刻标和相应标签</td></tr><tr><td>Ylabel</td><td>设置 y 轴的标签</td></tr><tr><td>Ylim</td><td>获取或设置 y 轴的区间大小</td></tr><tr><td>Yscale</td><td>设置 y 轴的缩放比例</td></tr><tr><td>Yticks</td><td>获取或设置 y 轴的刻标和相应标签</td></tr></tbody></table><p>Figure 函数</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Figtext</td><td>在画布上添加文本</td></tr><tr><td>Figure</td><td>创建一个新画布</td></tr><tr><td>Show</td><td>显示数字</td></tr><tr><td>Savefig</td><td>保存当前画布</td></tr><tr><td>Close</td><td>关闭画布窗口</td></tr></tbody></table><h1 id="基本绘图-2D"><a href="#基本绘图-2D" class="headerlink" title="基本绘图 2D"></a>基本绘图 2D</h1><p>Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图 API。</p><p>Pyplot 是常用的绘图模块，能很方便让用户绘制 2D 图表。</p><p>Pyplot 包含一系列绘图函数的相关函数，每个函数会对当前的图像进行一些修改，例如：给图像加上标记，生新的图像，在图像中产生新的绘图区域等等。</p><h2 id="matplotlib-基本设置"><a href="#matplotlib-基本设置" class="headerlink" title="matplotlib 基本设置"></a>matplotlib 基本设置</h2><h3 id="Matplotlib-grid-设置网格格式"><a href="#Matplotlib-grid-设置网格格式" class="headerlink" title="Matplotlib grid()设置网格格式"></a>Matplotlib grid()设置网格格式</h3><p>通过 Matplotlib axes 对象提供的 grid() 方法可以开启或者关闭画布中的网格（即是否显示网格）以及网格的主/次刻度。除此之外，grid() 函数还可以设置网格的颜色、线型以及线宽等属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid(color=<span class="string">&#x27;b&#x27;</span>, ls = <span class="string">&#x27;-.&#x27;</span>, lw = <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>color：表示网格线的颜色；</li><li>ls：表示网格线的样式；</li><li>lw：表示网格线的宽度；</li></ul><p>网格在默认状态下是关闭的，通过调用上述函数，网格会被自动开启，如果您只是想开启不带任何样式的网格，可以通过 grid(True) 来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#fig画布；axes子图区域</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>,<span class="number">3</span>, figsize = (<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">11</span>)</span><br><span class="line">axes[<span class="number">0</span>].plot(x, x**<span class="number">3</span>, <span class="string">&#x27;g&#x27;</span>,lw=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#开启网格</span></span><br><span class="line">axes[<span class="number">0</span>].grid(<span class="literal">True</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&#x27;default grid&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>].plot(x, np.exp(x), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment">#设置网格的颜色，线型，线宽</span></span><br><span class="line">axes[<span class="number">1</span>].grid(color=<span class="string">&#x27;b&#x27;</span>, ls = <span class="string">&#x27;-.&#x27;</span>, lw = <span class="number">0.25</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&#x27;custom grid&#x27;</span>)</span><br><span class="line">axes[<span class="number">2</span>].plot(x,x)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&#x27;no grid&#x27;</span>)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021154922.png?raw=true" alt="blog_images20221021154922.png"></p><h3 id="Matplotlib-坐标轴格式"><a href="#Matplotlib-坐标轴格式" class="headerlink" title="Matplotlib 坐标轴格式"></a>Matplotlib 坐标轴格式</h3><p>在一个函数图像中，有时自变量 x 与因变量 y 是指数对应关系，这时需要将坐标轴刻度设置为对数刻度。Matplotlib 通过 axes 对象的<code>xscale</code>或<code>yscale</code>属性来实现对坐标轴的格式设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">axes[<span class="number">0</span>].plot( x, np.exp(x))</span><br><span class="line">axes[<span class="number">0</span>].plot(x,x**<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;Normal scale&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].plot (x, np.exp(x))</span><br><span class="line">axes[<span class="number">1</span>].plot(x, x**<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_yscale(<span class="string">&quot;log&quot;</span>)<span class="comment">#设置y轴刻度为对数关系</span></span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;Logarithmic scale (y)&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_xlabel(<span class="string">&quot;x axis&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_ylabel(<span class="string">&quot;y axis&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].xaxis.labelpad = <span class="number">10</span></span><br><span class="line"><span class="comment">#设置x、y轴标签</span></span><br><span class="line">axes[<span class="number">1</span>].set_xlabel(<span class="string">&quot;x axis&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_ylabel(<span class="string">&quot;y axis&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155106.png?raw=true" alt="blog_images20221021155106.png"></p><h3 id="Matplotlib-坐标轴范围"><a href="#Matplotlib-坐标轴范围" class="headerlink" title="Matplotlib 坐标轴范围"></a>Matplotlib 坐标轴范围</h3><p>Matplotlib 可以根据自变量与因变量的取值范围，自动设置 x 轴与 y 轴的数值大小。当然，您也可以用自定义的方式，通过 set_xlim() 和 set_ylim() 对 x、y 轴的数值范围进行设置。当对 3D 图像进行设置的时，会增加一个 z 轴，此时使用 set_zlim() 可以对 z 轴进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">a1 = fig.add_axes([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">a1.plot(x, np.exp(x),<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">a1.set_title(<span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line"><span class="comment">#设置y轴</span></span><br><span class="line">a1.set_ylim(<span class="number">0</span>,<span class="number">10000</span>)<span class="comment">#自定义y轴刻度</span></span><br><span class="line"><span class="comment">#设置x轴</span></span><br><span class="line">a1.set_xlim(<span class="number">0</span>,<span class="number">10</span>)<span class="comment">#自定义x轴刻度</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155413.png?raw=true" alt="blog_images20221021155413.png"></p><h3 id="Matplotlib-刻度和刻度标签"><a href="#Matplotlib-刻度和刻度标签" class="headerlink" title="Matplotlib 刻度和刻度标签"></a>Matplotlib 刻度和刻度标签</h3><p>xticks() 和 yticks() 函数接受一个列表对象作为参数，列表中的元素表示对应数轴上要显示的刻度。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xticks([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>x 轴上的刻度标记，依次为 2，4，6，8，10。您也可以分别通过 set_xticklabels() 和 set_yticklabels() 函数设置与刻度线相对应的刻度标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line"><span class="comment">#生成画布对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment">#添加绘图区域</span></span><br><span class="line">ax = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span>])</span><br><span class="line">y = np.sin(x)</span><br><span class="line">ax.plot(x, y)</span><br><span class="line"><span class="comment">#设置x轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;angle&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;sine&#x27;</span>)</span><br><span class="line">ax.set_xticks([<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment">#设置x轴刻度标签</span></span><br><span class="line">ax.set_xticklabels([<span class="string">&#x27;zero&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;four&#x27;</span>,<span class="string">&#x27;six&#x27;</span>])</span><br><span class="line"><span class="comment">#设置y轴刻度</span></span><br><span class="line">ax.set_yticks([-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155514.png?raw=true" alt="blog_images20221021155514.png"></p><h3 id="matplotlib-增加图例"><a href="#matplotlib-增加图例" class="headerlink" title="matplotlib 增加图例"></a>matplotlib 增加图例</h3><p>直接看效果图</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021144413.png?raw=true" alt="blog_images20221021144413.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br></pre></td></tr></table></figure><p>plt.legend(loc=”upper left”) 左上角的周活</p><ul><li>best （自动找一个最好的位置，但有时不符合我们的预期）</li><li>upper right（右上角）</li><li>upper left （左上角）</li><li>lower left （左下角）</li><li>lower right （右下角）</li><li>right （右，和 center right 位置一样）</li><li>center left （中间偏左）</li><li>center right （中间偏右）</li><li>lower center（中间偏下）</li><li>upper center（中间偏上）</li><li>center（正中间）</li></ul><h2 id="matplotlib2D-绘图"><a href="#matplotlib2D-绘图" class="headerlink" title="matplotlib2D 绘图"></a>matplotlib2D 绘图</h2><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><p>plt.plot()函数可以画各种线图，比如曲线图,折线图和直线图，具体根据你传入的点进行绘画</p><p>函数原型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(self, xs, ys, zs, zdir=<span class="string">&#x27;z&#x27;</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>xs：x 轴坐标</li><li>ys：y 轴坐标</li><li>zs：z 轴坐标我们画 2D 图一般用不到</li><li>zdir：方向（默认值就好不要动）</li><li>**kwargs： kwargs 其他参数被转发到<code>matplotlib.axes.Axes.plot</code></li></ul><h4 id="画折线图："><a href="#画折线图：" class="headerlink" title="画折线图："></a>画折线图：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> @Time : 2022/10/21 13:17</span></span><br><span class="line"><span class="string"> @Author : liao.sc</span></span><br><span class="line"><span class="string"> @File : demo10</span></span><br><span class="line"><span class="string"> @Contact : 446773160@qq.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 解决中文问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment"># 用来正常显示负号</span></span><br><span class="line"><span class="comment"># 准备绘制数据</span></span><br><span class="line">x = [<span class="string">&quot;Mon&quot;</span>, <span class="string">&quot;Tues&quot;</span>, <span class="string">&quot;Wed&quot;</span>, <span class="string">&quot;Thur&quot;</span>, <span class="string">&quot;Fri&quot;</span>, <span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>]</span><br><span class="line">y = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">42</span>, <span class="number">80</span>, <span class="number">50</span>]</span><br><span class="line"><span class="comment"># &quot;g&quot; 表示红色，marksize用来设置&#x27;D&#x27;菱形的大小</span></span><br><span class="line">plt.plot(x, y, <span class="string">&quot;g&quot;</span>, marker=<span class="string">&#x27;D&#x27;</span>, markersize=<span class="number">5</span>, label=<span class="string">&quot;周活&quot;</span>,color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="comment"># 绘制坐标轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;登录时间&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;用户活跃度&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;山不让尘,川不辞盈博客活跃度&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图例 左上角显示</span></span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line"><span class="comment"># 调用 text()在图像上绘制注释文本</span></span><br><span class="line"><span class="comment"># x1、y1表示文本所处坐标位置，ha参数控制水平对齐方式, va控制垂直对齐方式，str(y1)表示要绘制的文本</span></span><br><span class="line"><span class="keyword">for</span> x1, y1 <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):</span><br><span class="line">    plt.text(x1, y1, <span class="built_in">str</span>(y1), ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021140426.png?raw=true" alt="blog_images20221021140426.png"></p><h4 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> @Time : 2022/10/21 13:17</span></span><br><span class="line"><span class="string"> @Author : liao.sc</span></span><br><span class="line"><span class="string"> @File : demo10</span></span><br><span class="line"><span class="string"> @Contact : 446773160@qq.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span>  np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, np.pi)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br><span class="line">ax1.plot(x, y_sin)</span><br><span class="line">ax2.plot(x, y_sin, <span class="string">&#x27;go--&#x27;</span>, linewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line">ax3.plot(x, y_cos, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021141045.png?raw=true" alt="blog_images20221021141045.png"></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图用于在水平轴和垂直轴上绘制数据点，它表示了因变量随自变量变化的趋势。通俗地讲，它反映的是一个变量受另一个变量的影响程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> @Time : 2022/10/21 13:17</span></span><br><span class="line"><span class="string"> @Author : liao.sc</span></span><br><span class="line"><span class="string"> @File : demo10</span></span><br><span class="line"><span class="string"> @Contact : 446773160@qq.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">girls_grades = [<span class="number">89</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">89</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">34</span>]</span><br><span class="line">boys_grades = [<span class="number">30</span>, <span class="number">29</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">100</span>, <span class="number">48</span>, <span class="number">38</span>, <span class="number">45</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">grades_range = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>]</span><br><span class="line">fig=plt.figure()</span><br><span class="line"><span class="comment">#添加绘图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.scatter(grades_range, girls_grades, color=<span class="string">&#x27;r&#x27;</span>,label=<span class="string">&quot;girls&quot;</span>)</span><br><span class="line">ax.scatter(grades_range, boys_grades, color=<span class="string">&#x27;b&#x27;</span>,label=<span class="string">&quot;boys&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Grades Range&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Grades Scored&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;scatter plot&#x27;</span>)</span><br><span class="line"><span class="comment">#添加图例</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021142150.png?raw=true" alt="blog_images20221021142150.png"></p><h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>柱状图是一种用矩形柱来表示数据分类的图表，柱状图可以垂直绘制，也可以水平绘制，它的高度与其所表示的数值成正比关系。柱状图显示了不同类别之间的比较关系，图表的水平轴 X 指定被比较的类别，垂直轴 Y 则表示具体的类别值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.bar(x, height, width, bottom, align)</span><br></pre></td></tr></table></figure><table><thead><tr><th>x</th><th>一个标量序列，代表柱状图的 x 坐标，默认 x 取值是每个柱状图所在的中点位置，或者也可以是柱状图左侧边缘位置。</th></tr></thead><tbody><tr><td>height</td><td>一个标量或者是标量序列，代表柱状图的高度。</td></tr><tr><td>width</td><td>可选参数，标量或类数组，柱状图的默认宽度值为 0.8。</td></tr><tr><td>bottom</td><td>可选参数，标量或类数组，柱状图的 y 坐标默认为 None。</td></tr><tr><td>algin</td><td>有两个可选项 {“center”,”edge”}，默认为 ‘center’，该参数决定 x 值位于柱状图的位置。</td></tr></tbody></table><p>下面是一个关于 Matplotlib 柱状图的简单示例。它用来显示了不同编程语言的学习人数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#创建图形对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment">#添加子图区域，参数值表示[left, bottom, width, height ]</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment">#准备数据</span></span><br><span class="line">langs = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>]</span><br><span class="line">students = [<span class="number">23</span>,<span class="number">17</span>,<span class="number">35</span>,<span class="number">29</span>,<span class="number">12</span>]</span><br><span class="line"><span class="comment">#绘制柱状图</span></span><br><span class="line">ax.bar(langs,students)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155642.png?raw=true" alt="blog_images20221021155642.png"></p><p>通过调整柱状图的宽度，可以实现在同一 x 轴位置绘制多个柱状图。您可以将它们设置成不同的颜色，从而使它们更容易区分。下面示例描述了某工程学院过去四年中，三个专业录取的统招学生数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">data = [[<span class="number">30</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">20</span>], [<span class="number">40</span>, <span class="number">23</span>, <span class="number">51</span>, <span class="number">17</span>], [<span class="number">35</span>, <span class="number">22</span>, <span class="number">45</span>, <span class="number">19</span>]]</span><br><span class="line">X = np.arange(<span class="number">4</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 添加子图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">ax.bar(X + <span class="number">0.00</span>, data[<span class="number">0</span>], color=<span class="string">&#x27;b&#x27;</span>, width=<span class="number">0.25</span>)</span><br><span class="line">ax.bar(X + <span class="number">0.25</span>, data[<span class="number">1</span>], color=<span class="string">&#x27;g&#x27;</span>, width=<span class="number">0.25</span>)</span><br><span class="line">ax.bar(X + <span class="number">0.50</span>, data[<span class="number">2</span>], color=<span class="string">&#x27;r&#x27;</span>, width=<span class="number">0.25</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155841.png?raw=true" alt="blog_images20221021155841.png"></p><p>柱状图除了上述使用方法外，还有另外一种堆叠柱状图。所谓堆叠柱状图就是将不同数组别的柱状图堆叠在一起，堆叠后的柱状图高度显示了两者相加的结果值。</p><p>bar() 函数提供了一个可选参数<code>bottom</code>，该参数可以指定柱状图开始堆叠的起始值，一般从底部柱状图的最大值开始，依次类推。</p><p>下面是一个不同国家参加奥林匹克运动会所得奖牌（金银铜）的柱状堆叠图示例，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">countries = [<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;India&#x27;</span>, <span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Russia&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>]</span><br><span class="line">bronzes = np.array([<span class="number">38</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">19</span>, <span class="number">15</span>])</span><br><span class="line">silvers = np.array([<span class="number">37</span>, <span class="number">23</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">10</span>])</span><br><span class="line">golds = np.array([<span class="number">46</span>, <span class="number">27</span>, <span class="number">26</span>, <span class="number">19</span>, <span class="number">17</span>])</span><br><span class="line"><span class="comment"># 此处的 _ 下划线表示将循环取到的值放弃，只得到[0,1,2,3,4]</span></span><br><span class="line">ind = [x <span class="keyword">for</span> x, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(countries)]</span><br><span class="line"><span class="comment">#绘制堆叠图</span></span><br><span class="line">plt.bar(ind, golds, width=<span class="number">0.5</span>, label=<span class="string">&#x27;golds&#x27;</span>, color=<span class="string">&#x27;gold&#x27;</span>, bottom=silvers+bronzes)</span><br><span class="line">plt.bar(ind, silvers, width=<span class="number">0.5</span>, label=<span class="string">&#x27;silvers&#x27;</span>, color=<span class="string">&#x27;silver&#x27;</span>, bottom=bronzes)</span><br><span class="line">plt.bar(ind, bronzes, width=<span class="number">0.5</span>, label=<span class="string">&#x27;bronzes&#x27;</span>, color=<span class="string">&#x27;#CD853F&#x27;</span>)</span><br><span class="line"><span class="comment">#设置坐标轴</span></span><br><span class="line">plt.xticks(ind, countries)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Medals&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Countries&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;2019 Olympics Top Scorers&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021155951.png?raw=true" alt="blog_images20221021155951.png"></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>直方图（Histogram），又称质量分布图，它是一种条形图的一种，由一系列高度不等的纵向线段来表示数据分布的情况。 直方图的横轴表示数据类型，纵轴表示分布情况。</p><p><strong>首先，我们需要了解柱状图和直方图的区别。直方图用于概率分布，它显示了一组数值序列在给定的数值范围内出现的概率；而柱状图则用于展示各个类别的频数。</strong></p><p>如果想要构建直方图，必须遵循以下步骤：</p><ul><li>将整个值范围划分为一系列区间。</li><li>区间值（bin）的取值，不可遗漏数据；</li><li>计算每个区间中有多少个值。</li></ul><p>例如，我们对某工厂的员工年龄做直方图统计，首先我们要统计出每一位员工的年龄，然后设定一个 20 至 65 的数值范围，并将该数值范围细分为 4 个区间段 (20,35),(35,45),(45,55),(55,65) , 最后通过直方图的形式，展示该工厂员工在相应年龄区间的分布情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.hist()<span class="comment">#函数原型</span></span><br></pre></td></tr></table></figure><p>该函数的参数说明如下：</p><table><thead><tr><th>x</th><th>必填参数，数组或者数组序列。</th></tr></thead><tbody><tr><td>bins</td><td>可选参数，整数或者序列，bins 表示每一个间隔的边缘（起点和终点）默认会生成 10 个间隔。</td></tr><tr><td>range</td><td>指定全局间隔的下限与上限值 (min,max)，元组类型，默认值为 None。</td></tr><tr><td>density</td><td>如果为 True，返回概率密度直方图；默认为 False，返回相应区间元素的个数的直方图。</td></tr><tr><td>histtype</td><td>要绘制的直方图类型，默认值为“bar”，可选值有 barstacked(堆叠条形图)、step(未填充的阶梯图)、stepfilled(已填充的阶梯图)。</td></tr></tbody></table><p>以下示例绘制了班级学生得分情况的直方图。其中定义了四个区间（bins）分别是：0-25、26-50、51-75 和 76-100。直方图显示了相应范围的学生人数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#创建图形对象和轴域对象</span></span><br><span class="line">fig,ax = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">a = np.array([<span class="number">22</span>,<span class="number">87</span>,<span class="number">5</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">73</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">11</span>,<span class="number">20</span>,<span class="number">51</span>,<span class="number">5</span>,<span class="number">79</span>,<span class="number">31</span>,<span class="number">27</span>])</span><br><span class="line"><span class="comment">#绘制直方图</span></span><br><span class="line">ax.hist(a, bins = [<span class="number">0</span>,<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>])</span><br><span class="line"><span class="comment">#设置坐标轴</span></span><br><span class="line">ax.set_title(<span class="string">&quot;histogram of result&quot;</span>)</span><br><span class="line">ax.set_xticks([<span class="number">0</span>,<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>])</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;marks&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;no.of students&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160038.png?raw=true" alt="blog_images20221021160038.png"></p><h3 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h3><p>饼状图用来显示一个数据系列，具体来说，饼状图显示一个数据系列中各项目的占项目总和的百分比。</p><p>Matplotlib 提供了一个 pie() 函数，该函数可以生成数组中数据的饼状图。您可使用 x/sum(x) 来计算各个扇形区域占饼图总和的百分比。pie() 函数的参数说明如下：</p><table><thead><tr><th>X</th><th>数组序列，数组元素对应扇形区域的数量大小。</th></tr></thead><tbody><tr><td>labels</td><td>列表字符串序列，为每个扇形区域备注一个标签名字。</td></tr><tr><td>color</td><td>为每个扇形区域设置颜色，默认按照颜色周期自动设置。</td></tr><tr><td>autopct</td><td>格式化字符串”fmt%pct”，使用百分比的格式设置每个扇形 区的标签，并将其放置在扇形区内。</td></tr></tbody></table><p>以下示例：关于不同计算机语言学习人数的饼状图。autopct 参数设置为 %1.2f% ，并将各项所占总和的百分比显示在相对应的扇形区内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#添加图形对象</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#使得X/Y轴的间距相等</span></span><br><span class="line">ax.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line"><span class="comment">#准备数据</span></span><br><span class="line">langs = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>]</span><br><span class="line">students = [<span class="number">23</span>,<span class="number">17</span>,<span class="number">35</span>,<span class="number">29</span>,<span class="number">12</span>]</span><br><span class="line"><span class="comment">#绘制饼状图</span></span><br><span class="line">ax.pie(students, labels = langs,autopct=<span class="string">&#x27;%1.2f%%&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160156.png?raw=true" alt="blog_images20221021160156.png"></p><h3 id="等高线"><a href="#等高线" class="headerlink" title="等高线"></a>等高线</h3><p>等高线图（也称“水平图”）是一种在二维平面上显示 3D 图像的方法。等高线有时也被称为 “Z 切片”，如果您想要查看因变量 Z 与自变量 X、Y 之间的函数图像变化（即 Z=f(X,Y)），那么采用等高线图最为直观。</p><p>Matplotlib API 提供了绘制等高线（contour）与填充等高线（ contourf）的函数。这两个函数都需要三个参数，分别是 X、Y 与 Z。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#创建xlist、ylist数组</span></span><br><span class="line">xlist = np.linspace(-<span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">100</span>)</span><br><span class="line">ylist = np.linspace(-<span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment">#将上述数据变成网格数据形式</span></span><br><span class="line">X, Y = np.meshgrid(xlist, ylist)</span><br><span class="line"><span class="comment">#定义Z与X,Y之间的关系</span></span><br><span class="line">Z = np.sqrt(X**<span class="number">2</span> + Y**<span class="number">2</span>)</span><br><span class="line">fig,ax=plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#填充等高线颜色</span></span><br><span class="line">cp = ax.contourf(X, Y, Z)</span><br><span class="line">fig.colorbar(cp) <span class="comment"># 给图像添加颜色柱</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;Filled Contours Plot&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x (cm)&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y (cm)&#x27;</span>)</span><br><span class="line"><span class="comment">#画等高线</span></span><br><span class="line">plt.contour(X,Y,Z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160236.png?raw=true" alt="blog_images20221021160236.png"></p><h3 id="振动图"><a href="#振动图" class="headerlink" title="振动图"></a>振动图</h3><p>振动图也叫磁场图，或量场图，其图像的表现形式是一组矢量箭头，其数学含义是在点 (x,y) 处具有分向量 (u,v)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiver(x,y,u,v)</span><br></pre></td></tr></table></figure><p>上述函数表示，在指定的 (x,y) 坐标上以箭头的形式绘制向量，参数说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>一维、二维数组或者序列，表示箭头位置的 x 坐标。</td></tr><tr><td>y</td><td>一维、二维数组或者序列，表示箭头位置的 y 坐标。</td></tr><tr><td>u</td><td>一维、二维数组或者序列，表示箭头向量的 x 分量。</td></tr><tr><td>v</td><td>一维、二维数组或者序列，表示箭头向量的 y 分量。</td></tr><tr><td>c</td><td>一维、二维数组或者序列，表示箭头颜色。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x,y = np.meshgrid(np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.2</span>), np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.25</span>))</span><br><span class="line">z = x*np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#计算数组中元素的梯度</span></span><br><span class="line">v, u = np.gradient(z, <span class="number">0.2</span>, <span class="number">0.2</span>)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">q = ax.quiver(x,y,u,v)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160326.png?raw=true" alt="blog_images20221021160326.png"></p><h3 id="泡泡图"><a href="#泡泡图" class="headerlink" title="泡泡图"></a>泡泡图</h3><p>散点图的一种，加入了第三个值 <code>s</code> 可以理解成普通散点，画的是二维，泡泡图体现了 Z 的大小，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">50</span></span><br><span class="line">x = np.random.rand(N)</span><br><span class="line">y = np.random.rand(N)</span><br><span class="line">colors = np.random.rand(N)</span><br><span class="line">area = (<span class="number">30</span> * np.random.rand(N))**<span class="number">2</span>  <span class="comment"># 0 to 15 point radii</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, s=area, c=colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021144108.png?raw=true" alt="blog_images20221021144108.png"></p><h1 id="matplotlib-绘制-3D-图"><a href="#matplotlib-绘制-3D-图" class="headerlink" title="matplotlib 绘制 3D 图"></a>matplotlib 绘制 3D 图</h1><p>最初开发的 Matplotlib，仅支持绘制 2d 图形，后来随着版本的不断更新， Matplotlib 在二维绘图的基础上，构建了一部分较为实用的 3D 绘图程序包，比如 <code>mpl_toolkits.mplot3d</code>，通过调用该程序包一些接口可以绘制 3D 散点图、3D 曲面图、3D 线框图等</p><p>首先创建一个三维绘图区域， plt.axes() 函数提供了一个参数<code>projection</code>，将其参数值设置为 “3d”。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入三维工具包mplot3d</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment">#创建3d绘图区域</span></span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="3D-散点图"><a href="#3D-散点图" class="headerlink" title="3D 散点图"></a>3D 散点图</h2><p>通过 ax.scatter3D() 函数可以绘制 3D 散点图，示例代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment">#创建绘图区域</span></span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="comment">#构建xyz</span></span><br><span class="line">z = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">x = z * np.sin(<span class="number">20</span> * z)</span><br><span class="line">y = z * np.cos(<span class="number">20</span> * z)</span><br><span class="line">c = x + y</span><br><span class="line">ax.scatter3D(x, y, z, c=c)</span><br><span class="line">ax.set_title(<span class="string">&#x27;3d Scatter plot&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160440.png?raw=true" alt="blog_images20221021160440.png"></p><h2 id="3D-等高线图"><a href="#3D-等高线图" class="headerlink" title="3D 等高线图"></a>3D 等高线图</h2><p>ax.contour3D() 可以用来创建三维等高线图，该函数要求输入数据均采用二维网格式的矩阵坐标。同时，它可以在每个网格点<code>(x,y)</code>处计算出一个 z 值。</p><p>以下示例展示了如何绘制三维正弦等高线图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">   <span class="keyword">return</span> np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"><span class="comment">#构建x、y数据</span></span><br><span class="line">x = np.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line">y = np.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">#将数据网格化处理</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="comment">#50表示在z轴方向等高线的高度层级，binary颜色从白色变成黑色</span></span><br><span class="line">ax.contour3D(X, Y, Z, <span class="number">50</span>, cmap=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;3D contour&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160531.png?raw=true" alt="blog_images20221021160531.png"></p><h2 id="3D-线框图"><a href="#3D-线框图" class="headerlink" title="3D 线框图"></a>3D 线框图</h2><p>线框图同样要采用二维网格形式的数据，与绘制等高线图类似。</p><p>线框图可以将数据投影到指定的三维表面上，并输出可视化程度较高的三维效果图。通过 plot_wireframe() 能够绘制 3D 线框图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#要绘制函数图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">   <span class="keyword">return</span> np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"><span class="comment">#准备x,y数据</span></span><br><span class="line">x = np.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line">y = np.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">#生成x、y网格化数据</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"><span class="comment">#准备z值</span></span><br><span class="line">Z = f(X, Y)</span><br><span class="line"><span class="comment">#绘制图像</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="comment">#调用绘制线框图的函数plot_wireframe()</span></span><br><span class="line">ax.plot_wireframe(X, Y, Z, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;wireframe&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160616.png?raw=true" alt="blog_images20221021160616.png"></p><h2 id="3D-曲面图"><a href="#3D-曲面图" class="headerlink" title="3D 曲面图"></a>3D 曲面图</h2><p>曲面图表示一个指定的因变量<code>y</code>与两个自变量<code>x</code>和<code>z</code>之间的函数关系。</p><p>3D 曲面图是一个三维图形，它非常类似于线框图。不同之处在于，线框图的每个面都由多边形填充而成。Matplotlib 提供的 plot_surface() 函数可以绘制 3D 曲面图，该函数需要接受三个参数值 x，y 和 z 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#求向量积(outer()方法又称外积)</span></span><br><span class="line">x = np.outer(np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">30</span>), np.ones(<span class="number">30</span>))</span><br><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">y = x.copy().T</span><br><span class="line"><span class="comment">#数据z</span></span><br><span class="line">z = np.cos(x ** <span class="number">2</span> + y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment">#绘制曲面图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="comment">#调用plot_surface()函数</span></span><br><span class="line">ax.plot_surface(x, y, z,cmap=<span class="string">&#x27;viridis&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Surface plot&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021160711.png?raw=true" alt="blog_images20221021160711.png"></p>]]></content>
    
    
    <summary type="html">数据可视化</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据预处理</title>
    <link href="http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2022/10/21/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</id>
    <published>2022-10-21T07:00:00.000Z</published>
    <updated>2022-11-22T08:31:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据预处理："><a href="#数据预处理：" class="headerlink" title="数据预处理："></a>数据预处理：</h1><p><strong>前提：本文通过 python 语言实现预处理和算法功能，如果对 python 语法不熟悉请先去学习一下 python 语法以帮助之后的学习。</strong></p><h2 id="常用终端命令："><a href="#常用终端命令：" class="headerlink" title="常用终端命令："></a>常用终端命令：</h2><h3 id="conda-命令"><a href="#conda-命令" class="headerlink" title="conda 命令"></a>conda 命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">conda -v #查看当前conda版本</span><br><span class="line">conda --<span class="built_in">help</span> #通过命令行获取帮助 缩写为 conda -h</span><br><span class="line">   #例如 conda install -h 查看install如何使用</span><br><span class="line">conda info --base #–base：查看基环境所在路径。</span><br><span class="line">conda info -e #列出当前所有的 conda 环境。</span><br><span class="line">conda info --unsafe-channels #查看令牌公开的频道</span><br><span class="line">conda create -n my_env #创建一个 conda 环境 环境名称为my_env</span><br><span class="line">conda activate my_env  #创建完成后，我们使用命令进入该环境。使用 conda list 命令来查看该环境下都安装了哪些包。</span><br><span class="line">conda deactivate #退出环境</span><br><span class="line">conda create -n new_env --clone original_env #克隆new_env环境到new_env环境</span><br><span class="line">conda create -n new_env --clone G:\anaconda3\envs\original_env #根据地址镜像克隆</span><br><span class="line">conda install 包名#conda install numpy</span><br><span class="line">#conda install -n my_env python=<span class="number">3</span>.<span class="number">9</span>.<span class="number">7</span> # 根据名称</span><br><span class="line">#conda install -p G:\anaconda3\envs\my_env python=<span class="number">3</span>.<span class="number">9</span>.<span class="number">7</span> # 根据地址</span><br><span class="line">conda remove -n my_env numpy #移除 my_env 下的 numpy</span><br><span class="line">conda remove -n my_env --all #移除 my_env 下的所有包</span><br><span class="line">#需要注意的是，conda没有提供重命名环境的命令,我们只能先克隆一份原来的环境，然后再删除原来的环境(例如将环境 a 重命名成 b)</span><br><span class="line">conda create -n b --clone a</span><br><span class="line">conda remove -n a --all</span><br><span class="line">#conda uninstall是 conda remove的别名，我们也可以使用 conda uninstall来移除包，方法是相同的。</span><br><span class="line">conda list #列出当前环境下的所有包</span><br><span class="line">conda list -n my_env #列出my_env环境下的所有包</span><br><span class="line">conda search -c conda-forge numpy#指定在conda-forge中搜索numpy</span><br><span class="line">conda update -n my_env numpy scipy #升级my_env下的numpy和scipy</span><br><span class="line">conda update -n my_env --all#更新 my_env中的所有包</span><br><span class="line">conda update conda #更新conda本身</span><br></pre></td></tr></table></figure><h3 id="pip-命令"><a href="#pip-命令" class="headerlink" title="pip 命令"></a>pip 命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">python -m ensurepip #安装pip</span><br><span class="line">python -m pip install -U pip#更新pip</span><br><span class="line">python -m pip install pip==<span class="number">20</span>.<span class="number">2</span>.<span class="number">4</span> #安装指定版本的pip</span><br><span class="line">pip install [package] #安装包</span><br><span class="line">pip install [package==version] #安装指定版本的包</span><br><span class="line">pip install --upgrade [package]#升级包 缩写：pip install -U [package]</span><br><span class="line">pip uninstall [package] #卸载包</span><br><span class="line">pip install [package] -i [source]#指定单次安装源</span><br><span class="line">pip install [-U] -r requirements.txt#安装requirements.txt文件中的所有包</span><br><span class="line">pip freeze &gt; requirements.txt#将包导出requirements.txt</span><br><span class="line">pip --version##查看pip版本 缩写：pip -V</span><br><span class="line">pip --<span class="built_in">help</span> #获取帮助 缩写：pip -h</span><br><span class="line">pip search [package] #搜索包</span><br><span class="line">pip show [-f] [package]#查看指定包的详细信息，包含版本号</span><br><span class="line">#列出已安装的包及其版本号</span><br><span class="line">pip list</span><br><span class="line">pip freeze</span><br><span class="line">pip list -o #查看可升级的包</span><br></pre></td></tr></table></figure><h2 id="镜像源配置："><a href="#镜像源配置：" class="headerlink" title="镜像源配置："></a>镜像源配置：</h2><p>国内镜像源：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">阿里云镜像:</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">百度镜像:</span><br><span class="line">https://mirror.baidu.com/pypi/simple/</span><br><span class="line">清华镜像:</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">中科大镜像</span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">豆瓣镜像:</span><br><span class="line">http://pypi.douban.com/simple/</span><br><span class="line">搜狐镜像:</span><br><span class="line">http://mirrors.sohu.com/Python/</span><br><span class="line">华中科大镜像:</span><br><span class="line">https://pypi.hustunique.com/</span><br><span class="line">山东理工大学镜像:</span><br><span class="line">https://pypi.hustunique.com/</span><br></pre></td></tr></table></figure><p>下载时直接指定临时镜像</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> pip install numpy -i 镜像源</span><br><span class="line"># 例如：pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><p><strong>推荐配置永久镜像这样以后每次下载包我们都不需要加镜像地址</strong></p><p><strong>配置 conda 镜像源</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#这里我们选择清华的Tuna镜像源,有时候有的镜像会挂掉不要怕可以换一个镜像</span><br><span class="line">#打开<span class="built_in">cmd</span>输入以下指令</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>配置完成后在 cmd 输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/11/ndIbUx.png" alt="img"></p><p>可以看到 channel URLs 已经配置好镜像源</p><p><strong>配置 pip 镜像源</strong></p><p>命令行配置 pip</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/  配置阿里云镜像</span><br><span class="line">pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com 配置信任主机镜像</span><br><span class="line">大家可以根据自己喜欢的镜像地址进行配置</span><br></pre></td></tr></table></figure><p>文档更换 pip 源</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Windows环境，在C:\user\username\pip\pip.ini（自行创建）中加入：</span><br><span class="line">[global]</span><br><span class="line">index-url=https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.tuna.tsinghua.edu.cn</span><br><span class="line">disable-pip-version-check = true</span><br><span class="line">timeout = <span class="number">6000</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Linux环境</span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">mkdir</span> .pip</span><br><span class="line"><span class="built_in">cd</span> .pip</span><br><span class="line">sudo vim pip.conf</span><br><span class="line"></span><br><span class="line"># 加入如下内容（其实就是指定tuna源）</span><br><span class="line">[global]</span><br><span class="line">index-url=https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.tuna.tsinghua.edu.cn</span><br><span class="line">disable-pip-version-check = true</span><br><span class="line">timeout = <span class="number">6000</span></span><br></pre></td></tr></table></figure><h2 id="python-数据处理包——numpy"><a href="#python-数据处理包——numpy" class="headerlink" title="python 数据处理包——numpy"></a>python 数据处理包——numpy</h2><h3 id="numpy-介绍"><a href="#numpy-介绍" class="headerlink" title="numpy 介绍"></a>numpy 介绍</h3><p>NumPy 是 Python 科学计算的基础软件包，提供多了维数组对象，多种派生对象（掩码数组、矩阵等）以及用于快速操作数组的函数及 API，它包括数学、逻辑、数组形状变换、排序、选择、I/O 、离散傅立叶变换、基本线性代数、基本统计运算、随机模拟等</p><p><strong>numpy 模块介绍：</strong></p><table><thead><tr><th>numpy.core</th><th>核心子模块</th></tr></thead><tbody><tr><td>numpy.lib</td><td>函数子模块</td></tr><tr><td>numpy.random</td><td>随机抽样子模块</td></tr><tr><td>numpy.ma</td><td>掩码数组子模块，用于处理包含无效或丢失的数据的数组</td></tr><tr><td>numpy.linalg</td><td>线性代数子模块</td></tr><tr><td>numpy.fft</td><td>离散傅里叶变换子模块</td></tr><tr><td>numpy.math</td><td>由 C 标准定义的数学函数子模块</td></tr><tr><td>numpy.emath</td><td>具有自动域的数学函数子模块</td></tr><tr><td>numpy.rec</td><td>记录数组子模块，数组元素是多个不同类型的数据的组合，类似结构体</td></tr><tr><td>numpy.matrixlib</td><td>矩阵类和函数子模块</td></tr><tr><td>numpy.ctypeslib</td><td>ctypes 外部函数接口子模块</td></tr><tr><td>numpy.polynomial</td><td>多项式子模块</td></tr><tr><td>numpy.char</td><td>向量化字符串操作子模块</td></tr><tr><td>numpy.testing</td><td>测试支持子模块</td></tr></tbody></table><p><strong>维、秩、轴</strong></p><p>维，就是维度。我们说数组是几维的，就是指维度，3 维的数组，其维度数自然就是 3。维度数，有一个专用名字，叫做秩。秩这个名字感觉有些多余，不如维度数更容易理解。但是，轴（axis）的概念一定要建立起来，并且要理解，因为轴的概念很重要。简单来说，可以把数组的轴，和笛卡尔坐标系的轴对应一下。</p><p>一维数组，类比于一维空间，只有一个轴，那就是 0 轴。</p><p>二维数组，类比于二维平面，有两个轴，我们习惯表示成行、列，那么行的方向就是 0 轴，列的方向就是 1 轴。</p><p>三维数组，类比于三维空间，有三个轴，我们习惯表示成层、行、列，那么层的方向就是 0 轴，行的方向就是 1 轴，列的方向就是 2 轴。</p><p><strong>广播和矢量化</strong></p><p>在讲两个概念之前，我们先思考两个问题：</p><ol><li>整型数组各元素加 1；</li><li>求两个等长整型数组对应元素之和组成的新数组。</li></ol><p>若用 python 的列表实现的话，代码大约会这样写吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)): <span class="comment"># 遍历数组为每个元素加1</span></span><br><span class="line">        x[i] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = <span class="built_in">list</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x, y): <span class="comment"># 遍历两个数组，逐个元素求和</span></span><br><span class="line">        z.append(i+j)</span><br></pre></td></tr></table></figure><p>用 NumPy 数组实现的话，代码就简洁多了，无需循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a + b</span><br></pre></td></tr></table></figure><p>显然，用 NumPy 数组实现起来，要比 Python 列表更简洁、更清晰。这得益于于 NumPy 的两大特性：广播和矢量化。</p><p>广播（broadcast）和矢量化（vectorization），是 NumPy 最精髓的特性，是 NumPy 的灵魂。所谓广播，就是将对数组的操作映射到每个数组元素上；矢量化可以理解为代码中没有显式的循环、索引等。NumPy 数组最重要的特性是广播和矢量化，体现在性能上，就是接近 C 语言的运行效率，体现在代码上，则有这样的特点：</p><ol><li>矢量化代码更简洁，更易于阅读</li><li>代码行越少意味着出错的几率越小</li><li>代码更接近于标准的数学符号</li><li>矢量化代码更 pythonic</li></ol><h3 id="numpy-下载"><a href="#numpy-下载" class="headerlink" title="numpy 下载"></a>numpy 下载</h3><p>1.下载 numpy</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy  #pip下载</span><br><span class="line">conda install numpy #Anconda下载</span><br></pre></td></tr></table></figure><p>备注：如果下载很慢导致超时可以配置镜像下载</p><p>2.导入 numpy 包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>NumPy 支持的数据类型主要有整型(integrate)、浮点型(float)、布尔型(bool)和复数型(complex)，每一种数据类型根据占用内存的字节数又分为多个不同的子类型。当然，NumPy 也支持自定义类型。</p><h3 id="numpy-创建数组"><a href="#numpy-创建数组" class="headerlink" title="numpy 创建数组"></a>numpy 创建数组</h3><p><strong>numpy 数组的属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ndarray.dtype</td><td>元素类型</td></tr><tr><td>ndarray.shape</td><td>数组结构或形状</td></tr><tr><td>ndarray.size</td><td>数组元素个数</td></tr><tr><td>ndarray.itemsize</td><td>数组元素的大小，以字节为单位</td></tr><tr><td>ndarray.ndim</td><td>数组的维度数，也叫秩</td></tr><tr><td>ndarray.flags</td><td>数组的内存信息</td></tr><tr><td>ndarray.real</td><td>元素的实部</td></tr><tr><td>ndarray.imag</td><td>元素的虚部</td></tr><tr><td>ndarray.data</td><td>元素数组的实际存储区</td></tr></tbody></table><h4 id="蛮力构造法："><a href="#蛮力构造法：" class="headerlink" title="蛮力构造法："></a>蛮力构造法：</h4><p>蛮力构造法使用 np.array() 来创建数组，其原型为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="literal">None</span>, subok=<span class="literal">False</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>蛮力构造法就是你想要什么结构，就直接用 Python 数组或元组写出来。这个方法看起来简单，但很容易出错，不适合构造体量较大的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment"># 创建2行3列数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br></pre></td></tr></table></figure><p>也可以像下面这样，在创建数组时，指定元素的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], dtype=np.uint8) <span class="comment"># 创建2行3列的单字节无符号整型数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure><h4 id="特殊数值法"><a href="#特殊数值法" class="headerlink" title="特殊数值法"></a>特殊数值法</h4><p>特殊值一般指 0，1，空值等。特殊数值法适合构造全 0、全 1、空数组，或者由 0、1 组成的类似单位矩阵（主对角线为 1，其余为 0）的数组。特殊数值法使用的 4 个函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype=<span class="built_in">float</span>, order=‘C’) <span class="comment">#创建全为0的数组</span></span><br><span class="line">numpy.ones(shape, dtype=<span class="built_in">float</span>, order=‘C’)<span class="comment">#创建全为1的数组</span></span><br><span class="line">numpy.empty(shape, dtype=<span class="built_in">float</span>, order=‘C’)<span class="comment">#创建空的数组</span></span><br><span class="line">numpy.eye(N, M=<span class="literal">None</span>, k=<span class="number">0</span>, dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;C’) #创建单位数组（单位矩阵）</span></span><br></pre></td></tr></table></figure><p>如果我们需要一个 3 行 4 列、初始值都是 5 的数组，该怎么做呢？填充函数 fill() 就是专门解决这个问题的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.empty((<span class="number">3</span>,<span class="number">4</span>), dtype=np.int8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.fill(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]], dtype=int8)</span><br></pre></td></tr></table></figure><h4 id="随机数值法"><a href="#随机数值法" class="headerlink" title="随机数值法"></a>随机数值法</h4><p>和 Python 的标准模块 random 类似，NumPy 也有一个 random 子模块，功能更为强大。用随机数值法创建数组，主要就是使用 random 子模块。random 子模块方法很多，我们只介绍 3 个常用函数，其原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.random(size=<span class="literal">None</span>) <span class="comment">#生成[0,1)之间的随机浮点数</span></span><br><span class="line">numpy.random.randint(low, high=<span class="literal">None</span>, size=<span class="literal">None</span>, dtype=‘l’) <span class="comment"># 生成 [low, high) 区间内的随机整数</span></span><br><span class="line">numpy.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=<span class="literal">None</span>) <span class="comment">#normal() 生成以 loc 为均值、以 scale 为标准差的正态分布数组</span></span><br></pre></td></tr></table></figure><p>下面，我们用正态分布函数模拟生成 1000 位成年男性的身高数据（假定中国成年男性平均身高 170 厘米，标准差 4 厘米），并画出柱状图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tall = np.random.normal(<span class="number">170</span>, <span class="number">4</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bins = np.arange(<span class="number">156</span>, <span class="number">190</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.hist(tall, bins)</span><br><span class="line">(array([  <span class="number">3.</span>,   <span class="number">4.</span>,  <span class="number">15.</span>,  <span class="number">31.</span>,  <span class="number">94.</span>, <span class="number">163.</span>, <span class="number">185.</span>, <span class="number">186.</span>, <span class="number">157.</span>,  <span class="number">92.</span>,  <span class="number">43.</span>,</span><br><span class="line">        <span class="number">18.</span>,   <span class="number">6.</span>,   <span class="number">1.</span>,   <span class="number">1.</span>,   <span class="number">0.</span>]), array([<span class="number">156</span>, <span class="number">158</span>, <span class="number">160</span>, <span class="number">162</span>, <span class="number">164</span>, <span class="number">166</span>, <span class="number">168</span>, <span class="number">170</span>, <span class="number">172</span>, <span class="number">174</span>, <span class="number">176</span>, <span class="number">178</span>, <span class="number">180</span>,</span><br><span class="line">       <span class="number">182</span>, <span class="number">184</span>, <span class="number">186</span>, <span class="number">188</span>]), &lt;a <span class="built_in">list</span> of <span class="number">16</span> Patch objects&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021151338.png?raw=true" alt="blog_images20221021151338.png"></p><h4 id="定长分割法"><a href="#定长分割法" class="headerlink" title="定长分割法"></a>定长分割法</h4><p>定长分割法最常用的函数是 arange()，非常类似于 Python 的 range() 函数，只是前面多了一个字母 a。另一个定长分割函数 linspace() 类似于 arange()，但功能更强大。两个函数的原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype=<span class="literal">None</span>)</span><br><span class="line">numpy.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>linspace() 函数需要 3 个参数：一个起点、一个终点，一个返回元素的个数。</p><p>linspace() 返回的元素包括起点和终点，我们可以通过 endpoint 参数选择是否包含终点。</p><h4 id="构造复杂数组"><a href="#构造复杂数组" class="headerlink" title="构造复杂数组"></a>构造复杂数组</h4><h5 id="重复构造法"><a href="#重复构造法" class="headerlink" title="重复构造法"></a>重复构造法</h5><p>重复构造法主要使用 repeat() 和 tile() 两个函数，<strong>repeat() 用来重复元素，tile() 用来重复数组。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.repeat(a,<span class="number">3</span>) <span class="comment"># 重复元素3次</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.tile(a,<span class="number">3</span>) <span class="comment"># 重复数组3次</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.tile(a,(<span class="number">3</span>,<span class="number">2</span>)) <span class="comment"># 重复数组3行2列</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure><p>对于多维数组 a，repeat() 还有一个默认参数 axis，tile() 也有不同表现，请仔细揣摩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.repeat(a,<span class="number">3</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.repeat(a,<span class="number">3</span>,axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.repeat(a,<span class="number">3</span>,axis=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.tile(a,<span class="number">3</span>)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.tile(a,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><h5 id="网格构造法"><a href="#网格构造法" class="headerlink" title="网格构造法"></a>网格构造法</h5><p>用数组表示经纬度网格，一般有两种方式。第一种方式，用两个一维数组表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lon = np.linspace(-<span class="number">180</span>,<span class="number">180</span>,<span class="number">37</span>) <span class="comment"># 网格精度为10°，共计37个经度点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lat = np.linspace(-<span class="number">90</span>,<span class="number">90</span>,<span class="number">19</span>) <span class="comment"># 网格精度为10°，共计19个纬度点</span></span><br></pre></td></tr></table></figure><p>第二种方式，则是用 np.meshgrid() 生成两个二维数组，分别表示经度网格、纬度网格。np.meshgrid() 以刚才的两个一维数组 lon 和 lat 为参数，生成的网格精度也是 10°。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lons,lats = np.meshgrid(lon,lat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lons.shape</span><br><span class="line">(<span class="number">19</span>, <span class="number">37</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lats.shape</span><br><span class="line">(<span class="number">19</span>, <span class="number">37</span>)</span><br></pre></td></tr></table></figure><p>构造网格，除了 np.meshgrid() 之外，还有一个更牛的方法，可以直接生成纬度网格和经度网格（请注意，纬度在前，经度在后）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lats, lons = np.mgrid[-<span class="number">90</span>:<span class="number">91</span>:<span class="number">5.</span>, -<span class="number">180</span>:<span class="number">181</span>:<span class="number">5.</span>] <span class="comment"># 网格精度为5°，网格shape为(37,73)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lons.shape, lats.shape</span><br><span class="line">((<span class="number">37</span>, <span class="number">73</span>), (<span class="number">37</span>, <span class="number">73</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lats, lons = np.mgrid[-<span class="number">90</span>:<span class="number">90</span>:<span class="number">37j</span>, -<span class="number">180</span>:<span class="number">180</span>:<span class="number">73j</span>] <span class="comment"># 也可以用虚实指定分割点数，网格精度同样为5°</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lons.shape, lats.shape</span><br><span class="line">((<span class="number">37</span>, <span class="number">73</span>), (<span class="number">37</span>, <span class="number">73</span>))</span><br></pre></td></tr></table></figure><h3 id="numpy-操作数组"><a href="#numpy-操作数组" class="headerlink" title="numpy 操作数组"></a>numpy 操作数组</h3><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><p>NumPy 数组对象的内容可以通过索引或切片来访问和修改。对于一维数组的索引和切片，NumPy 数组和 Python 的列表一样灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>]                            <span class="comment"># 最后一个元素</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>]                           <span class="comment"># 返回第2到第5个元素</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">7</span>:<span class="number">3</span>]                          <span class="comment"># 返回第0到第7个元素，步长为3</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::-<span class="number">1</span>]                          <span class="comment"># 返回逆序的数组</span></span><br><span class="line">array([<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>对于多维数组操作，NumPy 数组比 Python 的列表更加灵活、强大。假设有一栋 2 层楼，每层楼内的房间都是 3 行 4 列，那我们可以用一个三维数组来保存每个房间的居住人数（当然，也可以是房间面积等其他数值信息）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)    <span class="comment"># 2层3行4列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]                          <span class="comment"># 虽然可以这样</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]                            <span class="comment"># 但这才是规范的用法</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,<span class="number">0</span>,<span class="number">0</span>]                            <span class="comment"># 所有楼层的第1排第1列</span></span><br><span class="line">array([ <span class="number">0</span>, <span class="number">12</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>,:,:]                            <span class="comment"># 1楼的所有房间，等价与a[0]或a[0,...]</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,:,<span class="number">1</span>:<span class="number">3</span>]                          <span class="comment"># 所有楼层所有排的第2到4列</span></span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">17</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>,:,-<span class="number">1</span>]                           <span class="comment"># 2层每一排的最后一个房间</span></span><br><span class="line">array([<span class="number">15</span>, <span class="number">19</span>, <span class="number">23</span>])</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>对多维数组切片或索引得到的结果，维度不是确定的；</li><li>切片返回的数组不是原始数据的副本，而是指向与原始数组相同的内存区域。数组切片不会复制内部数组数据，只是产生了原始数据的一个新视图。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[<span class="number">1</span>:,<span class="number">2</span>:] <span class="comment"># 数组b是数组a的切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[:,:] = <span class="number">99</span> <span class="comment"># 改变数组b的值，也会同时影响数组a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[<span class="number">99</span>, <span class="number">99</span>],</span><br><span class="line">       [<span class="number">99</span>, <span class="number">99</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>, <span class="number">99</span>, <span class="number">99</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">99</span>, <span class="number">99</span>]])</span><br></pre></td></tr></table></figure><h4 id="改变结构"><a href="#改变结构" class="headerlink" title="改变结构"></a>改变结构</h4><p>NumPy 数组的存储顺序和数组的视图是相互独立的，因此改变数组的维度是非常便捷的操作，这一类操作不会改变所操作的数组本身的存储顺序， resize() 除外。</p><ul><li>reshape() - 按照指定的结构（形状）返回数组的新视图，但不会改变数组</li><li>resize() - 按照指定的结构（形状）改变数组，无返回值</li><li>ravel() - 返回多维数组一维化的视图，但不会改变原数组</li><li>transpose() - 返回行变列的视图，但不会改变原数组</li><li>rollaxis() - 翻滚轴，返回新的视图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.reshape((<span class="number">3</span>，<span class="number">4</span>)) <span class="comment"># reshape()返回数组a的一个新视图，但不会改变数组a</span></span><br><span class="line">&gt;&gt;&gt;&gt; a.shape</span><br><span class="line">(<span class="number">12</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.base <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">a.resize([<span class="number">4</span>,<span class="number">3</span>]) <span class="comment"># resize()则真正改变了数组a的结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ravel() <span class="comment"># 返回多维数组一维化的视图，但不会改变原数组</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.transpose() <span class="comment"># 返回行变列的视图，但不会改变原数组</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.T  <span class="comment"># 返回行变列的视图，等价于transpose()</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.rollaxis(a, <span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 翻滚轴，1轴变0轴</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><h4 id="合并与拆分"><a href="#合并与拆分" class="headerlink" title="合并与拆分"></a>合并与拆分</h4><p>NumPy 数组一旦创建就不能再改变其元素数量了。如果要动态改变数组元素数量，只能通过合并或者拆分的方法，生成新的数组。对于刚刚上手 NumPy 的程序员来说，最大的困惑就是不能使用 append() 方法向数组内添加元素，甚至连 append() 方法都找不到了。其实，NumPy 仍然保留了 append() 方法，只不过这个方法不再是 NumPy 数组的方法，而是是升级到最外层的 NumPy 命名空间，并且该方法的功能不再是追加元素，而是合并数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.append([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])<span class="comment">#append的作用不是增加元素而是合并数组</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.append([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.append([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>不过，这个 append()委实不够好用，我给大家推荐的是 stack()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">4</span>,<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((a,b)) <span class="comment"># 水平合并</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.vstack((a,b)) <span class="comment"># 垂直合并</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dstack((a,b)) <span class="comment"># 深度合并</span></span><br><span class="line">array([[[<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">7</span>]]])</span><br></pre></td></tr></table></figure><p>stack 函数原型为 stack(arrays, axis=0)，请注意体会下面例子中的 axis 的用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">60</span>).reshape(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">60</span>).reshape(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape, b.shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.stack((a,b), axis=<span class="number">0</span>).shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.stack((a,b), axis=<span class="number">1</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.stack((a,b), axis=<span class="number">2</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.stack((a,b), axis=<span class="number">3</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>因为数组切片非常简单，所以数组拆分应用较少。拆分是合并的逆过程，最常用的方法是 split()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.vsplit(a, <span class="number">2</span>) <span class="comment"># 垂直方向拆分成2部分</span></span><br><span class="line">[array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]), array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hsplit(a, <span class="number">2</span>) <span class="comment"># 水平方向拆分成2部分</span></span><br><span class="line">[array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>]]), array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])]</span><br></pre></td></tr></table></figure><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>改变数组结构返回的是原元数据的一个新视图，而不是原元数据的副本。浅复制（view）和深复制（copy）则是创建原数据的副本，但二者之间也有细微差别：浅复制（view）是共享内存，深复制（copy）则是独享。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.view()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.base <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.flags.owndata</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.base <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.flags.owndata</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>NumPy 数组排序函数有两个，一个是 sort()，一个是 argsort()。sort()返回输入数组的排序副本，argsort()返回的是数组值从小到大的索引号。从函数原型看，这两个函数的参数是完全一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis=-1, kind=‘quicksort’, order=None)</span><br><span class="line">numpy.argsort(a, axis=-1, kind=‘quicksort’, order=None)</span><br></pre></td></tr></table></figure><ul><li>a - 要排序的数组</li><li>axis - 沿着它排序数组的轴，如果没有，则沿着最后的轴排序</li><li>kind - 排序方法，默认为’quicksort’（快速排序），其他选项还有 ‘mergesort’（归并排序）和 ‘heapsort’（堆排序）</li><li>order - 如果数组包含字段，则是要排序的字段</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0.79658569</span>, <span class="number">0.14507096</span>, <span class="number">0.63016223</span>],</span><br><span class="line">       [<span class="number">0.24983103</span>, <span class="number">0.98368325</span>, <span class="number">0.71092079</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(a) <span class="comment"># 返回行内从小到大排序的索引序号（列排序），相当于axis=1（最后的轴）</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]], dtype=int64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sort(a) <span class="comment"># 返回行内从小到大排序的一个新数组（列排序）</span></span><br><span class="line">array([[<span class="number">0.14507096</span>, <span class="number">0.63016223</span>, <span class="number">0.79658569</span>],</span><br><span class="line">       [<span class="number">0.24983103</span>, <span class="number">0.71092079</span>, <span class="number">0.98368325</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sort(a,axis=<span class="number">0</span>) <span class="comment"># 返回列内每一行都是从小到大排序（行排序）</span></span><br><span class="line">array([[<span class="number">0.24983103</span>, <span class="number">0.14507096</span>, <span class="number">0.63016223</span>],</span><br><span class="line">       [<span class="number">0.79658569</span>, <span class="number">0.98368325</span>, <span class="number">0.71092079</span>]])</span><br></pre></td></tr></table></figure><p>我们再看看排序字段的使用。先定义一个新的数据类型 dt：dt 类似于一个字典，有两个键值对，一个是姓名 name，一个是年龄 age，姓名长度 10 个字符，年龄是整型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,  <span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,  <span class="built_in">int</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([(<span class="string">&quot;zhang&quot;</span>,<span class="number">21</span>),(<span class="string">&quot;wang&quot;</span>,<span class="number">25</span>),(<span class="string">&quot;li&quot;</span>,  <span class="number">17</span>),  (<span class="string">&quot;zhao&quot;</span>,<span class="number">27</span>)], dtype = dt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sort(a, order=<span class="string">&#x27;name&#x27;</span>) <span class="comment"># 如果指定姓名排序，结果是李王张赵</span></span><br><span class="line">array([(<span class="string">b&#x27;li&#x27;</span>, <span class="number">17</span>), (<span class="string">b&#x27;wang&#x27;</span>, <span class="number">25</span>), (<span class="string">b&#x27;zhang&#x27;</span>, <span class="number">21</span>), (<span class="string">b&#x27;zhao&#x27;</span>, <span class="number">27</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sort(a, order=<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 如果指定年龄排序，结果则是李张王赵</span></span><br><span class="line">array([(<span class="string">b&#x27;li&#x27;</span>, <span class="number">17</span>), (<span class="string">b&#x27;zhang&#x27;</span>, <span class="number">21</span>), (<span class="string">b&#x27;wang&#x27;</span>, <span class="number">25</span>), (<span class="string">b&#x27;zhao&#x27;</span>, <span class="number">27</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>)])</span><br></pre></td></tr></table></figure><h4 id="查找和筛选"><a href="#查找和筛选" class="headerlink" title="查找和筛选"></a>查找和筛选</h4><p>这里，我们约定查找是返回符合条件的元素的索引号，筛选是返回符合条件的元素。查找和筛选，是 NumPy 数组最令人心动的功能，也是相对比较烧脑的操作。</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>下面的代码演示了返回数组中最大值和最小值的索引（对于多维数组，这个索引是数组转成一维之后的索引）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0.47881615</span>, <span class="number">0.55682904</span>, <span class="number">0.29173085</span>],</span><br><span class="line">       [<span class="number">0.41107703</span>, <span class="number">0.91467593</span>, <span class="number">0.88852535</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(a)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmin(a)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>下面的代码演示了返回数组中非零元素的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.nonzero(a)</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>], dtype=int64), array([<span class="number">1</span>, <span class="number">2</span>], dtype=int64))</span><br></pre></td></tr></table></figure><p>numpy.where() 用于返回数组中满足给定条件的元素的索引，还可以用于替换符合条件的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.where(condition[, x, y])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a &lt; <span class="number">5</span>)</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=int64),)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a.reshape((<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a &lt; <span class="number">5</span>)</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int64), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=int64))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a &lt; <span class="number">5</span>, a, <span class="number">10</span>*a) <span class="comment"># 满足条件的元素不变，其他元素乘以10</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]])</span><br></pre></td></tr></table></figure><h5 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h5><p>筛选有 3 种方式，一是使用 np.where()返回的 python 元组，二是使用逻辑表达式返回的布尔型数组，三是使用整型数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0.41551063</span>, <span class="number">0.38984904</span>, <span class="number">0.01204226</span>, <span class="number">0.72323978</span>],</span><br><span class="line">       [<span class="number">0.82425869</span>, <span class="number">0.64216573</span>, <span class="number">0.41475495</span>, <span class="number">0.21351508</span>],</span><br><span class="line">       [<span class="number">0.30104819</span>, <span class="number">0.52046164</span>, <span class="number">0.58286043</span>, <span class="number">0.66749564</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[np.where(a&gt;<span class="number">0.5</span>)] <span class="comment"># 返回大于0.5的元素（使用np.where()返回的python元组）</span></span><br><span class="line">array([<span class="number">0.72323978</span>, <span class="number">0.82425869</span>, <span class="number">0.64216573</span>, <span class="number">0.52046164</span>, <span class="number">0.58286043</span>,</span><br><span class="line">       <span class="number">0.66749564</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[(a&gt;<span class="number">0.3</span>)&amp;(a&lt;<span class="number">0.7</span>)] <span class="comment"># 返回大于0.3且小于0.7的元素（使用逻辑表达式返回的布尔型数组）</span></span><br><span class="line">array([<span class="number">0.41551063</span>, <span class="number">0.38984904</span>, <span class="number">0.64216573</span>, <span class="number">0.41475495</span>, <span class="number">0.30104819</span>,</span><br><span class="line">       <span class="number">0.52046164</span>, <span class="number">0.58286043</span>, <span class="number">0.66749564</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[np.array([<span class="number">2</span>,<span class="number">1</span>])] <span class="comment"># 返回整形数组指定的项（使用整型数组）</span></span><br><span class="line">array([[<span class="number">0.30104819</span>, <span class="number">0.52046164</span>, <span class="number">0.58286043</span>, <span class="number">0.66749564</span>],</span><br><span class="line">       [<span class="number">0.82425869</span>, <span class="number">0.64216573</span>, <span class="number">0.41475495</span>, <span class="number">0.21351508</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a.ravel()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>])] <span class="comment"># 返回整形数组指定的项（使用整型数组）</span></span><br><span class="line">array([<span class="number">0.72323978</span>, <span class="number">0.64216573</span>, <span class="number">0.21351508</span>, <span class="number">0.66749564</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[np.array([[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">11</span>]])] <span class="comment"># 返回整形数组指定的项（使用整型数组）</span></span><br><span class="line">array([[<span class="number">0.72323978</span>, <span class="number">0.64216573</span>],</span><br><span class="line">       [<span class="number">0.21351508</span>, <span class="number">0.66749564</span>]])</span><br></pre></td></tr></table></figure><h4 id="数组-I-O"><a href="#数组-I-O" class="headerlink" title="数组 I/O"></a>数组 I/O</h4><p>所谓数组 I/O，就是讨论如何分发、交换数据。在机器学习算法模型的例子中，海量的训练数据通常都是从数据文件中读出来的，而数据文件一般是 csv 格式，NumPy 自带的 csv 文件读写函数，可以很方便的读写 csv 格式的数据文件。除了支持通用的 csv 格式的数据文件， NumPy 为数组对象引入了新的二进制文件格式，用于数据交换。后缀名为.npy 文件用于存储单个数组，后缀名为.npz 文件用于存取多个数组。</p><p>csv 文件：</p><ul><li>加载文件函数：loadtxt()</li><li>保存文件函数：savetxt()</li></ul><p>npy/npz 文件：</p><ul><li>加载文件函数：load()</li><li>保存单个文件函数：save()</li><li>保存多个文件函数：savez()</li></ul><p>NumPy 自定义的数据交换格式也是一个非常好用的数据交换方式，使用它保存 NumPy 数组时不会丢失任何信息，特别是数据类型的信息。实际操作下面的代码时，请注意结合实际情况替换对应的文件路径和文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>single_arr_fn = <span class="string">&#x27;single_arr.npy&#x27;</span> <span class="comment"># 存储单个数组文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multi_arr_fn = <span class="string">&#x27;multi_arr.npz&#x27;</span> <span class="comment"># 存储多个数组文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lon = np.linspace(<span class="number">10</span>,<span class="number">90</span>,<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lat = np.linspace(<span class="number">20</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.save(single_arr_fn, lon) <span class="comment"># 用save()函数把经度数组保存成.npy文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lon = np.load(single_arr_fn) <span class="comment"># 接着用load()函数读出来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.savez(multi_arr_fn, longitude=lon, latitude=lat) <span class="comment">#保存两个数组到一个文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = np.load(multi_arr_fn) <span class="comment"># 用load()函数把这个.npz文件读成一个结构data</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.files <span class="comment"># 查看所有的数组名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="string">&#x27;longitude&#x27;</span>] <span class="comment"># 使用data[数组名]，就可以取得想要的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="string">&#x27;latitude&#x27;</span>] <span class="comment"># 使用data[数组名]，就可以取得想要的数据</span></span><br></pre></td></tr></table></figure><h3 id="numpy-常用函数："><a href="#numpy-常用函数：" class="headerlink" title="numpy 常用函数："></a>numpy 常用函数：</h3><h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><p>NumPy 有两个很有趣的特殊值，np.nan 和 np.inf。nan 是 not a number 的简写，意为不是数字，inf 是 infinity 的简写，意为无穷大。np.nan 也可以写作 np.Nan、np.NaN 或者 np.NAN，np.inf 也可以写作 np.Inf 或 np.Infinity。</p><p>基本处理方法：</p><ul><li>np.isnan()</li><li>np.isinf()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>, <span class="number">2</span>, np.nan, np.inf])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = np.nan</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = np.inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([nan, inf, nan, inf])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] == a[<span class="number">2</span>] <span class="comment"># 两个np.nan不相等</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] == a[<span class="number">3</span>] <span class="comment"># 两个np.inf则相等</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.isnan(a[<span class="number">0</span>]) <span class="comment"># 判断一个数字是否是np.nan</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.isinf(a[<span class="number">1</span>]) <span class="comment"># 判断一个数字是否是np.inf</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment">#nan并不会影响计算结果</span></span><br></pre></td></tr></table></figure><h4 id="函数命名空间"><a href="#函数命名空间" class="headerlink" title="函数命名空间"></a>函数命名空间</h4><p>刚开始使用 NumPy 函数的时候，你一定会有这样的困惑：</p><p>都是求和、求极值，下面这两种写法有什么区别吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">max</span>(), np.<span class="built_in">max</span>(a)</span><br><span class="line">(<span class="number">0.8975052328686041</span>, <span class="number">0.8975052328686041</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">sum</span>(), np.<span class="built_in">sum</span>(a)</span><br><span class="line">(<span class="number">5.255303938070831</span>, <span class="number">5.255303938070831</span>)</span><br></pre></td></tr></table></figure><p>同样是复制，为什么深复制 copy() 两种写法都行，而浅复制 view() 则只有数组的方法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.copy()</span><br><span class="line">array([<span class="number">0.14712593</span>, <span class="number">0.05692805</span>, <span class="number">0.41679214</span>, <span class="number">0.62755199</span>, <span class="number">0.58272166</span>,</span><br><span class="line">       <span class="number">0.88131178</span>, <span class="number">0.26184716</span>, <span class="number">0.30175671</span>, <span class="number">0.78588028</span>, <span class="number">0.50557561</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.copy(a)</span><br><span class="line">array([<span class="number">0.14712593</span>, <span class="number">0.05692805</span>, <span class="number">0.41679214</span>, <span class="number">0.62755199</span>, <span class="number">0.58272166</span>,</span><br><span class="line">       <span class="number">0.88131178</span>, <span class="number">0.26184716</span>, <span class="number">0.30175671</span>, <span class="number">0.78588028</span>, <span class="number">0.50557561</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.view()</span><br></pre></td></tr></table></figure><p>为什么 where() 不能作为数组 ndarray 的函数，而必须作为 NumPy 的函数？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a&gt;<span class="number">0.5</span>)</span><br><span class="line">(array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>], dtype=int64),)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.where(a&gt;<span class="number">0.5</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#65&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.where(a&gt;<span class="number">0.5</span>)</span><br><span class="line">AttributeError: <span class="string">&#x27;numpy.ndarray&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;where&#x27;</span></span><br></pre></td></tr></table></figure><p>以上这些差异，取决于函数在不同的的命名空间是否有映射。数组的大部分函数在顶层命名空间有映射，因此可以有两种用法。数组的一小部分函数，没有映射到顶层命名空间，只能有一种用法。而顶层命名空间的大部分函数，也都只有一种用法。下表整理出来的常用方法的和命名空间的关系，仅供参考。</p><table><thead><tr><th>顶层命名空间和数组对象均支持</th><th>仅数组对象均支持</th><th>仅顶层命名空间支持</th></tr></thead><tbody><tr><td>np/ndarray.any()/all()</td><td>ndarray.astype()</td><td>np.where()</td></tr><tr><td>np/ndarray.max()/min()</td><td>ndarray.fill()</td><td>np.stack()</td></tr><tr><td>np/ndarray.argsort()</td><td>ndarray.view()</td><td>np.rollaxis()</td></tr><tr><td>np/ndarray.mean()</td><td>ndarray.tolist()</td><td>np.sin()</td></tr></tbody></table><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>如果不熟悉 NumPy，Python 程序员一般都选择使用 math 模块来应对数学问题。从现在开始，我们可以放弃 math 模块了，因为 NumPy 的数学函数比 math 的更方便。我把这两个模块的数学函数整理了一下，分成 5 类，汇总在这里。其他诸如求和、求差、求积的函数，我把它们归类到统计函数。</p><ol><li>数学常数</li><li>舍入函数</li><li>快速转换函数</li><li>幂函数、指数函数和对数函数</li><li>部分三角函数。</li></ol><table><thead><tr><th>NumPy 函数</th><th>math 函数</th><th>功能</th></tr></thead><tbody><tr><td>np.e</td><td>math.e</td><td>自然常数</td></tr><tr><td>np.pi</td><td>math.pi</td><td>圆周率</td></tr><tr><td>np.ceil()</td><td>math.ceil()</td><td>进尾取整</td></tr><tr><td>np.floor()</td><td>nath.floor</td><td>去尾取整</td></tr><tr><td>np.around()</td><td></td><td>四舍五入到指定精度</td></tr><tr><td>np.rint()</td><td></td><td>四舍五入到最近整数</td></tr><tr><td>np.deg2rad()/radians()</td><td>math.radians</td><td>度转弧度</td></tr><tr><td>np.rad2deg()/degrees()</td><td>math.degrees()</td><td>弧度转度</td></tr><tr><td>np.hypot()</td><td>math.hypot()</td><td>计算直角三角形的斜边</td></tr><tr><td>np.square()</td><td></td><td>平方</td></tr><tr><td>np.sqrt()</td><td>math.sqrt()</td><td>开平方</td></tr><tr><td>np.power()</td><td>math.pow()</td><td>幂</td></tr><tr><td>np.exp()</td><td>math.exp()</td><td>指数</td></tr><tr><td>np.log()/log10()/log2()</td><td>math.log()/log10()/log2()</td><td>对数</td></tr><tr><td>np.sin()/arcsin()</td><td>math.sin()/asin()</td><td>正弦/反正弦</td></tr><tr><td>np.cos()/arccos()</td><td>math.cos()/acos()</td><td>余弦/反余弦</td></tr><tr><td>np.tan()/arctan()</td><td>math.tan()/atan()</td><td>正切/反正切</td></tr></tbody></table><h4 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h4><p>NumPy 的统计函数有很多，我整理了一下，大约可以分成 4 类：</p><ol><li>查找特殊值</li><li>求和差积</li><li>均值和方差</li><li>相关系数</li></ol><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>np.max/min(a, axis=None) np.nanmax/nanmin(a, axis=None)</td><td>返回数组中的最大值/最小值 忽略 nan 返回数组中的最大值/最小值</td></tr><tr><td>np.argmax/argmin(a, axis=None) np.nanargmax/nanargmin(a, axis=None)</td><td>返回数组中最大值和最小值的索引 忽略 nan 返回数组中最大值和最小值的索引</td></tr><tr><td>np.ptp(a, axis=None)</td><td>返回数组中元素最大值与最小值的差</td></tr><tr><td>np.median(a, axis=None) np.nanmedian(a, axis=None)</td><td>返回数组元素的中位数 忽略 nan 返回数组元素的中位数</td></tr><tr><td>np.sum(a, axis=None) np.nansum(a, axis=None)</td><td>按指定的轴求元素之和 忽略 nan 按指定的轴求元素之和</td></tr><tr><td>np.cumsum(a, axis=None) np.nancumsum(a, axis=None)</td><td>按指定的轴求元素的累进和 忽略 nan 按指定的轴求元素的累进和</td></tr><tr><td>np.diff(a, axis=-1)</td><td>按指定的轴返回相邻元素的差</td></tr><tr><td>np.prod(a, axis=None) np.nanprod(a, axis=None)</td><td>按指定的轴求元素之积 忽略 nan 按指定的轴求元素之积</td></tr><tr><td>np.mean(a, axis=None) np.nanmean(a, axis=None)</td><td>按指定的轴返回元素的算数平均值 忽略 nan 按指定的轴返回元素的算数平均值</td></tr><tr><td>np.average()</td><td>根据权重数据，返回数据数组所有元素的加权平均值</td></tr><tr><td>np.var(a) np.nanvar(a)</td><td>返回数组方差 忽略 nan 返回数组方差</td></tr><tr><td>np.std() np.nanstd()</td><td>返回数组标准差 忽略 nan 返回数组标准差</td></tr><tr><td>np.corrcoef(a, b)</td><td>返回两个数组的皮尔逊积矩相关系数</td></tr></tbody></table><h2 id="python-数据处理包——pandas"><a href="#python-数据处理包——pandas" class="headerlink" title="python 数据处理包——pandas"></a>python 数据处理包——pandas</h2><h3 id="pandas-介绍"><a href="#pandas-介绍" class="headerlink" title="pandas 介绍"></a>pandas 介绍</h3><p>Pandas 是基于 Numpy 的。但 Numpy 只能处理数字，若想处理其他类型的数据，如字符串等，就得依靠 Pandas。pandas 有两种数据类型，一维 Series 和二维 Dataframe,由于最常用的是 DataFrame 所以这边直接开始介绍 DataFrame</p><h3 id="pandas-下载"><a href="#pandas-下载" class="headerlink" title="pandas 下载"></a>pandas 下载</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda innstall pandas #conda安装</span><br><span class="line">pip install pandas #pip安装</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd<span class="comment">#导入pandas</span></span><br></pre></td></tr></table></figure><h3 id="dataframe-创建数据表"><a href="#dataframe-创建数据表" class="headerlink" title="dataframe 创建数据表"></a>dataframe 创建数据表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><p>DataFrame参数说明：</p><table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody><tr><td>data</td><td>一组数据</td></tr><tr><td>index</td><td>索引值，或者可以理解为行标签</td></tr><tr><td>columns</td><td>列标签</td></tr><tr><td>dtype</td><td>数据类型</td></tr><tr><td>copy</td><td>拷贝数据，默认是FALSE</td></tr></tbody></table><p>pandas 属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>df.shape</td><td>维度查看</td></tr><tr><td>df.info()</td><td>数据表基本信息（维度、列名称、数据格式、所占空间等）</td></tr><tr><td>df.dtypes</td><td>每一列数据的格式</td></tr><tr><td>index</td><td>索引</td></tr><tr><td>df.size</td><td>元素个数</td></tr><tr><td>df.values</td><td>查看数据表的值</td></tr><tr><td>df.columns</td><td>查看列名称</td></tr><tr><td>ndim</td><td>维度数</td></tr></tbody></table><p>pandas 读取文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(pd.read_csv(<span class="string">&#x27;name.csv&#x27;</span>,header=<span class="number">1</span>))<span class="comment">#读取csv</span></span><br><span class="line">df = pd.DataFrame(pd.read_excel(<span class="string">&#x27;name.xlsx&#x27;</span>))<span class="comment">#读取Excel</span></span><br><span class="line">df = pd.read_table(<span class="string">r&#x27;DATA.txt&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, index_col=<span class="number">0</span>)<span class="comment">#读取txt文本</span></span><br><span class="line">data.to_csv(<span class="string">&quot;地址&quot;</span>)<span class="comment">#保存csv文本文件</span></span><br><span class="line">data.to_excel(<span class="string">&quot;地址&quot;</span>)<span class="comment">#保存excel文本文件</span></span><br></pre></td></tr></table></figure><p>pandas 创建数据表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种：python中的字典生成</span></span><br><span class="line">employees = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;program language&#x27;</span>: [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>]&#125;</span><br><span class="line">emp_df = pd.DataFrame(employees)</span><br><span class="line"><span class="comment">#第二种： 利用指定的列内容、索引以及数据</span></span><br><span class="line">colums = [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>]</span><br><span class="line">dates = pd.date_range(<span class="string">&#x27;20190101&#x27;</span>, periods=<span class="number">6</span>)</span><br><span class="line">num_df = pd.DataFrame(data=np.random.randn(<span class="number">6</span>, <span class="number">3</span>), index=dates, columns=colums)</span><br><span class="line"><span class="comment">#第三种：利用pandas的series</span></span><br><span class="line">emp = pd.DataFrame.from_dict(</span><br><span class="line">    &#123;<span class="string">&#x27;age&#x27;</span>: pd.Series([<span class="number">23</span>,<span class="number">43</span>,<span class="number">23</span>,<span class="number">25</span>], index=[<span class="string">&#x27;shawn&#x27;</span>,<span class="string">&#x27;olivia&#x27;</span>, <span class="string">&#x27;Gene&#x27;</span>, <span class="string">&#x27;Herry&#x27;</span>]),</span><br><span class="line">       <span class="string">&#x27;gender&#x27;</span>: pd.Series([<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;female&#x27;</span>], index=[<span class="string">&#x27;shawn&#x27;</span>,<span class="string">&#x27;olivia&#x27;</span>, <span class="string">&#x27;Gene&#x27;</span>, <span class="string">&#x27;Herry&#x27;</span>]),</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="comment">#第四种利用列表构建</span></span><br><span class="line">name = [<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;krish&#x27;</span>, <span class="string">&#x27;nick&#x27;</span>, <span class="string">&#x27;juli&#x27;</span>]  </span><br><span class="line">age = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">22</span>]  </span><br><span class="line"><span class="comment">#[(&#x27;tom&#x27;, 25), (&#x27;krish&#x27;, 30), (&#x27;nick&#x27;, 26), (&#x27;juli&#x27;, 22)]</span></span><br><span class="line">emp_df = pd.DataFrame(<span class="built_in">list</span>(<span class="built_in">zip</span>(name, age)), columns = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]) </span><br><span class="line"><span class="comment">#第五种利用ndarray创建DataFrame</span></span><br><span class="line"><span class="comment">#普通创建</span></span><br><span class="line">&gt;&gt;&gt; data = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; df = pd.DataFrame(data)</span><br><span class="line"><span class="comment">#设置列名创建</span></span><br><span class="line">&gt;&gt;&gt; data = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; df = pd.DataFrame(data, columns=<span class="built_in">list</span>(<span class="string">&quot;ABC&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="列索引操作"><a href="#列索引操作" class="headerlink" title="列索引操作"></a>列索引操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">创建数据</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj.head())</span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.781380</span> -<span class="number">1.074496</span> -<span class="number">1.448204</span> -<span class="number">0.313385</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.568288</span>  <span class="number">2.011669</span>  <span class="number">0.955440</span>  <span class="number">1.617713</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.222755</span> -<span class="number">1.507924</span> -<span class="number">0.903779</span>  <span class="number">1.301956</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.706442</span> -<span class="number">0.503069</span> -<span class="number">1.561416</span> -<span class="number">0.290718</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.071889</span> -<span class="number">0.280071</span> -<span class="number">2.033153</span>  <span class="number">1.618598</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 读取单列  传入列的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj[<span class="string">&#x27;a&#x27;</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 读取多列 不连续索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 添加新列，直接进行赋值操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj[<span class="string">&#x27;e&#x27;</span>] = pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br><span class="line"><span class="comment">#insert(索引位置,columns=&#x27;列名&#x27;,value=&#x27;值&#x27;) 插入新列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj.insert(<span class="number">1</span>, column=<span class="string">&#x27;f&#x27;</span>, value=[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])  <span class="comment"># 插入一列为不同数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj)</span><br><span class="line">          a   f         b         c         d   e</span><br><span class="line"><span class="number">0</span>  <span class="number">1.520003</span>  <span class="number">10</span>  <span class="number">0.375014</span>  <span class="number">0.059027</span>  <span class="number">1.171379</span>  <span class="number">10</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.099122</span>  <span class="number">20</span>  <span class="number">0.096940</span> -<span class="number">0.189679</span> -<span class="number">0.046981</span>  <span class="number">20</span></span><br><span class="line"><span class="number">2</span> -<span class="number">2.270308</span>  <span class="number">30</span> -<span class="number">0.759622</span>  <span class="number">0.660129</span> -<span class="number">1.017288</span>  <span class="number">30</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.010634</span>  <span class="number">40</span>  <span class="number">1.456483</span> -<span class="number">0.741796</span> -<span class="number">0.280938</span>  <span class="number">40</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.120968</span>  <span class="number">50</span>  <span class="number">1.077172</span> -<span class="number">1.616609</span> -<span class="number">1.069243</span>  <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj.insert(<span class="number">1</span>, column=<span class="string">&#x27;g&#x27;</span>, value=<span class="number">111</span>)  <span class="comment"># 插入一列为相同数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj)</span><br><span class="line">          a    g   f         b         c         d   e</span><br><span class="line"><span class="number">0</span>  <span class="number">1.520003</span>  <span class="number">111</span>  <span class="number">10</span>  <span class="number">0.375014</span>  <span class="number">0.059027</span>  <span class="number">1.171379</span>  <span class="number">10</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.099122</span>  <span class="number">111</span>  <span class="number">20</span>  <span class="number">0.096940</span> -<span class="number">0.189679</span> -<span class="number">0.046981</span>  <span class="number">20</span></span><br><span class="line"><span class="number">2</span> -<span class="number">2.270308</span>  <span class="number">111</span>  <span class="number">30</span> -<span class="number">0.759622</span>  <span class="number">0.660129</span> -<span class="number">1.017288</span>  <span class="number">30</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.010634</span>  <span class="number">111</span>  <span class="number">40</span>  <span class="number">1.456483</span> -<span class="number">0.741796</span> -<span class="number">0.280938</span>  <span class="number">40</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.120968</span>  <span class="number">111</span>  <span class="number">50</span>  <span class="number">1.077172</span> -<span class="number">1.616609</span> -<span class="number">1.069243</span>  <span class="number">50</span></span><br><span class="line"><span class="comment">#删除列 del()或者pop()都可以删除列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> df_obj[<span class="string">&#x27;f&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj.pop(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="索引读取数据操作"><a href="#索引读取数据操作" class="headerlink" title="索引读取数据操作"></a>索引读取数据操作</h3><table><thead><tr><th>操作</th><th>语法</th><th>结果</th></tr></thead><tbody><tr><td>选择列</td><td><code>df[col]</code>或<code>df.col</code></td><td><code>Series</code></td></tr><tr><td>按列值选择行</td><td><code>df.loc[label]</code></td><td><code>Series</code></td></tr><tr><td>按整数位置选择行</td><td><code>df.iloc[loc]</code></td><td><code>Series</code></td></tr><tr><td>对行切片</td><td><code>df[5:10]</code></td><td><code>DataFrame</code></td></tr><tr><td>按布尔向量选择行</td><td><code>df[bool_vec]</code></td><td><code>DataFrame</code></td></tr></tbody></table><p><strong>注意：loc区间是左闭右闭，iloc是左闭右开</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#标签索引 dataframe不能直接进行切片，可以通过loc来做切片，loc是基于标签名的索引，也就是我们定义的列值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 第一个参数索引行，第二个参数是列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj.loc[<span class="number">0</span>:<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="number">0</span>    <span class="number">0.237575</span></span><br><span class="line"><span class="number">1</span>    <span class="number">0.294029</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.151643</span></span><br><span class="line">Name: a, dtype: float64</span><br><span class="line"><span class="comment">#位置索引 作用和loc一样，不过是基于索引编号来索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj.iloc[<span class="number">0</span>:<span class="number">2</span>, <span class="number">0</span>]) </span><br><span class="line"><span class="number">0</span>    <span class="number">0.237575</span></span><br><span class="line"><span class="number">1</span>    <span class="number">0.294029</span></span><br><span class="line">Name: a, dtype: float64</span><br><span class="line"> <span class="comment">#切片索引  行索引，取前两行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj[<span class="number">0</span>:<span class="number">2</span>])  <span class="comment"># 左闭右开</span></span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span> -<span class="number">0.008962</span> -<span class="number">1.440611</span> -<span class="number">0.241749</span> -<span class="number">0.328990</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.722666</span> -<span class="number">0.968137</span>  <span class="number">0.752607</span>  <span class="number">0.060432</span></span><br><span class="line"><span class="comment">#添加行  append()函数可以把新的DataFrame对象追加到原对象后面，在行末尾再追加</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj1 = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]], columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj1)</span><br><span class="line">   a  b  c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj = df_obj.append(df_obj1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj)</span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span> -<span class="number">0.214975</span> -<span class="number">1.574176</span>  <span class="number">0.005630</span>  <span class="number">0.372708</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.951436</span>  <span class="number">0.725618</span>  <span class="number">1.275498</span>  <span class="number">2.072770</span></span><br><span class="line"><span class="number">2</span> -<span class="number">1.739804</span> -<span class="number">0.375916</span> -<span class="number">0.588529</span> -<span class="number">0.045825</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.048349</span> -<span class="number">0.015041</span>  <span class="number">0.953475</span>  <span class="number">1.369060</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.515951</span> -<span class="number">1.453001</span>  <span class="number">0.921479</span> -<span class="number">0.338588</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.000000</span>  <span class="number">2.000000</span>  <span class="number">3.000000</span>  <span class="number">4.000000</span></span><br><span class="line"><span class="comment">#删除行  使用drop(索引)即可删除指定行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj = df_obj.drop(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_obj = df_obj.drop(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(df_obj)</span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">2</span> -<span class="number">1.739804</span> -<span class="number">0.375916</span> -<span class="number">0.588529</span> -<span class="number">0.045825</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.048349</span> -<span class="number">0.015041</span>  <span class="number">0.953475</span>  <span class="number">1.369060</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.515951</span> -<span class="number">1.453001</span>  <span class="number">0.921479</span> -<span class="number">0.338588</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据的修改和查找"><a href="#数据的修改和查找" class="headerlink" title="数据的修改和查找"></a>数据的修改和查找</h3><p>用 rename 修改行标签或者列名称。<br>直接用 df.series 同==,&gt;,&lt;等逻辑运算符获取满足特定关系的 df 数据<br>也可以用 between、isin 方法获取在之间，匹配某些数量的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.rename(columns = &#123;<span class="string">&#x27;user_id&#x27;</span>:<span class="string">&#x27;用户ID&#x27;</span>&#125;)<span class="comment">#用rename修改列标签，使用字典的形式；</span></span><br><span class="line">data.rename(index = &#123;<span class="number">1</span>:<span class="number">11</span>, <span class="number">2</span>:<span class="number">22</span>&#125;, inplace = <span class="literal">True</span>)<span class="comment">#用rename修改行标签，使用字典的形式；</span></span><br><span class="line"><span class="comment">#DataFrame.loc[行索引名称或条件, 列索引名称] = new_value</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">&#x27;性别&#x27;</span>] == <span class="number">0</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;女性&#x27;</span><span class="comment">#data[&#x27;性别&#x27;] == 0为行索引,&#x27;性别&#x27;为列索引</span></span><br><span class="line">data.loc[data[<span class="string">&#x27;性别&#x27;</span>] == <span class="number">1</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;男性&#x27;</span> </span><br><span class="line">data.loc[data[<span class="string">&#x27;性别&#x27;</span>] == <span class="number">2</span>, <span class="string">&#x27;性别&#x27;</span>] = <span class="string">&#x27;未知&#x27;</span></span><br><span class="line"></span><br><span class="line">data[data[<span class="string">&#x27;buy_mount&#x27;</span>]&gt;<span class="number">80</span>]<span class="comment">#获取名称为&#x27;buy_mount&#x27;列的数据中大于80的数据,通过行索引获得</span></span><br><span class="line"><span class="built_in">print</span>(data[(data[<span class="string">&#x27;buy_mount&#x27;</span>] &lt; <span class="number">80</span>) &amp; (data[<span class="string">&#x27;性别&#x27;</span>] == <span class="string">&#x27;男性&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>(data[data[<span class="string">&#x27;buy_mount&#x27;</span>].isin([<span class="number">80</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">98</span>])])<span class="comment">#buy_mount 列数值属于list[80, 88, 89, 90]的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dataframe-运算操作"><a href="#dataframe-运算操作" class="headerlink" title="dataframe 运算操作"></a>dataframe 运算操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1+df2 <span class="comment">#df1和df2相加。结构必须相同</span></span><br><span class="line">df * <span class="number">5</span> + <span class="number">2</span> <span class="comment">#每个元素乘5加2</span></span><br><span class="line"><span class="number">1</span> / df  <span class="comment">#1除以df里面每个元素</span></span><br><span class="line">df ** <span class="number">4</span> <span class="comment">#df每个元素镜像四次幂运算</span></span><br><span class="line">df1 &amp; df2 <span class="comment">#dataframe对应位置可以做布尔运算</span></span><br><span class="line">df.T <span class="comment">#和ndarray一样，要进行转置，访问T属性或者调用DataFrame.transpose()方法</span></span><br></pre></td></tr></table></figure><h3 id="数据统计与排序"><a href="#数据统计与排序" class="headerlink" title="数据统计与排序"></a>数据统计与排序</h3><p>数据统计信息显示采用 discribe()方法；<br>数据排序使用:<br>df. sort_values(by, axis=0, ascending=True, inplace=False, kind=‘quicksort’, na_position=‘last’),基于某几行或列的值进行排列。<br>df. sort_index(axis=0, level=None, ascending=True, inplace=False, kind=‘quicksort’, na_position=‘last’, sort_remaining=True, by=None)，基于行或列标签进行排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df1.describe())<span class="comment">#只对数字类参数有用，输出每一列的均值、标准差、最大、最小值和25%/50%/75%的值</span></span><br><span class="line"><span class="built_in">print</span>(df1.sort_index(axis = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(df1.sort_values(by = [<span class="string">&#x27;Bid_Count&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>]))<span class="comment">#根据指定的列名称及其优先级顺序，对整个列表进行排序。</span></span><br></pre></td></tr></table></figure><h3 id="DataFrame-与-NumPy-函数的互操作"><a href="#DataFrame-与-NumPy-函数的互操作" class="headerlink" title="DataFrame 与 NumPy 函数的互操作"></a>DataFrame 与 NumPy 函数的互操作</h3><p>大多数 NumPy 函数可以在<code>Series</code>和<code>DataFrame</code>上直接调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">abs</span>(df)<span class="comment">#求取df里面每个绝对值</span></span><br><span class="line">np.asarray(df) <span class="comment">#把df转换成数组</span></span><br></pre></td></tr></table></figure><p>当传递两个 pandas 对象给 NumPy 函数时，会先进行对齐再执行函数操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser1 = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">ser2 = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">np.remainder(ser1, ser2) <span class="comment">#ser1%ser2</span></span><br></pre></td></tr></table></figure><p>与<code>Series</code>一样，可以使用<code>DataFrame.to_numpy()</code>方法获得相应的 ndarray</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_numpy()</span><br></pre></td></tr></table></figure><h3 id="数据表清洗"><a href="#数据表清洗" class="headerlink" title="数据表清洗"></a>数据表清洗</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value=<span class="number">0</span>)<span class="comment">#用数字0填充空值</span></span><br><span class="line">df[<span class="string">&#x27;prince&#x27;</span>].fillna(df[<span class="string">&#x27;prince&#x27;</span>].mean()) <span class="comment">#使用列prince的均值对NA进行填充</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>]=df[<span class="string">&#x27;city&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">str</span>.strip) <span class="comment">#清除city字段的字符空格</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>]=df[<span class="string">&#x27;city&#x27;</span>].<span class="built_in">str</span>.lower() <span class="comment">#大小写转换</span></span><br><span class="line">df[<span class="string">&#x27;price&#x27;</span>].astype(<span class="string">&#x27;int&#x27;</span>)  <span class="comment">#更改数据格式，可以把标签变量变成数字变量</span></span><br><span class="line">df.rename(columns=&#123;<span class="string">&#x27;category&#x27;</span>: <span class="string">&#x27;category-size&#x27;</span>&#125;) <span class="comment">#更改列名称</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>].drop_duplicates()<span class="comment">#删除后出现的重复值</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>].drop_duplicates(keep=<span class="string">&#x27;last&#x27;</span>)<span class="comment">#删除先出现的重复值</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>].replace(<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>)<span class="comment">#数据替换</span></span><br></pre></td></tr></table></figure><p>pandas库基于NumPy，自然也可以用这些函数对数据框进行描述性统计。pandas还提供了更加便利的方法来计算均值</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>min</td><td>最小值</td><td>max</td><td>最大值</td></tr><tr><td>mean</td><td>均值</td><td>ptp</td><td>极差</td></tr><tr><td>median</td><td>中位数</td><td>std</td><td>标准差</td></tr><tr><td>var</td><td>方差</td><td>cov</td><td>协方差</td></tr><tr><td>sem</td><td>标准误差</td><td>mode</td><td>众数</td></tr><tr><td>skew</td><td>样本偏度</td><td>kurt</td><td>样本峰度</td></tr><tr><td>quantile</td><td>四分位数</td><td>count</td><td>非空值数目</td></tr><tr><td>describe</td><td>描述统计</td><td>mad</td><td>平均绝对离差</td></tr></tbody></table><h3 id="数据表合并"><a href="#数据表合并" class="headerlink" title="数据表合并"></a>数据表合并</h3><p>merge</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_inner=pd.merge(df,df1,how=<span class="string">&#x27;inner&#x27;</span>)  <span class="comment"># 匹配合并，交集</span></span><br><span class="line">df_left=pd.merge(df,df1,how=<span class="string">&#x27;left&#x27;</span>)        <span class="comment">#</span></span><br><span class="line">df_right=pd.merge(df,df1,how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">df_outer=pd.merge(df,df1,how=<span class="string">&#x27;outer&#x27;</span>)  <span class="comment">#并集</span></span><br></pre></td></tr></table></figure><p>append</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = df1.append(df2)  <span class="comment">#进行行合并 并且添加在最后一行</span></span><br></pre></td></tr></table></figure><p>join</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = left.join(right, on=<span class="string">&#x27;key&#x27;</span>) <span class="comment">#进行列合并</span></span><br></pre></td></tr></table></figure><p>concat</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>,</span><br><span class="line">          keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>,</span><br><span class="line">          copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择</li><li>（见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。</li><li>axis: {0，1，…}，默认值为 0。要连接沿轴。</li><li>join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。</li><li>ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记</li><li>0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。</li><li>join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部/外部设置逻辑。 keys︰</li><li>序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。</li><li>levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。</li><li>names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。</li><li>verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。</li><li>副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。</li></ul><h3 id="数据汇总"><a href="#数据汇总" class="headerlink" title="数据汇总"></a>数据汇总</h3><h4 id="使用groupby方法拆分数据。"><a href="#使用groupby方法拆分数据。" class="headerlink" title="使用groupby方法拆分数据。"></a>使用groupby方法拆分数据。</h4><p>用groupby方法分组后的结果并不能直接查看，而是被存在内存中，输出的是内存地址。实际上分组后的数据对象GroupBy类似Series与DataFrame，是pandas提供的一种对象。GroupBy对象常用的描述性统计方法如下。</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>count</td><td>计算分组的数目，包括缺失值。</td><td>cumcount</td><td>对每个分组中组员的进行标记，0至n-1。</td></tr><tr><td>head</td><td>返回每组的前n个值。</td><td>size</td><td>返回每组的大小。</td></tr><tr><td>max</td><td>返回每组最大值。</td><td>min</td><td>返回每组最小值。</td></tr><tr><td>mean</td><td>返回每组的均值。</td><td>std</td><td>返回每组的标准差。</td></tr><tr><td>median</td><td>返回每组的中位数。</td><td>sum</td><td>返回每组的和。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">dict_obj = &#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;data1&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">            <span class="string">&#x27;data2&#x27;</span>: np.random.randn(<span class="number">8</span>)&#125;</span><br><span class="line">df_obj = pd.DataFrame(dict_obj)</span><br><span class="line"><span class="comment"># dataframe根据key1进行分组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df_obj.groupby(<span class="string">&#x27;key1&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataframe的 data1 列根据 key1 进行分组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df_obj[<span class="string">&#x27;data1&#x27;</span>].groupby(df_obj[<span class="string">&#x27;key1&#x27;</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GroupBy对象支持迭代操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单层分组，根据key1</span></span><br><span class="line"><span class="keyword">for</span> group_name, group_data <span class="keyword">in</span> grouped1:</span><br><span class="line">    <span class="built_in">print</span>(group_name)</span><br><span class="line">    <span class="built_in">print</span>(group_data)</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1   key2</span><br><span class="line"><span class="number">0</span>  <span class="number">0.974685</span> -<span class="number">0.672494</span>    a    one</span><br><span class="line"><span class="number">2</span>  <span class="number">1.508838</span>  <span class="number">0.392787</span>    a    two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.347359</span> -<span class="number">0.177858</span>    a    two</span><br><span class="line"><span class="number">6</span> -<span class="number">0.624708</span>  <span class="number">0.450885</span>    a    one</span><br><span class="line"><span class="number">7</span> -<span class="number">1.019229</span> -<span class="number">1.143825</span>    a  three</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">      data1     data2 key1   key2</span><br><span class="line"><span class="number">1</span> -<span class="number">0.214324</span>  <span class="number">0.758372</span>    b    one</span><br><span class="line"><span class="number">3</span>  <span class="number">0.522911</span>  <span class="number">0.630814</span>    b  three</span><br><span class="line"><span class="number">5</span> -<span class="number">0.264616</span>  <span class="number">1.017155</span>    b    two</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多层分组，根据key1 和 key2</span></span><br><span class="line"><span class="keyword">for</span> group_name, group_data <span class="keyword">in</span> grouped2:</span><br><span class="line">    <span class="built_in">print</span>(group_name)</span><br><span class="line">    <span class="built_in">print</span>(group_data)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span>  <span class="number">0.974685</span> -<span class="number">0.672494</span>    a  one</span><br><span class="line"><span class="number">6</span> -<span class="number">0.624708</span>  <span class="number">0.450885</span>    a  one</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;three&#x27;</span>)</span><br><span class="line">      data1     data2 key1   key2</span><br><span class="line"><span class="number">7</span> -<span class="number">1.019229</span> -<span class="number">1.143825</span>    a  three</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span>  <span class="number">1.508838</span>  <span class="number">0.392787</span>    a  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.347359</span> -<span class="number">0.177858</span>    a  two</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">1</span> -<span class="number">0.214324</span>  <span class="number">0.758372</span>    b  one</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;three&#x27;</span>)</span><br><span class="line">      data1     data2 key1   key2</span><br><span class="line"><span class="number">3</span>  <span class="number">0.522911</span>  <span class="number">0.630814</span>    b  three</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">5</span> -<span class="number">0.264616</span>  <span class="number">1.017155</span>    b  two</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GroupBy可以转换成列表或者字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GroupBy对象转换list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(grouped1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># GroupBy对象转换dict</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">list</span>(grouped1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用agg方法聚合数据"><a href="#使用agg方法聚合数据" class="headerlink" title="使用agg方法聚合数据"></a>使用agg方法聚合数据</h4><p>agg，aggregate方法都支持对每个分组应用某函数，包括Python内置函数或自定义函数。同时这两个方法能够也能够直接对DataFrame进行函数应用操作。</p><p>在正常使用过程中，agg函数和aggregate函数对DataFrame对象操作时功能几乎完全相同，因此只需要掌握其中一个函数即可。它们的参数说明如下表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.agg(func, axis=<span class="number">0</span>, *args, **kwargs)</span><br><span class="line">DataFrame.aggregate(func, axis=<span class="number">0</span>, *args, **kwargs</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>func</td><td>接收list、dict、function。表示应用于每行／每列的函数。无默认。</td></tr><tr><td>axis</td><td>接收0或1。代表操作的轴向。默认为0。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以使用agg方法一次求出当前数据中所有菜品销量和售价的总和与均值</span></span><br><span class="line">detail[[<span class="string">&#x27;counts&#x27;</span>,<span class="string">&#x27;amounts&#x27;</span>]].agg([np.<span class="built_in">sum</span>,np.mean]))</span><br><span class="line"><span class="comment">#对于某个字段希望只做求均值操作，而对另一个字段则希望只做求和操作，可以使用字典的方式，将两个字段名分别作为key，然后将NumPy库的求和与求均值的函数分别作为value</span></span><br><span class="line">detail.agg(&#123;<span class="string">&#x27;counts&#x27;</span>:np.<span class="built_in">sum</span>,<span class="string">&#x27;amounts&#x27;</span>:np.mean&#125;))</span><br><span class="line"><span class="comment">#在某些时候还希望求出某个字段的多个统计量，某些字段则只需要求一个统计量，此时只需要将字典对应key的value变为列表，列表元素为多个目标的统计量即可</span></span><br><span class="line">detail.agg(&#123;<span class="string">&#x27;counts&#x27;</span>:np.<span class="built_in">sum</span>,<span class="string">&#x27;amounts&#x27;</span>:[np.mean,np.<span class="built_in">sum</span>]&#125;))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;在agg方法可传入自定义的函数。</span></span><br><span class="line"><span class="string">使用自定义函数需要注意的是NumPy库中的函数np.mean，np.median，np.prod，np.sum，np.std，np.var能够在agg中直接使用，但是在自定义函数中使用NumPy库中的这些函数，如果计算的时候是单个序列则会无法得出想要的结果，如果是多列数据同时计算则不会出现这种问题。</span></span><br><span class="line"><span class="string">使用agg方法能够实现对每一个字段每一组使用相同的函数。</span></span><br><span class="line"><span class="string">如果需要对不同的字段应用不同的函数，则可以和Dataframe中使用agg方法相同。&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="使用apply方法聚合数据"><a href="#使用apply方法聚合数据" class="headerlink" title="使用apply方法聚合数据"></a>使用apply方法聚合数据</h4><p>apply方法类似agg方法能够将函数应用于每一列。不同之处在于apply方法相比agg方法传入的函数只能够作用于整个DataFrame或者Series，而无法像agg一样能够对不同字段，应用不同函数获取不同结果。<br>使用apply方法对GroupBy对象进行聚合操作其方法和agg方法也相同，只是使用agg方法能够实现对不同的字段进行应用不同的函数，而apply则不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.apply(func, axis=<span class="number">0</span>, broadcast=<span class="literal">False</span>, raw=<span class="literal">False</span>, reduce=<span class="literal">None</span>, args=(), **kwds)</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>func</td><td>接收functions。表示应用于每行／列的函数。无默认。</td></tr><tr><td>axis</td><td>接收0或1。代表操作的轴向。默认为0。</td></tr><tr><td>broadcast</td><td>接收boolearn。表示是否进行广播。默认为False。</td></tr><tr><td>raw</td><td>接收boolearn。表示是否直接将ndarray对象传递给函数。默认为False。</td></tr><tr><td>reduce</td><td>接收boolearn或者None。表示返回值的格式。默认None。</td></tr></tbody></table><h4 id="使用transform方法聚合数据"><a href="#使用transform方法聚合数据" class="headerlink" title="使用transform方法聚合数据"></a>使用transform方法聚合数据</h4><ul><li>transform方法能够对整个DataFrame的所有元素进行操作。且transform方法只有一个参数“func”，表示对DataFrame操作的函数。</li><li>同时transform方法还能够对DataFrame分组后的对象GroupBy进行操作，可以实现组内离差标准化等操作。</li><li>若在计算离差标准化的时候结果中有NaN，这是由于根据离差标准化公式，最大值和最小值相同的情况下分母是0。而分母为0的数在Python中表示为NaN。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">数据预处理</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://example.com/2022/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-21T07:00:00.000Z</published>
    <updated>2022-12-07T08:19:18.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p><strong>本文介绍机器学习算法，全文采用python代码去写且使用numpy,pandas以及matplotlib。机器学习算法采用sklearn框架去写，本文也会介绍机器学习框架的算法。如果基础不好的同学请移步去学习python基础。</strong></p><h1 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h1><p><strong>维基百科：</strong></p><p>机器学习是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与统计推断学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。很多推论问题属于无程序可循难度，所以部分的机器学习研究是开发容易处理的近似算法。</p><p><strong>网络教学信息</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">斯坦福机器学习</span><br><span class="line">http://v.163.com/special/opencourse/machinelearning.html</span><br><span class="line">CMU 机器学习课程</span><br><span class="line">http://www.cs.cmu.edu/~epxing/Class/10715/  </span><br><span class="line">http://www.cs.cmu.edu/~epxing/Class/10708/  视频</span><br><span class="line">http://www.cs.cmu.edu/~epxing/Class/10701</span><br><span class="line">https://sites.google.com/site/10601a14spring/syllabus </span><br><span class="line">http://wenku.baidu.com/course/view/49e8b8f67c1cfad6195fa705</span><br></pre></td></tr></table></figure><p><strong>相关学术文章下载资源</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLT和ICML(每年度的官网): http://www.cs.mcgill.ca/~colt2009/proceedings.html</span><br><span class="line">CV:http://www.cvpapers.com/index.html; </span><br><span class="line"><span class="attribute">NIPS</span><span class="punctuation">: </span>http://books.nips.cc/; </span><br><span class="line">JMLR(期刊): http://jmlr.csail.mit.edu/papers/;  </span><br></pre></td></tr></table></figure><p><strong>机器学习的定义</strong></p><p>机器学习有下面几种定义：<br>“机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能”。<br>“机器学习是对能通过经验自动改进的计算机算法的研究”。<br>“机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。”<br>英文定义：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</p><p><strong>机器学习的应用</strong></p><ul><li>数据挖掘</li><li>计算机视觉</li><li>自然语言处理</li><li>生物特征识别</li><li>搜索引擎</li><li>医学诊断</li><li>检测信用卡欺诈</li><li>证券市场分析</li><li>DNA序列测序</li><li>语音和手写识别</li><li>战略游戏</li><li>机器人</li></ul><p><strong>机器学习新的方向</strong></p><ul><li>集成学习</li><li>可扩展机器学习（对大数据集、高维数据的学习等）</li><li>强化学习</li><li>迁移学习</li><li>概率网络</li><li>深度学习</li></ul><p><strong>机器学习和数据挖掘的关系</strong></p><ul><li>机器学习是数据挖掘的重要工具。</li><li>数据挖掘不仅仅要研究、拓展、应用一些机器学习方法，还要通过许多非机器学习技术解决数据仓储、大规模数据、数据噪音等等更为实际的问题。</li><li>机器学习的涉及面更宽，常用在数据挖掘上的方法通常只是“从数据学习”，然则机器学习不仅仅可以用在数据挖掘上，一些机器学习的子领域甚至与数据挖掘关系不大，例如增强学习与自动控制等等。</li><li>数据挖掘试图从海量数据中找出有用的知识。</li><li>大体上看，数据挖掘可以视为机器学习和数据库的交叉，它主要利用机器学习界提供的技术来分析海量数据，利用数据库界提供的技术来管理海量数据。</li></ul><p><strong>机器学习相关学术期刊和会议</strong></p><p><strong>机器学习</strong><br>    学术会议：NIPS、ICML、ECML和COLT，<br>    学术期刊：《Machine Learning》和《Journal of Machine Learning Research》<br><strong>数据挖掘</strong><br>    学术会议：SIGKDD、ICDM、SDM、PKDD和PAKDD<br>    学术期刊：《Data Mining and Knowledge Discovery》和《IEEE Transactions on Knowledge and Data Engineering》<br><strong>人工智能</strong><br>    学术会议：IJCAI和AAAI、<br><strong>数据库</strong><br>    学术会议：SIGMOD、VLDB、ICDE，<br><strong>其它一些顶级期刊如</strong><br>    《Artificial Intelligence》、<br>    《Journal of Artificial Intelligence Research》、<br>    《IEEE Transactions on Pattern Analysis and Machine Intelligence》、<br>    《Neural Computation》等也经常发表机器学习和数据挖掘方面的论文</p><h1 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h1><p>统计学习或机器学习一般包括<strong>监督学习</strong>、<strong>无监督学习</strong>、<strong>强化学习</strong>。有时还包括<strong>半监督学习</strong>、<strong>主动学习</strong>。</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>  <strong>监督学习（supervised learning）</strong> 是指从<strong>标注数据</strong>中学习预测模型的机器学习问题。<strong>标注数据</strong>表示输入输出的对应关系，<strong>预测模型</strong>对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律。</p><p>（1）<strong>输入空间、输出空间和特征空间：</strong><br>          输入空间：输入所有可能取值的集合<br>          输出空间：输出所有可能取值的集合<br>          特征空间：所有特征向量存在的空间<br>  <strong>注1：</strong>输入与输出空间可以是有限元素的集合，也可以是整个欧式空间；输入空间与输出空间可以是同一个空间，也可以是不同的空间；通常输出空间远远小于输入空间。<br>  <strong>注2：</strong>特征空间的每一维对应一个特征。有时假设输入空间与特征空间为相同的空间，对它们不予区分；有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间。<br>（2）<strong>联合概率分布</strong><br>  监督学习假设输入与输出的随机变量X 和Y 遵循联合概率分布P ( X , Y ) 。P ( X , Y ) 表示分布函数，或分布密度函数。<br>  统计学习假设数据存在一定的统计规律，训练数据与测试数据被看作是依联合概率分布P ( X , Y ) 独立同分布产生的。<br>（3）<strong>假设空间</strong><br>  模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间也即意味着监督学习所要学习的范围。<br>（4）<strong>问题的形式化</strong><br>  监督学习分为学习和预测两个过程，由学习系统与预测系统共同完成。<br><img src="https://img-blog.csdnimg.cn/c8c90cfa48474a92b6c61d157376e940.png#pic_center" alt="img"></p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 无监督学习（unsupervised learning） 是指从无标注数据中学习预测模型的机器学习问题。无标注数据是自然得到的数据，预测模型表示数据的类别、转换或概率。无监督学习的本质是学习数据中的统计规律或潜在结构。<br>  无监督学习可用于对已有数据的分析，也可用于对未来数据的预测。它和监督学习有类似的流<br><img src="https://img-blog.csdnimg.cn/d4ffd967656844ad93ba49b905ebe50d.png#pic_center" alt="img"></p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>​        <strong>强化学习（reinforcement learning）</strong> 是指<strong>智能系统与环境的连续互动</strong>中学习最优行为策略的机器学习问题。强化学习的本质是学习最优的序贯决策。<br>  强化学习过程中，<code>智能系统不断地试错，以达到学习最优策略的目的</code>。智能系统与环境的互动如图所示</p><p><img src="https://img-blog.csdnimg.cn/2bed1450aac74b85854540d424e3d58b.png#pic_center" alt="img"></p><h2 id="半监督学习与主动学习"><a href="#半监督学习与主动学习" class="headerlink" title="半监督学习与主动学习"></a>半监督学习与主动学习</h2><p>​        <strong>半监督学习（semi-supervised learning）</strong> 是指利用标注数据和未标注数据学习预测模型的机器学习问题。半监督学习旨在利用未标注数据中的信息，辅助标注数据进行监督学习，以较低的成本达到较好的学习效果。<br>  <strong>主动学习（active learning）</strong> 是指机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。主动学习旨在找出对学习最有帮助的实例让教师标注，以较小的标注代价，达到较好的学习效果。</p><h1 id="机器学习方法三要素"><a href="#机器学习方法三要素" class="headerlink" title="机器学习方法三要素"></a>机器学习方法三要素</h1><p>机器学习方法由<strong>模型</strong>、<strong>策略</strong>和<strong>算法</strong>三要素构成</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>​        机器学习首要考虑的问题是学习什么样的模型。在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>​        有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。<br>（1）损失函数和风险函数<br>  损失函数：度量模型一次预测的好坏<br>  风险函数：度量平均意义下模型预测的好坏<br>由于模型的输入、输出( X , Y ) 是随机变量，遵循联合分布P ( X , Y ) ，所以损失函数的期望是：</p><p><img src="https://raw.githubusercontent.com/446773160/Picbed/main/blog_images20221021181635.png" alt="img"></p><p>​        这是理论模型f ( X )关于联合分布P ( X , Y ) 的平均意义下的损失，称为风险函数或期望损失。<br>实际上，联合分布P ( X , Y )是未知的，因为Rexp(f)是不能直接计算的，但根据大数定律，当样本容量N趋于无穷时，经验风险Remp(f)趋于期望风险Rexp(f)<strong>。</strong> 因为很自然的一个想法，即用经验风险估计期望风险。模型f ( X ) 关于训练数据集的平均损失即为经验风险或经验损失，记作Remp</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021182719.png?raw=true" alt="blog_images20221021182719.png"></p><p>但由于现实中训练样本数目有限，所以用经验风险估计期望风险常常并不理想，要对经验风险进行一定的矫正。</p><p>（2）经验风险最小化与结构风险最小化<br>  为了求解到最优的模型，在监督学习中经常采用经验风险最小化和结构风险最小化这两个基本策略来选择模型。<br>  经验风险最小化（empirical risk minimization,ERM） 的策略认为，经验风险最小的模型即最优的模型，上述问题可转化为求解如下的最优化问题：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021183729.png?raw=true" alt="blog_images20221021183729.png"></p><p>注：F是假设空间<br>  当样本容量足够大时，经验风险最小化能保证有很好的学习效果。但是，当样本容量很小时，经验风险最小化学习的效果未必很好，会产生“过拟合”现象。<br>  结构风险最小化（structural risk minimization,SRM） 即为了防止过拟合而提出的策略。其通过在经验风险基础上加上表示模型复杂度的正则化项或惩罚项，在本质上等价于正则化。结构风险可定义如下：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021183729.png?raw=true" alt="blog_images20221021183729.png"></p><p>注：J(f)为模型的复杂度，是定义在假设空间F上的泛函<br>  结构风险最小化策略认为结构风险最小的模型是最优的模型，所以求最优模型就是求解最优化问题：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021183928.png?raw=true" alt="blog_images20221021183928.png"></p><p>     综上，监督学习问题就变成了经验风险或结构风险函数的最优化问题，经验风险或结构风险的函数就是最优化的目标函数。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法指学习模型的具体计算方法。由于统计学问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。</p><h1 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h1><h2 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h2><p>  统计学习的目的是使学到的模型不仅对已知数据而且对未知数据都能有很好的预测能力。不同的学习方法会给出不同的模型，而基于损失函数的模型训练误差（training error） 和模型测试误差（test error） 就自然成为学习方法的评估的标准。<br>  训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力。通常将学习方法对未知数据的预测能力称为泛化能力。</p><h2 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h2><p>  当假设空间含有不同复杂度的模型时，就要面临模型选择的问题。如果在假设空间中存在“真”模型，那么所选择的模型应该逼近真模型。<br>  如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合（over-fitting）。这种现象表现为对已知数据预测得很好，但对为知数据预测得很差。</p><h1 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h1><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>  模型选择的典型方法是<strong>正则化（regularization）</strong>。正则化是结构风险最小化策略的实现，是<code>在经验风险上加一个正则化项或惩罚项</code>。一般具有如下形式：</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221021184148.png?raw=true" alt="blog_images20221021184148.png"></p><p>  利用正则化进行模型选择的方法符合奥卡姆剃刀原理，即在所有可能选择的模型中，<code>能够很好地解释已知数据并且十分简单</code>才是最好的模型，也就是应该选择的模型。</p><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>​    另一种模型选择的典型方法是交叉验证（cross validation）。它的基本思想是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集和测试集，在此基础上反复地进行训练、测试以及模型选择。</p><p>​    常见的交叉验证方法有以下三种：简单交叉验证、S折交叉验证、留一交叉验证</p><h1 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h1><p>​    学习方法的<strong>泛化能力（generalization ability）</strong> 是指由该方法学习到的模型<code>对未知数据的预测能力</code>，是学习方法本质上重要的性质。</p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><p>     监督学习方法又可以分为生成方法和判别方法，所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。<br>  生成方法由数据学习联合概率分布P ( X , Y ) ，然后求出条件概率分布P ( Y ∣ X ) 作为预测的模型（生成模型），之所以被称之为生成方法，是因为模型表示了给定输入X XX产生输出Y YY的生成关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成方法的特点：</span><br><span class="line">（1）生成方法可以还原出联合概率分布P ( X , Y ) ；</span><br><span class="line">（2）生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；</span><br><span class="line">（3）生成方法适用于存在隐变量的学习。</span><br></pre></td></tr></table></figure><p> 判别方法由数据直接学习决策函数f ( X ) 或者条件概率分布P ( Y ∣ X ) 作为预测模型（判别模型），判别方法关注于给定的输入X ，应该预测什么样的输出Y 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判别方法的特点：</span><br><span class="line">（1）判别方法直接学习条件概率P ( Y ∣ X ) 或决策函数f ( X ) ，直接面对预测，往往学习的准确率更高；</span><br><span class="line">（2）判别方法可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</span><br></pre></td></tr></table></figure><h1 id="监督学习应用"><a href="#监督学习应用" class="headerlink" title="监督学习应用"></a>监督学习应用</h1><p>​    监督学习的应用主要在三个方面：<strong>分类问题</strong>、<strong>标注问题</strong>和<strong>回归问题</strong>。</p><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p> 输入变量为有限个离散变量的预测问题称为分类问题。其表示如图</p><p><img src="https://img-blog.csdnimg.cn/65054a8e54ab43c3bb0d907e0e693756.png#pic_center" alt="img"></p><h2 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h2><p> 输入变量与输出变量均为变量序列的预测问题称为标注问题。其表示如图</p><p><img src="https://img-blog.csdnimg.cn/143fb3dc8f7d4574aaa88b2561f29e24.png#pic_center" alt="img"></p><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><p>输入变量与输出变量均为连续变量的预测问题称为回归问题。其表示如图</p><p><img src="https://img-blog.csdnimg.cn/ae3d0da74c7d41cc9016f56894a49adf.png#pic_center" alt="img"></p><h1 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h1><h2 id="sklearn概述"><a href="#sklearn概述" class="headerlink" title="sklearn概述"></a>sklearn概述</h2><p>scikit-learn计划开始于scikits.learn，它是David Cournapeau（英语：David Cournapeau）的Google编程之夏计划。它的名字来源自成为“SciKit”（SciPy工具箱）的想法，即一个独立开发和发行的第三方SciPy扩展。最初的代码库被其他开发者重写了。在2010年，来自法国罗康库尔的法国国家信息与自动化研究所的Fabian Pedregosa、Gael Varoquaux、Alexandre Gramfort和Vincent Michel，领导了这个项目并在2010年2月1日进行了首次公开发行。在各种scikit中，scikit-learn和scikit-image（英语：scikit-image）截至2012年11月被称为“良好维护和流行的”。Scikit-learn是在GitHub上最流行的机器学习库之一。</p><h2 id="sklearn模块"><a href="#sklearn模块" class="headerlink" title="sklearn模块"></a>sklearn模块</h2><p><strong>注：sklearn里面只能接收二维的矩阵，如果只是一维请采用reshape(-1,1)</strong></p><p><strong>分类 (Classification)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> SomeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SomeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> SomeClassifier</span><br></pre></td></tr></table></figure><p><strong>回归 (Regression)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> SomeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SomeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> SomeRegressor</span><br></pre></td></tr></table></figure><p><strong>聚类 (Clustering)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> SomeModel</span><br></pre></td></tr></table></figure><p><strong>降维 (Dimensionality Reduction)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> SomeModel</span><br></pre></td></tr></table></figure><p><strong>模型选择 (Model Selection)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> SomeModel</span><br></pre></td></tr></table></figure><p><strong>预处理 (Preprocessing)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> SomeModel</span><br></pre></td></tr></table></figure><p>此外，Sklearn 里面还有很多自带数据集供，引入它们的伪代码如下。</p><p><strong>数据集 (Dataset)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> SomeData</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">datasets.load_boston <span class="comment">#波士顿房价数据集  回归模型</span></span><br><span class="line">datasets.load_breast_cancer <span class="comment">#乳腺癌数据集  分类模型</span></span><br><span class="line">datasets.load_diabetes <span class="comment">#糖尿病数据集  回归模型</span></span><br><span class="line">datasets.load_digits <span class="comment">#手写体数字数据集  分类模型</span></span><br><span class="line">datasets.load_files  </span><br><span class="line">datasets.load_iris <span class="comment">#鸢尾花数据集  分类模型</span></span><br><span class="line">datasets.load_lfw_pairs  </span><br><span class="line">datasets.load_lfw_people  </span><br><span class="line">datasets.load_linnerud <span class="comment">#体能训练数据集  回归模型</span></span><br><span class="line">datasets.load_mlcomp  </span><br><span class="line">datasets.load_sample_image  </span><br><span class="line">datasets.load_sample_images  </span><br><span class="line">datasets.load_svmlight_file  </span><br><span class="line">datasets.load_svmlight_files  </span><br></pre></td></tr></table></figure><h2 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing)"></a>预处理(Preprocessing)</h2><h3 id="数据无量纲化"><a href="#数据无量纲化" class="headerlink" title="数据无量纲化"></a>数据无量纲化</h3><p> 在机器学习算法实践中，我们往往有着将不同规格的数据转换到同一规格，或不同分布的数据转换到某个特定分布 的需求，这种需求统称为将数据“无量纲化”。</p><p><strong>reprocessing.MinMaxScaler</strong></p><p>当数据data中的一个特征太大严重影响另外一个特征，数据data按照最小值中心化后，再按极差（最大值 - 最小值）缩放，数据移动了最小值个单位，并且会被收敛到 [0,1]之间，而这个过程，就叫做数据归一化(Normalization，又称Min-Max Scaling)。公式如下：<br>$$<br>x=\frac{x-min(x)}{max(x)-min(x)}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.DataFrame(data)</span><br><span class="line"><span class="comment">#实现归一化</span></span><br><span class="line">scaler = MinMaxScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler = scaler.fit(data) <span class="comment">#fit，在这里本质是生成min(x)和max(x)</span></span><br><span class="line">result = scaler.transform(data) <span class="comment">#通过接口导出结果</span></span><br><span class="line">result</span><br><span class="line">result_ = scaler.fit_transform(data) <span class="comment">#训练和导出结果一步达成</span></span><br><span class="line">scaler.inverse_transform(result) <span class="comment">#将归一化后的结果逆转</span></span><br><span class="line"><span class="comment">#使用MinMaxScaler的参数feature_range实现将数据归一化到[0,1]以外的范围中</span></span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = MinMaxScaler(feature_range=[<span class="number">5</span>,<span class="number">10</span>]) <span class="comment">#依然实例化</span></span><br><span class="line">result = scaler.fit_transform(data) <span class="comment">#fit_transform一步导出结果</span></span><br><span class="line">result</span><br></pre></td></tr></table></figure><p><strong>preprocessing.StandardScaler</strong></p><p> 当数据(x)按均值(μ)中心化后，再按标准差(σ)缩放，数据就会服从为均值为0，方差为1的正态分布（即标准正态分 布），而这个过程，就叫做数据标准化(Standardization）。公式如下<br>$$<br>x=\frac{x-\mu}{\sigma}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = [[-<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = StandardScaler() <span class="comment">#实例化</span></span><br><span class="line">scaler.fit(data) <span class="comment">#fit，本质是生成均值和方差</span></span><br><span class="line">scaler.mean_ <span class="comment">#查看均值的属性mean_</span></span><br><span class="line">scaler.var_ <span class="comment">#查看方差的属性var_</span></span><br><span class="line">x_std = scaler.transform(data) <span class="comment">#通过接口导出结果</span></span><br><span class="line">x_std.mean() <span class="comment">#导出的结果是一个数组，用mean()查看均值</span></span><br><span class="line">x_std.std() <span class="comment">#用std()查看方差</span></span><br><span class="line">scaler.fit_transform(data) <span class="comment">#使用fit_transform(data)一步达成结果</span></span><br><span class="line">scaler.inverse_transform</span><br><span class="line">(x_std) <span class="comment">#使用inverse_transform逆转标准化</span></span><br></pre></td></tr></table></figure><p><strong>StandardScaler</strong>和<strong>MinMaxScaler</strong>选哪个？</p><p>​        看情况。大多数机器学习算法中，会选择StandardScaler来进行特征缩放，因为MinMaxScaler对异常值非常敏感。在PCA，聚类，逻辑回归，支持向量机，神经网络这些算法中，StandardScaler往往是最好的选择。</p><p>​        MinMaxScaler在不涉及距离度量、梯度、协方差计算以及数据需要被压缩到特定区间时使用广泛，比如数字图像处理中量化像素强度时，都会使用MinMaxScaler将数据压缩于[0,1]区间之中。</p><p>​        建议先试试看StandardScaler，效果不好换MinMaxScaler。</p><p>​        除了StandardScaler和MinMaxScaler之外，sklearn中也提供了各种其他缩放处理（中心化只需要一个pandas广</p><p>播一下减去某个数就好了，因此sklearn不提供任何中心化功能）。比如，在希望压缩数据，却不影响数据的稀疏</p><p>性时（不影响矩阵中取值为0的个数时），我们会使用MaxAbsScaler；在异常值多，噪声非常大时，我们可能会选</p><p>用分位数来无量纲化，此时使用RobustScaler。更多详情请参考以下列表</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221022093634.png?raw=true" alt="blog_images20221022093634.png"></p><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>机器学习和数据挖掘中所使用的数据，永远不可能是完美的。很多特征，对于分析和建模来说意义非凡，但对于实际收集数据的人却不是如此，因此数据挖掘之中，常常会有重要的字段缺失值很多，但又不能舍弃字段的情况。因此，数据预处理中非常重要的一项就是处理缺失值</p><p><strong>缺失值处理一般采用以下方式：<br>如果是数值类型，用平均值取代；<br>如果是分类数据，用最常见的类别取代；</strong></p><p><strong>impute.SimpleImputer</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sklearn</span>.impute.SimpleImputer (missing_values=nan, strategy=’mean’, fill_value=<span class="literal">None</span>, verbose=<span class="number">0</span>,</span><br><span class="line">copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>含义&amp;输入</strong></th></tr></thead><tbody><tr><td>missing_values</td><td>告诉SimpleImputer，数据中的缺失值长什么样，默认空值np.nan</td></tr><tr><td>strategy</td><td>我们填补缺失值的策略，默认均值。输入“mean”使用均值填补（仅对数值型特征可用)                    输入“median”用中值填补（仅对数值型特征可用 ）                                                                          输入”most_frequent”用众数填补（对数值型和字符型特征都可用）                                                  输入“constant”表示请参考参数“fifill_value”中的值（对数值型和字符型特征都可用）</td></tr><tr><td>fifill_value</td><td>当参数startegy为”constant”的时候可用，可输入字符串或数字表示要填充的值，常用0</td></tr><tr><td>copy</td><td>默认为True，将创建特征矩阵的副本，反之则会将缺失值填补到原本的特征矩阵中去。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Age = data.loc[:,<span class="string">&quot;Age&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#sklearn当中特征矩阵必须是二维</span></span><br><span class="line">Age[:<span class="number">20</span>]</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imp_mean = SimpleImputer() <span class="comment">#实例化，默认均值填补</span></span><br><span class="line">imp_median = SimpleImputer(strategy=<span class="string">&quot;median&quot;</span>) <span class="comment">#用中位数填补</span></span><br><span class="line">imp_0 = SimpleImputer(strategy=<span class="string">&quot;constant&quot;</span>,fill_value=<span class="number">0</span>) <span class="comment">#用0填补</span></span><br><span class="line">imp_mean = imp_mean.fit_transform(Age) <span class="comment">#fit_transform一步完成调取结果</span></span><br><span class="line">imp_median = imp_median.fit_transform(Age)</span><br><span class="line">imp_0 = imp_0.fit_transform(Age)</span><br></pre></td></tr></table></figure><p>补充:其实利用pandas和numpy进行填充更简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">r&quot;D:\Project\PythonProject\Python01\jupyter\train.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">data.head()</span><br><span class="line">data.loc[:,<span class="string">&quot;Age&quot;</span>] = data.loc[:,<span class="string">&quot;Age&quot;</span>].fillna(data.loc[:,<span class="string">&quot;Age&quot;</span>].median())</span><br><span class="line"><span class="comment">#.fillna 在DataFrame里面直接进行填补</span></span><br><span class="line">data.dropna(axis=<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#.dropna(axis=0)删除所有有缺失值的行，.dropna(axis=1)删除所有有缺失值的列</span></span><br><span class="line"><span class="comment">#参数inplace，为True表示在原数据集上进行修改，为False表示生成一个复制对象，不修改原数据，默认False</span></span><br></pre></td></tr></table></figure><h3 id="处理分类型特征：编码与哑变量"><a href="#处理分类型特征：编码与哑变量" class="headerlink" title="处理分类型特征：编码与哑变量"></a>处理分类型特征：编码与哑变量</h3><p>在机器学习中，大多数算法，譬如逻辑回归，支持向量机SVM，k近邻算法等都只能够处理数值型数据，不能处理文字，在sklearn当中，除了专用来处理文字的算法，其他算法在fifit的时候全部要求输入数组或矩阵，也不能够导入文字型数据（其实手写决策树和普斯贝叶斯可以处理文字，但是sklearn中规定必须导入数值型）。然而在现实中，许多标签和特征在数据收集完毕的时候，都不是以数字来表现的。比如说，学历的取值可以是[“小学”，“初中”，“高中”，”大学”]，付费方式可能包含[“支付宝”，“现金”，“微信”]等等。在这种情况下，为了让数据适应算法和库，我们必须将数据进行编码，即是说，将文字型数据转换为数值型。</p><p><strong>preprocessing.LabelEncoder</strong>：标签专用，能够将分类转换为分类数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">y = data.iloc[:,-<span class="number">1</span>] <span class="comment">#要输入的是标签，不是特征矩阵，所以允许一维</span></span><br><span class="line">le = LabelEncoder() <span class="comment">#实例化</span></span><br><span class="line">le = le.fit(y) <span class="comment">#导入数据</span></span><br><span class="line">label = le.transform(y)   <span class="comment">#transform接口调取结果</span></span><br><span class="line">le.classes_ <span class="comment">#属性.classes_查看标签中究竟有多少类别</span></span><br><span class="line">label <span class="comment">#查看获取的结果label</span></span><br><span class="line">le.fit_transform(y) <span class="comment">#也可以直接fit_transform一步到位</span></span><br><span class="line">le.inverse_transform(label) <span class="comment">#使用inverse_transform可以逆转</span></span><br></pre></td></tr></table></figure><p><strong>preprocessing.OrdinalEncoder</strong>：特征专用，能够将分类特征转换为分类数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder</span><br><span class="line"><span class="comment">#接口categories_对应LabelEncoder的接口classes_，一模一样的功能</span></span><br><span class="line">data_ = data.copy()</span><br><span class="line">data_.head()</span><br><span class="line">OrdinalEncoder().fit(data_.iloc[:,<span class="number">1</span>:-<span class="number">1</span>]).categories_</span><br><span class="line">data_.iloc[:,<span class="number">1</span>:-<span class="number">1</span>] = OrdinalEncoder().fit_transform(data_.iloc[:,<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">data_.head()</span><br></pre></td></tr></table></figure><p><strong>preprocessing.OneHotEncoder</strong>：独热编码，创建哑变量</p><p>我们刚才已经用OrdinalEncoder把分类变量Sex和Embarked都转换成数字对应的类别了。在舱门Embarked这一列中，我们使用[0,1,2]代表了三个不同的舱门，然而这种转换是正确的吗？</p><p>我们来思考三种不同性质的分类数据：</p><p>1） 舱门（S，C，Q）</p><p>三种取值S，C，Q是相互独立的，彼此之间完全没有联系，表达的是S≠C≠Q的概念。这是名义变量。</p><p>2） 学历（小学，初中，高中）</p><p>三种取值不是完全独立的，我们可以明显看出，在性质上可以有高中&gt;初中&gt;小学这样的联系，学历有高低，但是学历取值之间却不是可以计算的，我们不能说小学 + 某个取值 = 初中。这是有序变量。</p><p>3） 体重（&gt;45kg，&gt;90kg，&gt;135kg）</p><p>各个取值之间有联系，且是可以互相计算的，比如120kg - 45kg = 90kg，分类之间可以通过数学计算互相转换。这是有距变量。然而在对特征进行编码的时候，这三种分类数据都会被我们转换为[0,1,2]，这三个数字在算法看来，是连续且可以计算的，这三个数字相互不等，有大小，并且有着可以相加相乘的联系。所以算法会把舱门，学历这样的分类特征，都误会成是体重这样的分类特征。这是说，我们把分类转换成数字的时候，忽略了数字中自带的数学性质，所以给算法传达了一些不准确的信息，而这会影响我们的建模。类别OrdinalEncoder可以用来处理有序变量，但对于名义变量，我们只有使用哑变量的方式来处理，才能够尽量向算法传达最准确的信息。</p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221022152130.png?raw=true" alt="blog_images20221022152130.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data.head()</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">X = data.iloc[:,<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">enc = OneHotEncoder(categories=<span class="string">&#x27;auto&#x27;</span>).fit(X)</span><br><span class="line">result = enc.transform(X).toarray()</span><br><span class="line">result</span><br><span class="line"><span class="comment">#依然可以直接一步到位，但为了给大家展示模型属性，所以还是写成了三步</span></span><br><span class="line">OneHotEncoder(categories=<span class="string">&#x27;auto&#x27;</span>).fit_transform(X).toarray()</span><br><span class="line"><span class="comment">#依然可以还原</span></span><br><span class="line">pd.DataFrame(enc.inverse_transform(result))</span><br><span class="line">enc.get_feature_names()</span><br><span class="line">result</span><br><span class="line">result.shape</span><br><span class="line"><span class="comment">#axis=1,表示跨行进行合并，也就是将量表左右相连，如果是axis=0，就是将量表上下相连</span></span><br><span class="line">newdata = pd.concat([data,pd.DataFrame(result)],axis=<span class="number">1</span>)</span><br><span class="line">newdata.head()</span><br><span class="line">newdata.drop([<span class="string">&quot;Sex&quot;</span>,<span class="string">&quot;Embarked&quot;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">newdata.columns = [<span class="string">&quot;Age&quot;</span>,<span class="string">&quot;Survived&quot;</span>,<span class="string">&quot;Female&quot;</span>,<span class="string">&quot;Male&quot;</span>,<span class="string">&quot;Embarked_C&quot;</span>,<span class="string">&quot;Embarked_Q&quot;</span>,<span class="string">&quot;Embarked_S&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="处理连续型特征：二值化与分段"><a href="#处理连续型特征：二值化与分段" class="headerlink" title="处理连续型特征：二值化与分段"></a>处理连续型特征：二值化与分段</h3><p><strong>sklearn.preprocessing.Binarizer</strong></p><p>根据阈值将数据二值化（将特征值设置为0或1），用于处理连续型变量。大于阈值的值映射为1，而小于或等于阈值的值映射为0。默认阈值为0时，特征中所有的正值都映射到1。二值化是对文本计数数据的常见操作，分析人员可以决定仅考虑某种现象的存在与否。它还可以用作考虑布尔随机变量的估计器的预处理步骤（例如，使用贝叶斯设置中的伯努利分布建模）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line">X = data.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类为特征专用，所以不能使用一维数组</span></span><br><span class="line">transformer = Binarizer(threshold=<span class="number">30</span>).fit_transform(X)</span><br><span class="line">transformer</span><br></pre></td></tr></table></figure><p><strong>preprocessing.KBinsDiscretizer</strong></p><p>这是将连续型变量划分为分类变量的类，能够将连续型变量排序后按顺序分箱后编码。总共包含三个重要参数：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>含义&amp;输入</strong></th></tr></thead><tbody><tr><td><strong>n_bins</strong></td><td>每个特征中分箱的个数，默认5，一次会被运用到所有导入的特征</td></tr><tr><td><strong>encode</strong></td><td>编码的方式，默认“onehot”                                                                                                                      “onehot”：做哑变量，之后返回一个稀疏矩阵，每一列是一个特征中的一个类别，含有该类别的样本表示为1，不含的表示为0                                                                                                                                                      “ordinal”：每个特征的每个箱都被编码为一个整数，返回每一列是一个特征，每个特征下含有不同整数编码的箱的矩阵                                                                                                                                                “onehot-dense”：做哑变量，之后返回一个密集数组。</td></tr><tr><td><strong>strategy</strong></td><td>用来定义箱宽的方式，默认”quantile”                                                                                                       “uniform”：表示等宽分箱，即每个特征中的每个箱的最大值之间的差为(特征.max() - 特征.min())/(n_bins)      “quantile”：表示等位分箱，即每个特征中的每个箱内的样本数量都相同                                                                    “kmeans”：表示按聚类分箱，每个箱中的值到最近的一维k均值聚类的簇心得距离都相同</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> KBinsDiscretizer</span><br><span class="line">X = data.iloc[:,<span class="number">0</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line">est = KBinsDiscretizer(n_bins=<span class="number">3</span>, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">est.fit_transform(X)</span><br><span class="line"><span class="comment">#查看转换后分的箱：变成了一列中的三箱</span></span><br><span class="line"><span class="built_in">set</span>(est.fit_transform(X).ravel())</span><br><span class="line">est = KBinsDiscretizer(n_bins=<span class="number">3</span>, encode=<span class="string">&#x27;onehot&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line"><span class="comment">#查看转换后分的箱：变成了哑变量</span></span><br><span class="line">est.fit_transform(X).toarray()</span><br></pre></td></tr></table></figure><h3 id="Filter过滤法"><a href="#Filter过滤法" class="headerlink" title="Filter过滤法"></a>Filter过滤法</h3><p>过滤方法通常用作预处理步骤，特征选择完全独立于任何机器学习算法。它是根据各种统计检验中的分数以及相关性的各项指标来选择特征。</p><p><strong>方差过滤</strong></p><p> <strong>VarianceThreshold</strong></p><p>这是通过特征本身的方差来筛选特征的类。比如一个特征本身的方差很小，就表示样本在这个特征上基本没有差异，可能特征中的大多数值都一样，甚至整个特征的取值都相同，那这个特征对于样本区分没有什么作用。所以无论接下来的特征工程要做什么，都要优先消除方差为<strong>0的特征。VarianceThreshold有重要参数threshold</strong>，表示方差的阈值，表示舍弃所有方差小于threshold的特征，不填默认为0，即删除所有的记录都相同的特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line">selector = VarianceThreshold() <span class="comment">#实例化，不填参数默认方差为0</span></span><br><span class="line">X_var0 = selector.fit_transform(X) <span class="comment">#获取删除不合格特征之后的新特征矩阵</span></span><br><span class="line"><span class="comment">#也可以直接写成 X = VairanceThreshold().fit_transform(X)</span></span><br></pre></td></tr></table></figure><p>可以看见，我们已经删除了方差为0的特征，但是依然剩下了708多个特征，明显还需要进一步的特征选择。然而，如果我们知道我们需要多少个特征，方差也可以帮助我们将特征选择一步到位。比如说，我们希望留下一半的特征，那可以设定一个让特征总数减半的方差阈值，只要找到特征方差的中位数，再将这个中位数作为参数threshold的值输入就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_fsvar = VarianceThreshold(np.median(X.var().values)).fit_transform(X)</span><br><span class="line">X.var().values</span><br><span class="line">np.median(X.var().values)</span><br><span class="line">X_fsvar.shape</span><br></pre></td></tr></table></figure><p>当特征是二分类时，特征的取值就是伯努利随机变量，这些变量的方差可以计算为：<br>$$<br>Var[x]=p(1-p)<br>$$<br>其中X是特征矩阵，p是二分类特征中的一类在这个特征中所占的概率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#若特征是伯努利随机变量，假设p=0.8，即二分类特征中某种分类占到80%以上的时候删除特征</span></span><br><span class="line">X_bvar = VarianceThreshold(<span class="number">.8</span> * (<span class="number">1</span> - <span class="number">.8</span>)).fit_transform(X)</span><br><span class="line">X_bvar.shape</span><br></pre></td></tr></table></figure><h3 id="相关性过滤"><a href="#相关性过滤" class="headerlink" title="相关性过滤"></a>相关性过滤</h3><p>方差挑选完毕之后，我们就要考虑下一个问题：相关性了。我们希望选出与标签相关且有意义的特征，因为这样的特征能够为我们提供大量信息。如果特征与标签无关，那只会白白浪费我们的计算内存，可能还会给模型带来噪音。在sklearn当中，我们有三种常用的方法来评判特征与标签之间的相关性：卡方，F检验，互信息</p><p><strong>卡方过滤</strong></p><p>卡方过滤是专门针对离散型标签（即分类问题）的相关性过滤。卡方检验类<strong>feature_selection.chi2</strong>计算每个非负特征和标签之间的卡方统计量，并依照卡方统计量由高到低为特征排名。再结合<strong>feature_selection.SelectKBest</strong>这个可以输入”评分标准“来选出前K个分数最高的特征的类，我们可以借此除去最可能独立于标签，与我们分类目的无关的特征。另外，如果卡方检验检测到某个特征中所有的值都相同，会提示我们使用方差先进行方差过滤。并且，刚才我们已经验证过，当我们使用方差过滤筛选掉一半的特征后，模型的表现时提升的。因此在这里，我们使用threshold=中位数时完成的方差过滤的数据来做卡方检验（如果方差过滤后模型的表现反而降低了，那我们就不会使用方差过滤后的数据，而是使用原数据）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier <span class="keyword">as</span> RFC</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"><span class="comment">#假设在这里我一直我需要300个特征</span></span><br><span class="line">X_fschi = SelectKBest(chi2, k=<span class="number">300</span>).fit_transform(X_fsvar, y)</span><br><span class="line">X_fschi.shape</span><br></pre></td></tr></table></figure><p>验证一下模型的效果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cross_val_score(RFC(n_estimators=<span class="number">10</span>,random_state=<span class="number">0</span>),X_fschi,y,cv=<span class="number">5</span>).mean()</span><br></pre></td></tr></table></figure><p>如果效果降低了那么说明k=300的时候删除了模型相关的有效特征。那如何设置一个最佳的k值呢？在现实数据中，数据量很大，模型很复杂的时候，我们也许不能先去跑一遍模型看。看效果，而是希望最开始就能够选择一个最优的超参数k。那第一个方法，就是我们之前提过的学习曲线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#======【TIME WARNING: 5 mins】======#</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">score = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">390</span>,<span class="number">200</span>,-<span class="number">10</span>):</span><br><span class="line">    X_fschi = SelectKBest(chi2, k=i).fit_transform(X_fsvar, y)</span><br><span class="line">    once = cross_val_score(RFC(n_estimators=<span class="number">10</span>,random_state=<span class="number">0</span>),X_fschi,y,cv=<span class="number">5</span>).mean()</span><br><span class="line">    score.append(once)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">350</span>,<span class="number">200</span>,-<span class="number">10</span>),score)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过图例扎到最好的效果</p><table><thead><tr><th>p值</th><th>&lt;=0.05或0.01</th><th>&gt;0.05或0.01</th></tr></thead><tbody><tr><td>数据差异</td><td>差异不是自然形成的</td><td>这些差异是很自然的样本误差</td></tr><tr><td>相关性</td><td>两组数据是相关的</td><td>两组数据是相互独立的</td></tr><tr><td>原假设</td><td>拒绝原假设，接受备择假设</td><td>接受原假设</td></tr></tbody></table><p>从特征工程的角度，我们希望选取卡方值很大，p值小于0.05的特征，即和标签是相关联的特征。而调用SelectKBest之前，我们可以直接从chi2实例化后的模型中获得各个特征所对应的卡方值和P值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chivalue, pvalues_chi = chi2(X_fsvar,y)</span><br><span class="line"><span class="comment">#k取多少？我们想要消除所有p值大于设定值，比如0.05或0.01的特征：</span></span><br><span class="line">k = chivalue.shape[<span class="number">0</span>] - (pvalues_chi &gt; <span class="number">0.05</span>).<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment">#X_fschi = SelectKBest(chi2, k=填写具体的k).fit_transform(X_fsvar, y)</span></span><br><span class="line"><span class="comment">#cross_val_score(RFC(n_estimators=10,random_state=0),X_fschi,y,cv=5).mean()</span></span><br></pre></td></tr></table></figure><p> <strong>F检验</strong></p><p>F检验，又称ANOVA，方差齐性检验，是用来捕捉每个特征与标签之间的线性关系的过滤方法。它即可以做回归也可以做分类，因此包含feature_selection.f_classif（F检验分类）和feature_selection.f_regression（F检验回归）两个类。其中F检验分类用于标签是离散型变量的数据，而F检验回归用于标签是连续型变量的数据。和卡方检验一样，这两个类需要和类SelectKBest连用，并且我们也可以直接通过输出的统计量来判断我们到底要设置一个什么样的K。需要注意的是，F检验在数据服从正态分布时效果会非常稳定，因此如果使用F检验过滤，我们会先将数据转换成服从正态分布的方式。F检验的本质是寻找两组数据之间的线性关系，其原假设是”数据不存在显著的线性关系“。它返回F值和p值两个统计量。和卡方过滤一样，我们希望选取<strong>p值小于0.05或0.01的特征，这些特征与标签时显著线性相关的</strong>，而p值大于0.05或0.01的特征则被我们认为是和标签没有显著线性关系的特征，应该被删除。以F检验的分类为例，我们继续在数字数据集上来进行特征选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> f_classif</span><br><span class="line">F, pvalues_f = f_classif(X_fsvar,y)</span><br><span class="line">k = F.shape[<span class="number">0</span>] - (pvalues_f &gt; <span class="number">0.05</span>).<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment">#X_fsF = SelectKBest(f_classif, k=填写具体的k).fit_transform(X_fsvar, y)</span></span><br><span class="line"><span class="comment">#cross_val_score(RFC(n_estimators=10,random_state=0),X_fsF,y,cv=5).mean()</span></span><br></pre></td></tr></table></figure><p>得到的结论和我们用卡方过滤得到的结论一模一样：没有任何特征的p值大于0.01，所有的特征都是和标签相关的，因此我们不需要相关性过滤。</p><p><strong>互信息法</strong></p><p>互信息法是用来捕捉每个特征与标签之间的任意关系（包括线性和非线性关系）的过滤方法。和F检验相似，它既可以做回归也可以做分类，并且包含两个类feature_selection.mutual_info_classif（互信息分类）和feature_selection.mutual_info_regression（互信息回归）。这两个类的用法和参数都和F检验一模一样 ，不过互信息法比F检验更加强大，F检验只能够找出线性关系，而互信息法可以找出任意关系。互信息法不返回p值或F值类似的统计量，它返回“每个特征与目标之间的互信息量的估计”，这个估计量在[0,1]之间取值，为0则表示两个变量独立，为1则表示两个变量完全相关。以互信息分类为例的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> mutual_info_classif <span class="keyword">as</span> MIC</span><br><span class="line">result = MIC(X_fsvar,y) <span class="comment">#X_fsvar为特征,y为标签</span></span><br><span class="line">k = result.shape[<span class="number">0</span>] - <span class="built_in">sum</span>(result &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">#X_fsmic = SelectKBest(MIC, k=填写具体的k).fit_transform(X_fsvar, y)</span></span><br><span class="line"><span class="comment">#cross_val_score(RFC(n_estimators=10,random_state=0),X_fsmic,y,cv=5).mean()</span></span><br></pre></td></tr></table></figure><p>所有特征的互信息量估计都大于0，因此所有特征都与标签相关。当然了，无论是F检验还是互信息法，大家也都可以使用学习曲线，只是使用统计量的方法会更加高效。当统计量判断已经没有特征可以删除时，无论用学习曲线如何跑，删除特征都只会降低模型的表现。当然了，如果数据量太庞大，模型太复杂，我们还是可以牺牲模型表现来提升模型速度，一切都看大家的具体需求。</p><h3 id="Embedded嵌入法"><a href="#Embedded嵌入法" class="headerlink" title="Embedded嵌入法"></a>Embedded嵌入法</h3><p>嵌入法是一种让算法自己决定使用哪些特征的方法，即特征选择和算法训练同时进行。在使用嵌入法时，我们先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小选择特征。这些权值系数往往代表了特征对于模型的某种贡献或某种重要性，比如决策树和树的集成模型中的feature_importances_属性，可以列出各个特征对树的建立的贡献，我们就可以基于这种贡献的评估，找出对模型建立最有用的特征。因此相比于过滤法，嵌入法的结果会更加精确到模型的效用本身，对于提高模型效力有更好的效果。并且，由于考虑特征对模型的贡献，因此无关的特征（需要相关性过滤的特征）和无区分度的特征（需要方差过滤的特征）都会因为缺乏对模型的贡献而被删除掉，可谓是过滤法的进化版。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sklearn</span>.feature_selection.SelectFromModel (estimator, threshold=<span class="literal">None</span>, prefit=<span class="literal">False</span>, norm_order=<span class="number">1</span>,</span><br><span class="line">max_features=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数 说明</p><p><strong>estimator</strong> </p><p>使用的模型评估器，只要是带feature_importances_或者coef_属性，或带有l1和l2惩罚项的模型都可以使用</p><p><strong>threshold</strong> </p><p>特征重要性的阈值，重要性低于这个阈值的特征都将被删除</p><p><strong>prefifit</strong></p><p>默认False，判断是否将实例化后的模型直接传递给构造函数。如果为True，则必须直接调用fifit和transform，不能使用fifit_transform，并且SelectFromModel不能与cross_val_score，GridSearchCV和克隆估计器的类似实用程序一起使用。</p><p><strong>norm_order</strong></p><p>k可输入非零整数，正无穷，负无穷，默认值为1 ,在评估器的coef_属性高于一维的情况下，用于过滤低于阈值的系数的向量的范数的阶数。</p><p><strong>max_features</strong> </p><p>在阈值设定下，要选择的最大特征数。要禁用阈值并仅根据max_features选择，请设置threshold = -np.inf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier <span class="keyword">as</span> RFC</span><br><span class="line">RFC_ = RFC(n_estimators =<span class="number">10</span>,random_state=<span class="number">0</span>)</span><br><span class="line">X_embedded = SelectFromModel(RFC_,threshold=<span class="number">0.005</span>).fit_transform(X,y)</span><br><span class="line"><span class="comment">#在这里我只想取出来有限的特征。0.005这个阈值对于有780个特征的数据来说，是非常高的阈值，因为平均每个特征只能够分到大约0.001的feature_importances_</span></span><br></pre></td></tr></table></figure><h3 id="Wrapper包装法"><a href="#Wrapper包装法" class="headerlink" title="Wrapper包装法"></a>Wrapper包装法</h3><p>包装法也是一个特征选择和算法训练同时进行的方法，与嵌入法十分相似，它也是依赖于算法自身的选择，比如coef_属性或feature_importances_属性来完成特征选择。但不同的是，我们往往使用一个目标函数作为黑盒来帮助我们选取特征，而不是自己输入某个评估指标或统计量的阈值。包装法在初始特征集上训练评估器，并且通过coef_属性或通过feature_importances_属性获得每个特征的重要性。然后，从当前的一组特征中修剪最不重要的特征。在修剪的集合上递归地重复该过程，直到最终到达所需数量的要选择的特征。区别于过滤法和嵌入法的一次训练解决所有问题，包装法要使用特征子集进行多次训练，因此它所需要的计算成本是最高的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sklearn</span>.feature_selection.RFE (estimator, n_features_to_select=<span class="literal">None</span>, step=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数<strong>estimator</strong>是需要填写的实例化后的评估器，<strong>n_features_to_select</strong>是想要选择的特征个数，<strong>step</strong>表示每次迭代中希望移除的特征个数。除此之外，RFE类有两个很重要的属性，**.support_<strong>：返回所有的特征的是否最后被选中的布尔矩阵，以及</strong>.ranking_**返回特征的按数次迭代中综合重要性的排名。类feature_selection.RFECV会在交叉验证循环中执行RFE以找到最佳数量的特征，增加参数cv，其他用法都和RFE一模一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line">RFC_ = RFC(n_estimators =<span class="number">10</span>,random_state=<span class="number">0</span>)</span><br><span class="line">selector = RFE(RFC_, n_features_to_select=<span class="number">340</span>, step=<span class="number">50</span>).fit(X, y)</span><br></pre></td></tr></table></figure><h2 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h2><p><strong>算法</strong></p><p>遍历所有的样本点，计算每个样本点与待分类数据的距离，找出k个距离最近的点，统计每个类别的个数，投票数据最多的类别即为样本点的类别。</p><p>sklearn提供的模块</p><table><thead><tr><th>类方法</th><th>说明</th></tr></thead><tbody><tr><td>KNeighborsClassifier</td><td>KNN 算法解决分类问题</td></tr><tr><td>KNeighborsRegressor</td><td>KNN 算法解决回归问题</td></tr><tr><td>RadiusNeighborsClassifier</td><td>基于半径来查找最近邻的分类算法</td></tr><tr><td>NearestNeighbors</td><td>基于无监督学习实现KNN算法</td></tr><tr><td>KDTree</td><td>无监督学习下基于 KDTree 来查找最近邻的分类算法</td></tr><tr><td>BallTree</td><td>无监督学习下基于 BallTree 来查找最近邻的分类算法</td></tr></tbody></table><p><strong>sklearn.neighbors.KNeighborsClassifier参数说明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.neighbors.KNeighborsClassifier ( n_neighbors = <span class="number">5</span> , * , weights = <span class="string">&#x27;uniform&#x27;</span> , algorithm = <span class="string">&#x27;auto&#x27;</span> , leaf_size = <span class="number">30</span> , p = <span class="number">2</span> , metric = <span class="string">&#x27;minkowski&#x27;</span> , metric_params = <span class="literal">None</span> , n_jobs = <span class="literal">None</span> )</span><br></pre></td></tr></table></figure><blockquote><p><strong>n_neighbors int，默认=5</strong></p><p>默认情况下用于kneighbors查询的邻居数。</p><p><strong>weights{‘uniform’, ‘distance’} ，默认=’uniform’</strong></p><p>预测中使用的权重函数。可能的值：</p><ul><li>‘uniform’ ：统一的权重。每个邻域中的所有点的权重相等。</li><li>‘distance’ ：权重点的距离的倒数。在这种情况下，查询点的较近的邻居将比较远的邻居具有更大的影响。</li><li>[callable] ：一个用户定义的函数，它接受一个距离数组，并返回一个包含权重的相同形状的数组。</li></ul><p><strong>algorithm{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’</strong></p><p>用于计算最近邻的算法：</p><ul><li>‘ball_tree’ 将使用BallTree</li><li>‘kd_tree’ 将使用KDTree</li><li>‘brute’ 将使用暴力搜索。</li><li>‘auto’ 将尝试根据传递给fit方法的值来决定最合适的算法。</li></ul><p>注意：拟合稀疏输入将使用蛮力覆盖此参数的设置。</p><p><strong>Leaf_size int，默认=30</strong></p><p>叶大小传递给 BallTree 或 KDTree。这会影响构建和查询的速度，以及存储树所需的内存。最佳值取决于问题的性质。</p><p><strong>p int，默认=2</strong></p><p>Minkowski 度量的功率参数。当 p = 1 时，这相当于使用 manhattan_distance (l1)，而 p = 2 则使用 euclidean_distance (l2)。对于任意 p，使用 minkowski_distance (l_p)。</p><p><strong>metric ：str 或可调用，默认=’minkowski’</strong></p><p>用于距离计算的度量。默认为“minkowski”，当 p = 2 时产生标准欧几里德距离。请参阅scipy.spatial.distance的文档和列出 distance_metrics的有效度量值的度量。</p><p>如果 metric 是“预先计算的”，则 X 被假定为一个距离矩阵，并且在拟合期间必须是平方的。X 可能是一个稀疏图，在这种情况下，只有“非零”元素可以被认为是邻居。</p><p>如果 metric 是一个可调用函数，它需要两个表示一维向量的数组作为输入，并且必须返回一个值来指示这些向量之间的距离。这适用于 Scipy 的指标，但效率低于将指标名称作为字符串传递。</p><p><strong>metric_params:dic，默认=无</strong></p><p>度量函数的附加关键字参数。</p><p><strong>n_jobs :int</strong>，默认=无</p></blockquote><p>属性：</p><blockquote><p><strong>Effective_metric_str 或callble</strong></p><p>使用的距离度量。它将与<code>metric</code>参数或其同义词相同，例如，如果<code>metric</code>参数设置为“minkowski”且<code>p</code>参数设置为 2，则为“euclidean”。</p><p>*<strong>Effective_metric_params_dict _：</strong></p><p>度量函数的附加关键字参数。对于大多数指标将与参数相同，但如果属性设置为“minkowski” <code>metric_params</code>，也可能包含 <code>p</code>参数值。<code>effective_metric_</code></p><p><strong>n_features_in_ int</strong></p><p>拟合期间看到的特征数。</p><p><em>0.24 版中的新功能。</em></p><p><strong>feature_names_in_ndarray 的形状 ( <code>n_features_in_</code>,)</strong></p><p>拟合期间看到的特征名称。仅当<code>X</code> 具有全为字符串的特征名称时才定义。</p><p><em>1.0 版中的新功能。</em></p><p><strong>n_samples_fit_int_</strong></p><p>拟合数据中的样本数。</p><p><strong>outputs_2d_bool</strong></p><p>当<code>y</code>‘ 的形状在拟合期间为 (n_samples, ) 或 (n_samples, 1) 时为假，否则为真。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载红酒数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="comment">#KNN分类算法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment">#分割训练集与测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment">#导入numpy</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#加载数据集</span></span><br><span class="line">wine_dataset=load_wine()</span><br><span class="line"><span class="comment">#查看数据集对应的键</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;红酒数据集的键:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据集描述:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset[<span class="string">&#x27;data&#x27;</span>].shape))</span><br><span class="line"><span class="comment"># data 为数据集数据;target 为样本标签</span></span><br><span class="line"><span class="comment">#分割数据集，比例为 训练集：测试集 = 8:2</span></span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(wine_dataset[<span class="string">&#x27;data&#x27;</span>],wine_dataset[<span class="string">&#x27;target&#x27;</span>],test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#构建knn分类模型，并指定 k 值</span></span><br><span class="line">KNN=KNeighborsClassifier(n_neighbors=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#使用训练集训练模型</span></span><br><span class="line">KNN.fit(X_train,y_train)</span><br><span class="line"><span class="comment">#评估模型的得分</span></span><br><span class="line">score=KNN.score(X_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(score)</span><br><span class="line"><span class="comment">#给出一组数据对酒进行分类</span></span><br><span class="line">X_wine_test=np.array([[<span class="number">11.8</span>,<span class="number">4.39</span>,<span class="number">2.39</span>,<span class="number">29</span>,<span class="number">82</span>,<span class="number">2.86</span>,<span class="number">3.53</span>,<span class="number">0.21</span>,<span class="number">2.85</span>,<span class="number">2.8</span>,<span class="number">.75</span>,<span class="number">3.78</span>,<span class="number">490</span>]])</span><br><span class="line">predict_result=KNN.predict(X_wine_test)</span><br><span class="line"><span class="built_in">print</span>(predict_result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类结果：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset[<span class="string">&#x27;target_names&#x27;</span>][predict_result]))</span><br></pre></td></tr></table></figure><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><p><strong>信息熵</strong>：决策树学习的关键是如何选择最优划分属性。划分过程中，决策树的分支结点所包含的样本尽可能属于同一类别，结点的“纯度”（purity）越来越高。信息熵是度量样本集合纯度最常用的一种指标。假定当前样本集合D DD中第k kk类样本所占的比例来为Pk (k=1,2,…,|y|)，则D的信息熵定义为</p><p>函数原型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sklearn</span>.tree.DecisionTreeClassifier(*, criterion=<span class="string">&#x27;gini&#x27;</span>, splitter=<span class="string">&#x27;best&#x27;</span>, max_depth=<span class="literal">None</span>, min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, min_weight_fraction_leaf=<span class="number">0.0</span>, max_features=<span class="literal">None</span>, random_state=<span class="literal">None</span>, max_leaf_nodes=<span class="literal">None</span>, min_impurity_decrease=<span class="number">0.0</span>, class_weight=<span class="literal">None</span>, ccp_alpha=<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure><ul><li>criterion ： gini或者entropy，前者是基尼指数，后者是信息熵；</li><li>max_depth ： int or None, optional (default=None) 设置决策随机森林中的决策树的最大深度，深度越大，越容易过合，推荐树的深度为：5-20之间；</li><li>max_features： None（所有），log2，sqrt，N 特征小于50的时候一般使用所有的；</li><li>max_leaf_nodes ： 通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas用于处理和分析数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 导入鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># 导入决策树分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="comment"># # 导入分割数据集的方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># import relevant packages</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_text</span><br><span class="line"><span class="comment"># import matplotlib; matplotlib.use(&#x27;TkAgg&#x27;)</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用决策树进行鸢尾花数据集分类预测</span></span><br><span class="line"><span class="comment"># 数据集字段说明：</span></span><br><span class="line"><span class="comment"># 特征值（4个）：sepal length（花萼长度），sepal width（花萼宽度）， petal length（花瓣长度），petal width（花瓣宽度）</span></span><br><span class="line"><span class="comment"># 目标值（3个）：target（类别，0为&#x27;setosa&#x27;山鸢尾花，1为&#x27;versicolor&#x27;变色鸢尾花，2为&#x27;virginica&#x27;维吉尼亚鸢尾花）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load in the data加载数据</span></span><br><span class="line">data = load_iris()</span><br><span class="line"><span class="comment"># convert to a dataframe 转换数据格式</span></span><br><span class="line">df = pd.DataFrame(data.data, columns = data.feature_names)</span><br><span class="line"><span class="comment"># create the species column</span></span><br><span class="line">df[<span class="string">&#x27;Species&#x27;</span>] = data.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace this with the actual names</span></span><br><span class="line">target = np.unique(data.target)  <span class="comment"># 对于一维数组或者列表，unique函数去除其中重复的元素，并按元素由大到小返回一个新的无元素重复的元组或者列表</span></span><br><span class="line">target_names = np.unique(data.target_names)</span><br><span class="line">targets = <span class="built_in">dict</span>(<span class="built_in">zip</span>(target, target_names))</span><br><span class="line">df[<span class="string">&#x27;Species&#x27;</span>] = df[<span class="string">&#x27;Species&#x27;</span>].replace(targets)</span><br><span class="line"></span><br><span class="line"><span class="comment"># extract features and target variables 提取特征和目标变量</span></span><br><span class="line">x = df.drop(columns=<span class="string">&quot;Species&quot;</span>)</span><br><span class="line">y = df[<span class="string">&quot;Species&quot;</span>]</span><br><span class="line"><span class="comment"># save the feature name and target variables 保存特征名称和目标变量</span></span><br><span class="line">feature_names = x.columns</span><br><span class="line">labels = y.unique()  <span class="comment"># 去除重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集、测试集</span></span><br><span class="line"><span class="comment"># x 数据集的特征值</span></span><br><span class="line"><span class="comment"># y 数据集的标签值</span></span><br><span class="line"><span class="comment"># 训练集的特征值x_train 测试集的特征值x_test(test_x) 训练集的目标值y_train 测试集的目标值y_test(test_lab)</span></span><br><span class="line"><span class="comment"># random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。</span></span><br><span class="line">X_train, test_x, y_train, test_lab = train_test_split(x,y,</span><br><span class="line">                                                 test_size = <span class="number">0.4</span>,</span><br><span class="line">                                                 random_state = <span class="number">42</span>)</span><br><span class="line"><span class="comment"># 创建决策树分类器（树的最大深度为3）</span></span><br><span class="line">model = DecisionTreeClassifier(max_depth =<span class="number">3</span>, random_state = <span class="number">42</span>)  <span class="comment"># 初始化模型</span></span><br><span class="line">model.fit(X_train, y_train)  <span class="comment"># 训练模型</span></span><br><span class="line"><span class="built_in">print</span>(model.score(test_x,test_lab))  <span class="comment"># 评估模型分数</span></span><br><span class="line"><span class="comment"># 计算每个特征的重要程度</span></span><br><span class="line"><span class="built_in">print</span>(model.feature_importances_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化特征属性结果</span></span><br><span class="line">r = export_text(model, feature_names=data[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt the figure, setting a black background</span></span><br><span class="line">plt.figure(figsize=(<span class="number">30</span>,<span class="number">10</span>), facecolor =<span class="string">&#x27;g&#x27;</span>)  <span class="comment"># facecolor设置背景色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the tree plot 决策树绘图模块，实现决策树可视化</span></span><br><span class="line">a = tree.plot_tree(model,</span><br><span class="line">                   <span class="comment"># use the feature names stored</span></span><br><span class="line">                   feature_names = feature_names,</span><br><span class="line">                   <span class="comment"># use the class names stored</span></span><br><span class="line">                   class_names = labels,</span><br><span class="line">                   <span class="comment"># label=&#x27;all&#x27;,</span></span><br><span class="line">                   rounded = <span class="literal">True</span>,</span><br><span class="line">                   filled = <span class="literal">True</span>,</span><br><span class="line">                   fontsize=<span class="number">14</span>,</span><br><span class="line">                   )</span><br><span class="line"><span class="comment"># show the plot</span></span><br><span class="line"><span class="comment"># plt.legend(loc=&#x27;lower right&#x27;, borderpad=0, handletextpad=0)</span></span><br><span class="line">plt.savefig(<span class="string">&quot;save.png&quot;</span>, dpi=<span class="number">300</span>, bbox_inches=<span class="string">&quot;tight&quot;</span>)</span><br><span class="line"><span class="comment"># plt.tight_layout()</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p><strong>感知机简介</strong></p><blockquote><p>感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面。感知机是一种线性分类模型。</p></blockquote><p>感知机实际上表示为输入空间到输出空间的映射函数，如下所示：</p><p>$$<br>f(x)=sign(w.x+b)<br>$$<br>其中，<img src="https://www.zhihu.com/equation?tex=w" alt="w">和<img src="https://www.zhihu.com/equation?tex=b" alt="b">称为感知机的模型参数，<img src="https://www.zhihu.com/equation?tex=w%5Csubset+R%5E%7Bn%7D+" alt="w\subset R^{n}">叫做权值（weight）或权值向量（weight vector），<img src="https://www.zhihu.com/equation?tex=b%5Csubset+R" alt="b\subset R">叫做偏置（bias），<img src="https://www.zhihu.com/equation?tex=w%5Cbullet+x" alt="w\bullet x">是<img src="https://www.zhihu.com/equation?tex=w" alt="w">和<img src="https://www.zhihu.com/equation?tex=x" alt="x">的内积，<img src="https://www.zhihu.com/equation?tex=sign" alt="sign">是符号函数，其定义形式如下：</p><p>$$<br>sign=<br>\begin{cases}<br>-1,\quad x\leq 0\<br>1, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><p><strong>感知机只能做二分类问题</strong></p><p><strong>sklearn实现感知机</strong></p><p>生成数据集：生成1000个样本，每个样本4个特征，输出有2个类别，没有冗余特征，每个类别一个簇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line">x,y=make_classification(n_samples=<span class="number">1000</span>,n_features=<span class="number">4</span>,n_redundant=<span class="number">0</span>,n_informative=<span class="number">1</span>,n_clusters_per_class=<span class="number">1</span>,n_classes=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape,y.shape)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">(<span class="number">1000</span>, <span class="number">4</span>) (<span class="number">1000</span>,)</span><br></pre></td></tr></table></figure><p>数据预处理：划分数据集并标准化数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">x_train,x_test,y_train,y_test=train_test_split(x,y)</span><br><span class="line">std = StandardScaler()</span><br><span class="line">x_train = std.fit_transform(x_train)P</span><br><span class="line">x_test = std.fit_transform(x_test)</span><br><span class="line"><span class="built_in">print</span>(x_train.shape,x_test.shape)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">(<span class="number">750</span>, <span class="number">4</span>) (<span class="number">250</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>训练和评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">model = Perceptron()</span><br><span class="line">model.fit(x_train,y_train)</span><br><span class="line">y_pred = model.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(accuracy_score(y_pred,y_test))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">0.996</span></span><br></pre></td></tr></table></figure><h2 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h2><p>在所有的机器学习分类算法中，朴素贝叶斯和其他绝大多数的分类算法都不同。对于大多数的分类算法，比如决策树,KNN,逻辑回归，支持向量机等，他们都是判别方法，也就是直接学习出特征输出Y和特征X之间的关系，要么是决策函数Y=f(x),要么是决策条件分布P(Y|X)，但是朴素贝叶斯却是生成方法，也就是直接找出特征输出Y和特征X的联合分布，然后由P(Y|X)=P(X,Y)/P(X)得出分类的结果。</p><p>如果想了解朴素贝叶斯算法的可以移步</p><p><strong>sklearn中的贝叶斯分类器</strong></p><p>Sklearn基于数据分布以及这些分布上的概率估计的改进，为我们提供了四个朴素贝叶斯的分类器。</p><table><thead><tr><th><strong>类</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>naive_bayes.BernoulliNB</td><td>伯努利分布下的朴素贝叶斯</td></tr><tr><td>naive_bayes.GaussianNB</td><td>高斯分布下的朴素贝叶斯</td></tr><tr><td>naive_bayes.MultinomialNB</td><td>多项式分布下的朴素贝叶斯</td></tr><tr><td>naive_bayes.ComplementNB</td><td>补集朴素贝叶斯</td></tr><tr><td>linear_model.BayesianRidge</td><td>贝叶斯岭回归，在参数估计过程中使用贝叶斯回归技术来包括正则化参数</td></tr></tbody></table><p>虽然朴素贝叶斯使用了过于简化的假设，这个分类器在许多实际情况中都运行良好，著名的是文档分类和垃圾邮件过滤。而且由于贝叶斯是从概率角度进行估计，它所需要的样本量比较少，极端情况下甚至可以使用1%的数据作为训练集，依然可以得到很好的拟合效果。当然，如果样本量少于特征数目，贝叶斯效果就会被削弱（这对于任何算法都是一样的）。<br>与SVM和随机森林相比，朴素贝叶斯运行速度更快，因为求解P ( X i ∣ Y )本质是在每个特征上单独对概率进行计算，然后再求乘积，所以每个特征上的计算可以是独立并且并行的，因此贝叶斯的计算速度比较快。不过相对的，贝叶斯的运行效果不是那么好，所以贝叶斯的接口调用的predict_proba其实也不是总指向真正的分类结果，这一点需要注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%cmd</span></span><br><span class="line"><span class="comment">#pip install watermark</span></span><br><span class="line"><span class="comment">#魔法命令必须是一个cell的第一部分内容</span></span><br><span class="line"><span class="comment">#注意load_ext这个命令只能够执行一次，再执行就会报错，要求用reload命令</span></span><br><span class="line">%load_ext watermark</span><br><span class="line">%watermark -a <span class="string">&quot;86188&quot;</span> -d -v -m -p numpy,pandas,matplotlib,scipy,sklearn</span><br><span class="line"><span class="comment">#导入需要的库和数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">x,y = digits.data, digits.target</span><br><span class="line">xtrain,xtest,ytrain,ytest = train_test_split(x,y,test_size = <span class="number">0.3</span>,random_state = <span class="number">420</span>)</span><br><span class="line">xtrain.shape<span class="comment">#64个特征</span></span><br><span class="line"><span class="comment">#结果：(1257, 64)</span></span><br><span class="line">xtest.shape</span><br><span class="line"><span class="comment">#结果：(540, 64)</span></span><br><span class="line">np.unique(ytrain)<span class="comment">#多分类问题，类别是10个</span></span><br><span class="line"><span class="comment">#结果：array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建模，探索建模结果</span></span><br><span class="line">gnb = GaussianNB().fit(xtrain,ytrain)</span><br><span class="line"><span class="comment">#查看分数</span></span><br><span class="line">acc_score = gnb.score(xtest,ytest)</span><br><span class="line">acc_score</span><br><span class="line"><span class="comment">#结果：0.8592592592592593</span></span><br><span class="line"><span class="comment">#查看预测结果</span></span><br><span class="line">y_pred = gnb.predict(xtest)</span><br><span class="line"><span class="comment">#查看预测的概率结果</span></span><br><span class="line">prob = gnb.predict_proba(xtest)</span><br><span class="line">prob.shape<span class="comment">#每一列对应一个标签类别下的概率</span></span><br><span class="line"><span class="comment">#结果：(540, 10)</span></span><br><span class="line">prob[<span class="number">1</span>:].<span class="built_in">sum</span>()<span class="comment">#每一行的和都是1</span></span><br><span class="line"><span class="comment">#结果：1.000000000000003</span></span><br><span class="line">prob.<span class="built_in">sum</span>(axis=<span class="number">1</span>).shape</span><br><span class="line"><span class="comment">#结果：(540,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用混淆矩阵来查看贝叶斯的分类结果</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix <span class="keyword">as</span> CM</span><br><span class="line">CM(ytest,y_pred)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">array([[47,  0,  0,  0,  0,  0,  0,  1,  0,  0],</span></span><br><span class="line"><span class="string">       [ 0, 46,  2,  0,  0,  0,  0,  3,  6,  2],</span></span><br><span class="line"><span class="string">       [ 0,  2, 35,  0,  0,  0,  1,  0, 16,  0],</span></span><br><span class="line"><span class="string">       [ 0,  0,  1, 40,  0,  1,  0,  3,  4,  0],</span></span><br><span class="line"><span class="string">       [ 0,  0,  1,  0, 39,  0,  1,  4,  0,  0],</span></span><br><span class="line"><span class="string">       [ 0,  0,  0,  2,  0, 58,  1,  1,  1,  0],</span></span><br><span class="line"><span class="string">       [ 0,  0,  1,  0,  0,  1, 49,  0,  0,  0],</span></span><br><span class="line"><span class="string">       [ 0,  0,  0,  0,  0,  0,  0, 54,  0,  0],</span></span><br><span class="line"><span class="string">       [ 0,  3,  0,  1,  0,  0,  0,  2, 55,  0],</span></span><br><span class="line"><span class="string">       [ 1,  1,  0,  1,  2,  0,  0,  3,  7, 41]], dtype=int64)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#注意，ROC曲线是不能用于多分类的。多分类状况下最佳的模型评估指标是混淆矩阵和整体的准确度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>逻辑回归（logistic regression）属于机器学习中的监督算法.</p><p>虽然名字中带有“回归”二字，但却干着分类的活~这主要是由于sigmod和softmax函数的特点，可以将任意实数映射到（0，1）区间，这样我们就可以得到一个概率值，根据概率的大小，再结合定下的阈值，就可以进行分类。</p><p>逻辑回归相关的类：</p><blockquote><p>linear_model.LogisticRegression：逻辑回归分类器（又叫logit，最大熵分类器）<br>linear_model.LogisticRegressionCV：带交叉验证的逻辑回归分类器<br>linear_model.logistic_regression_path：计算Logistic回归模型以获得正则化参数的列表<br>linear_model.SGDClasiifier：利用梯度下降求解的线性分类器（SVM，逻辑回归等）<br>linear_model.SGDRegressor：利用梯度下降最小化正则化后的损失函数的线性回归模型<br>metrics.log_loss：对数损失，又称逻辑损失或交叉熵损失</p></blockquote><p>注：linear_model.RandomizedLogisticsRegression（随机的逻辑回归）在sklearn0.21版本中即将被移除</p><p><strong>其他会涉及的类</strong>：</p><blockquote><p>metrics.confusion_matrix：混淆矩阵，模型评估指标之一<br>metrics.roc_auc_score：ROC曲线，模型评估指标之一<br>metrics.accuracy_score：精确性，模型评估指标之一</p></blockquote><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris   <span class="comment"># 导入鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split   <span class="comment"># 导入数据划分函数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression   <span class="comment"># 导入逻辑回归</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入评价指标</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score   </span><br></pre></td></tr></table></figure><p>属于处理</p><p>鸢尾花的label原本是3类，这里为了展示二分类，我只取了鸢尾花的前100个数据，也就是label只有0和1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line"> </span><br><span class="line">iris_X = iris.data[:<span class="number">100</span>, ]   <span class="comment"># x有4个属性，共有100个样本</span></span><br><span class="line">iris_X</span><br><span class="line"></span><br><span class="line">iris_y = iris.target[:<span class="number">100</span>, ] <span class="comment"># y的取值有2个，分别是0,1</span></span><br><span class="line">iris_y</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_X, iris_y, test_size=<span class="number">0.3</span>)   <span class="comment"># 划分训练/测试集</span></span><br><span class="line"><span class="built_in">print</span>(X_train.shape)</span><br><span class="line"><span class="built_in">print</span>(X_test.shape)</span><br></pre></td></tr></table></figure><p>训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = LogisticRegression()   <span class="comment"># 选逻辑回归作为分类器</span></span><br><span class="line">model.fit(X_train, y_train)   <span class="comment"># 训练模型</span></span><br></pre></td></tr></table></figure><p>评估模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y_test_pred = model.predict(X=X_test)   <span class="comment"># 预测测试集的label</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(y_test_pred)   <span class="comment"># 模型预测的测试集label</span></span><br><span class="line"><span class="built_in">print</span>(y_test)   <span class="comment"># 测试集实际label </span></span><br><span class="line"></span><br><span class="line">accuracy_score(y_test, y_test_pred) <span class="comment"># 查看模型预测的准确率</span></span><br><span class="line"></span><br><span class="line">pred = model.predict_proba(X_test)   <span class="comment"># 查看测试集样本对应的概率值</span></span><br><span class="line">pred</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(model.coef_)   <span class="comment"># 查看变量参数</span></span><br><span class="line"><span class="built_in">print</span>(model.intercept_)   <span class="comment"># 查看常数参数项</span></span><br></pre></td></tr></table></figure><h2 id="SVM算法"><a href="#SVM算法" class="headerlink" title="SVM算法"></a>SVM算法</h2><blockquote><p>  支持向量机(support vector machines,SVM)是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器。除此之外，SVM算法还包括核函数，核函数可以使它成为非线性分类器。在了解SVM算法之前，我们要先认识一下线性分类器。</p><p>线性分类器：假设在一个二维线性可分的数据集中，我们要找到一个超平面把两组数据分开，已知的方法有我们已经学过的线性回归和逻辑回归，这条直线可以有很多种，如下图的H1、H2、H3哪一条直线的效果最好呢，也就是说哪条直线可以使两类的空间大小相隔最大呢？</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/68cf3d04a294b7f304c44d8a1a33ba3e.png" alt="img"></p><p>   我们凭直观感受应该觉得答案是H3。首先H1不能把类别分开，这个分类器肯定是不行的；H2可以，但分割线与最近的数据点只有很小的间隔，如果测试数据有一些噪声的话可能就会被H2错误分类(即对噪声敏感、泛化能力弱)。H3以较大间隔将它们分开，这样就能容忍测试数据的一些噪声而正确分类，是一个泛化能力不错的分类器。因此我们把这个划分数据的决策边界就叫做超平面。离这个超平面最近的点就是”支持向量”,点到超平面的距离叫做间隔，支持向量机的意思就是使超平面和支持向量之间的间隔尽可能的大，这样才可以使两类样本准确地分开。  </p><p>支持向量机的种类：      </p><blockquote><p>a) 线性可分SVM：当数据线性可分的时候，通过硬间隔最大化可以学习得到一个线性分类器，即硬间隔SVM，如上图的H3</p><p>b) 线性SVM:当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(soft margin)最大化也可以学习到一个线性分类器，即软间隔SVM</p><p>c) 非线性SVM：</p><p>当训练数据线性不可分时，通过使用核技巧(kernel trick)和软间隔最大化，可以学习到一个非线性SVM。</p></blockquote><p>超平面与间隔：</p><p><img src="https://img-blog.csdnimg.cn/20200916085324603.png" alt="在这里插入图片描述"></p><blockquote><p> 我们从图上可以看到，这条中间的实线代表的超平面离直线两边的数据的间隔最大，对训练集的数据的噪声有最大的包容力。</p></blockquote><p>函数原型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, coef0=<span class="number">0.0</span>,decision_function_shape=<span class="literal">None</span>, degree=<span class="number">3</span>, gamma=‘auto’, kernel=‘rbf’,max_iter=-<span class="number">1</span>, probability=<span class="literal">False</span>, random_state=<span class="literal">None</span>, shrinking=<span class="literal">True</span>,</span><br><span class="line">tol=<span class="number">0.001</span>, verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关的包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  <span class="comment"># 绘图功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建 40 个点</span></span><br><span class="line">np.random.seed(<span class="number">0</span>) <span class="comment"># 让每次运行程序生成的随机样本点不变</span></span><br><span class="line"><span class="comment"># 生成训练实例并保证是线性可分的</span></span><br><span class="line"><span class="comment"># np._r表示将矩阵在行方向上进行相连</span></span><br><span class="line"><span class="comment"># random.randn(a,b)表示生成 a 行 b 列的矩阵，且随机数服从标准正态分布</span></span><br><span class="line"><span class="comment"># array(20,2) - [2,2] 相当于给每一行的两个数都减去 2</span></span><br><span class="line">X = np.r_[np.random.randn(<span class="number">20</span>, <span class="number">2</span>) - [<span class="number">2</span>, <span class="number">2</span>], np.random.randn(<span class="number">20</span>, <span class="number">2</span>) + [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="comment"># 两个类别 每类有 20 个点，Y 为 40 行 1 列的列向量</span></span><br><span class="line">Y = [<span class="number">0</span>] * <span class="number">20</span> + [<span class="number">1</span>] * <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 建立 svm 模型</span></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获得划分超平面</span></span><br><span class="line"><span class="comment"># 划分超平面原方程：w0x0 + w1x1 + b = 0</span></span><br><span class="line"><span class="comment"># 将其转化为点斜式方程，并把 x0 看作 x，x1 看作 y，b 看作 w2</span></span><br><span class="line"><span class="comment"># 点斜式：y = -(w0/w1)x - (w2/w1)</span></span><br><span class="line">w = clf.coef_[<span class="number">0</span>]  <span class="comment"># w 是一个二维数据，coef 就是 w = [w0,w1]</span></span><br><span class="line">a = -w[<span class="number">0</span>] / w[<span class="number">1</span>]  <span class="comment"># 斜率</span></span><br><span class="line">xx = np.linspace(-<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 从 -5 到 5 产生一些连续的值（随机的）</span></span><br><span class="line"><span class="comment"># .intercept[0] 获得 bias，即 b 的值，b / w[1] 是截距</span></span><br><span class="line">yy = a * xx - (clf.intercept_[<span class="number">0</span>]) / w[<span class="number">1</span>]  <span class="comment"># 带入 x 的值，获得直线方程</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 画出和划分超平面平行且经过支持向量的两条线（斜率相同，截距不同）</span></span><br><span class="line">b = clf.support_vectors_[<span class="number">0</span>] <span class="comment"># 取出第一个支持向量点</span></span><br><span class="line">yy_down = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>]) </span><br><span class="line">b = clf.support_vectors_[-<span class="number">1</span>] <span class="comment"># 取出最后一个支持向量点</span></span><br><span class="line">yy_up = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看相关的参数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w: &quot;</span>, w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a: &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;support_vectors_: &quot;</span>, clf.support_vectors_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;clf.coef_: &quot;</span>, clf.coef_)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在 scikit-learin 中，coef_ 保存了线性模型中划分超平面的参数向量。形式为(n_classes, n_features)。若 n_classes &gt; 1，则为多分类问题，(1，n_features) 为二分类问题。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 绘制划分超平面，边际平面和样本点</span></span><br><span class="line">pl.plot(xx, yy, <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_down, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_up, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"><span class="comment"># 圈出支持向量</span></span><br><span class="line">pl.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">           s=<span class="number">80</span>, facecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">pl.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=Y, cmap=pl.cm.Paired)</span><br><span class="line"> </span><br><span class="line">pl.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><h3 id="随机森林简介"><a href="#随机森林简介" class="headerlink" title="随机森林简介"></a>随机森林简介</h3><p>随机森林应该是很多小伙伴们在学机器学习算法时最先接触到的集成算法，我们先简单介绍一下集成学习的大家族吧</p><ul><li>Bagging：个体评估器之间不存在强依赖关系，一系列个体学习器可以并行生成。代表算法：随机森林（Random Forest）</li><li>Boosting：个体学习器之间存在强依赖关系，一系列个体学习器基本都需要串行生成。代表算法：AdaBoost、GBDT、XGBoost、LightGBM</li></ul><p>在Bagging集成中，需要并行建立多个弱评估器（非线性算法），然后综合多个弱评估器的结果进行输出：</p><ul><li>Bootstrap: 从原始样本集中采用有放回抽样的方式抽取n个训练样本，共进行k轮抽取，得到k个相互独立的训练集。</li><li>对每个训练集进行训练，得到k个模型。</li><li>对分类问题：预测结果为k个分类器投票方式得到的分类结果，少数服从多数。</li><li>对回归问题：将学习器的均值作为预测结果。</li></ul><p>随机森林是bagging家族的代表算法，它的算法思想体现在它的名字上：“随机”和“森林”。首先“森林”是指随机森林的所有基学习器都是决策树，“随机”是指随机从原样本集中抽取样本和特征来训练，并不会使用所有的样本和特征，每棵树独立地有放回抽样，这就保证了每棵树所使用的数据集是不同的，进而所生成的树也是有差异的，最后集成所有树的决策结果，得到最终结果。具体算法流程如下：</p><p>从样本中随机抽取不同的子集，用于建立不同的决策树，在<strong>按照Bagging的规则对决策结果进行集成：</strong></p><ol><li>从M个的原始样本集中采用有放回抽样的方式抽取m个训练样本，共进行k轮抽取，得到k个相互独立的训练集，即有k个基学习器，注意：每颗树的特征并不是在建树前就抽好的，而是在每棵树分裂的节点进行抽样</li><li>用决策树算法对每个训练集进行训练，得到k个树</li><li>对分类问题：预测结果为k个分类器投票方式得到的分类结果，少数服从多数</li><li>对回归问题：将学习器的均值作为预测结果</li></ol><h3 id="导入各种包"><a href="#导入各种包" class="headerlink" title="导入各种包"></a>导入各种包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split  </span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier   </span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>为了方便大家代码复现，本次使用的是python自带的泰坦尼克号数据集，共981个样本，特征涉及性别、年龄、船票价格、是否有同伴等等，标签列有两个，分别是‘survived’和‘alive’，都表示该乘客是否生还，所以我们取一列就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = sns.load_dataset(<span class="string">&#x27;titanic&#x27;</span>)  <span class="comment"># 导入泰坦尼克号生还数据</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a8d74c7088ff4eb59deec83ccd2c7cc2.png" alt="img"></p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.replace(to_replace=<span class="string">r&#x27;^\s*$&#x27;</span>, value=np.nan, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)   <span class="comment"># 把各类缺失类型统一改为NaN的形式</span></span><br><span class="line">data.isnull().mean()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/02146917e65648aaa1a75272c6685929.png" alt="img"></p><p>共4列数据存在缺失值，‘deck’缺失率超过70%，予以删除，剩余特征的缺失值使用其均值或是众数进行填补</p><p>细心地童鞋可能发现了有好几列重复的特征，‘embarked’和‘embark_town’都表示出发港口，‘sex’、‘who’、‘adult_male’都表示性别，‘pclass’和‘class’都是船票类型，‘sibsp’和‘alone’都表示是否有同伴，对于这几个特征，所以我们保留其中一个就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;deck&#x27;</span>]   <span class="comment"># 删除‘deck’列</span></span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;who&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;adult_male&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;alone&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">data[<span class="string">&#x27;age&#x27;</span>].fillna(np.mean(data.age), inplace=<span class="literal">True</span>)   <span class="comment"># 年龄特征使用均值对缺失值进行填补</span></span><br><span class="line">data[<span class="string">&#x27;embarked&#x27;</span>].fillna(data[<span class="string">&#x27;embarked&#x27;</span>].mode(dropna=<span class="literal">False</span>)[<span class="number">0</span>], inplace=<span class="literal">True</span>)   <span class="comment"># 文本型特征视同众数进行缺失值填补</span></span><br><span class="line"> </span><br><span class="line">x = data.drop([<span class="string">&#x27;alive&#x27;</span>, <span class="string">&#x27;survived&#x27;</span>, <span class="string">&#x27;embark_town&#x27;</span>], axis=<span class="number">1</span>)   <span class="comment"># 取出用于建模的特征列X</span></span><br><span class="line">label = data[<span class="string">&#x27;survived&#x27;</span>]   <span class="comment"># 取出标签列Y</span></span><br></pre></td></tr></table></figure><p> sklean中的随机森林算法是无法进行字符串的处理的，所以要先进行数据编码，这里我们就使用最简单的特征编码，转化完毕后特征全部变为数值型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oe = OrdinalEncoder()   <span class="comment"># 定义特征转化函数</span></span><br><span class="line"> <span class="comment"># 把需要转化的特征都写进去</span></span><br><span class="line">x[[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;embarked&#x27;</span>]] = oe.fit_transform(x[[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;embarked&#x27;</span>]])  </span><br><span class="line">x.head()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d57f05fc499f42dca2e0ced7feab38a2.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#划分训练集、测试集</span></span><br><span class="line">xtrain, xtest, ytrain, ytest = train_test_split(x, label, test_size=<span class="number">0.3</span>)</span><br><span class="line">xtrain.head()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7e5dff4b5f9c4a0da56e432df49adeaa.png" alt="img"></p><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">随机森林所有超参数</span></span><br><span class="line"><span class="string">sklearn.ensemble.RandomForestClassifier (n_estimators=100, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, </span></span><br><span class="line"><span class="string">                                         min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, </span></span><br><span class="line"><span class="string">                                         min_impurity_split=None, class_weight=None, random_state=None, bootstrap=True, oob_score=False, </span></span><br><span class="line"><span class="string">                                         n_jobs=None, verbose=0, warm_start=False)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 单颗决策树</span></span><br><span class="line">clf = DecisionTreeClassifier(class_weight=<span class="string">&#x27;balanced&#x27;</span>,random_state=<span class="number">37</span>)   </span><br><span class="line">clf = clf.fit(xtrain, ytrain)   <span class="comment"># 拟合训练集</span></span><br><span class="line">score_c = clf.score(xtest, ytest)   <span class="comment"># 输出测试集准确率</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机森林</span></span><br><span class="line">rfc = RandomForestClassifier(class_weight=<span class="string">&#x27;balanced&#x27;</span>,random_state=<span class="number">37</span>)   </span><br><span class="line">rfc = rfc.fit(xtrain, ytrain)</span><br><span class="line">score_r = rfc.score(xtest, ytest)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4183b32c94d1428ab35068a9eb569544.png" alt="img"></p><p>这里的score封装的是准确率，即（模型预测正确的样本量）/（模型的总样本量），因此容易受到样本不均匀的影响，尤其是像癌症预测、信贷逾期预测之类的模型，响应样本的占比就很少，100个人中可能就1个人会有逾期的行为，对于这种情况，我们应该使用AUC这类评价指标，可以平衡样本量偏颇带来的影响，那下面我们来看一看单科决策树和随机森林的AUC情况吧。</p><h3 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 决策树 预测测试集</span></span><br><span class="line">y_test_proba_clf = clf.predict_proba(xtest)</span><br><span class="line">false_positive_rate_clf, recall_clf, thresholds_clf = roc_curve(ytest, y_test_proba_clf[:, <span class="number">1</span>])  </span><br><span class="line"><span class="comment"># 决策树 AUC指标</span></span><br><span class="line">roc_auc_clf = auc(false_positive_rate_clf, recall_clf)     </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机森林 预测测试集</span></span><br><span class="line">y_test_proba_rfc = rfc.predict_proba(xtest)</span><br><span class="line">false_positive_rate_rfc, recall_rfc, thresholds_rfc = roc_curve(ytest, y_test_proba_rfc[:, <span class="number">1</span>])  </span><br><span class="line"><span class="comment"># 随机森林 AUC指标</span></span><br><span class="line">roc_auc_rfc = auc(false_positive_rate_rfc, recall_rfc)     </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 画图 画出俩模型的ROC曲线</span></span><br><span class="line">plt.plot(false_positive_rate_clf, recall_clf, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;AUC_clf=%0.3f&#x27;</span> % roc_auc_clf) </span><br><span class="line">plt.plot(false_positive_rate_rfc, recall_rfc, color=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;AUC_rfc=%0.3f&#x27;</span> % roc_auc_rfc)  </span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>, fontsize=<span class="number">15</span>, frameon=<span class="literal">False</span>)  </span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&#x27;r--&#x27;</span>)  </span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])  </span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])  </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Recall&#x27;</span>)  </span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fall-out&#x27;</span>)  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c6eafdedff444aaea2a776652b9f6a47.png" alt="img"></p><p>来瞧一瞧看一看了昂，黄色实线代表随机森林的ROC曲线，蓝色实线代表单棵决策树的ROC曲线，在俩模型均未调参的情况下，明显随机森林的模型效果要比单科决策树的好对吧，所以集成算法还是牛的~</p><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>接下来我们尝试通过调整随机森林的超参数，来提高模型的性能，评价指标设为AUC</p><p>由于随机森林的基学习器均为决策树，因此我们调参的方向也和决策树相同，主要通过控制剪枝的相关参数来防止模型过拟合，这里我们选择两个参数进行调整，分别是：基学习器数量n_estimators和树深max_depth，大家可以使用网格搜索等自动调参工具，这里为了演示调参过程，我们来手动调整参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义空列表，用来存放每一个基学习器数量所对应的AUC值</span></span><br><span class="line">superpa = []</span><br><span class="line"><span class="comment"># 循环200次</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    rfc = ensemble.RandomForestClassifier(n_estimators=i+<span class="number">1</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>,random_state=<span class="number">37</span>, n_jobs=<span class="number">10</span>)</span><br><span class="line">    rfc = rfc.fit(xtrain, ytrain)   <span class="comment"># 拟合模型</span></span><br><span class="line">    </span><br><span class="line">    y_test_proba_rfc = rfc.predict_proba(xtest)   <span class="comment"># 预测测试集</span></span><br><span class="line">    false_positive_rate_rfc, recall_rfc, thresholds_rfc = roc_curve(ytest, y_test_proba_rfc[:, <span class="number">1</span>])  </span><br><span class="line">    roc_auc_rfc = auc(false_positive_rate_rfc, recall_rfc)   <span class="comment"># 计算模型AUC</span></span><br><span class="line">    </span><br><span class="line">    superpa.append(roc_auc_rfc)   <span class="comment"># 记录每一轮的AUC值</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(superpa),superpa.index(<span class="built_in">max</span>(superpa)))   <span class="comment"># 输出最大的AUC值和其对应的轮数</span></span><br><span class="line">plt.figure(figsize=[<span class="number">20</span>,<span class="number">5</span>])</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">201</span>),superpa)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b88ac185b89744b396343955ad5e0198.png" alt="img"></p><p>最大AUC为0.8871，对应的轮数是107，即基学习器数量为108时AUC取得最大值0.8871，接下来固定基学习器个数，调整最大树深</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">superpa = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    rfc = ensemble.RandomForestClassifier(max_depth=i+<span class="number">1</span>, n_estimators=<span class="number">185</span>,</span><br><span class="line">                                          class_weight=<span class="string">&#x27;balanced&#x27;</span>, random_state=<span class="number">37</span>, n_jobs=<span class="number">10</span>)</span><br><span class="line">    rfc = rfc.fit(xtrain, ytrain)</span><br><span class="line">    </span><br><span class="line">    y_test_proba_rfc = rfc.predict_proba(xtest)</span><br><span class="line">    false_positive_rate_rfc, recall_rfc, thresholds_rfc = roc_curve(ytest, y_test_proba_rfc[:, <span class="number">1</span>])  </span><br><span class="line">    roc_auc_rfc = auc(false_positive_rate_rfc, recall_rfc) </span><br><span class="line">    </span><br><span class="line">    superpa.append(roc_auc_rfc)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(superpa),superpa.index(<span class="built_in">max</span>(superpa)))</span><br><span class="line">plt.figure(figsize=[<span class="number">20</span>,<span class="number">5</span>])</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>),superpa)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/236d1ee310c24c9d9697bd5f4a753ee8.png" alt="img"></p><p>i=6即树深为7的时候，AUC达到最值0.8983</p><p>到此我们调参就结束了，我们通过手动调参，先找到最佳基学习器数量，在此基础上在寻找最佳树深， 但实际上不同的参数组合带来的效果是不同的，啥意思呢，举例说：</p><p>我们这边先固定学习器的数量为108，再去找树深，然后我们认为（学习器数量108+树深7）为最佳组合，但是当我们的树深为7时，基学习器的最佳选择可能就不是108了，因为这个108是在不限制树深的情况下跑出来的结果</p><p>所以自动调参机器网格搜索就是去枚举尽可能多的参数组合，从中找出最佳的，来弥补手动调参的弊端，但是随着超参数的增加，参数组合可以说是无穷无尽，所以网格搜索也只是尽量找到最佳组合，调参这个工作还是看经验，调的多了慢慢就有感觉了，毕竟调参是门玄学O(∩_∩)O哈哈~</p><h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><p>今天要说的Adaboost算是boosting中比较元老级别的算法了，我们先来说说boosting算法的特点吧</p><ul><li>它和bagging算法不同，boosting是通过降低整体的偏差来降低泛化误差，因此被称为提升法</li><li>相对于bagging，boosting算法在原理和操作上难度都更大</li><li>由于boosting算法专注于降低与真实值之间的偏差，因此boosting在模型效果上表现突出</li></ul><p>Adaboost(Adaptive Boosting, 自适应增强)是较为早期的boosting算法，所以他的构筑过程相对于其他boosting算法来说都是较为简单直观的，如果你不能够透彻地理解gbdt或是xgboost的原理，可以先从Adaboost入手，懂弄了之后再去看更复杂的集成算法，可能就不会很困难啦！</p><p>Adaboost的算法原理如下：</p><ol><li>基于全部样本建立一颗决策树</li><li>根据第一颗决策树的预测结果与真实值之间的偏差，增加被预测错误的样本在原数据集中的权重，并让加权后的全部样</li><li>作为下一颗决策树的训练样本</li><li>用加权后的数据建立第二颗树，查看第二棵树被预测错误的样本，根据这个结果修正样本权重用于第三棵树</li><li>一直循环上述过程，直到预测误差小于设定的阈值内，终止迭代，停止生成树</li></ol><p>在理解Adaboost算法的时候，有两点需要注意的地方哦：①和随机森林不同，Adaboost不进行样本和特征的抽样，会用全部样本和特征来建立每一个基学习器；②整个算法过程中涉及两个权重的迭代更新，一个是样本权重，根据每轮基学习器的预测结果，增加预测错误样本对应的权重，实质上就是我们在建立下一个基学习器时，会更重视上一轮被预测错误的样本，尽量避免它在这一轮又被预测错误，以此来不断修正错误，进而我们的集成所有的基学习器后，正确率就会高很多，还有一个权重是每一个基学习器的权重，这个权重由每一个基学习器的分类误差率决定，分类误差率越低，基学习器的权重越高，说白了就是能力越大责任越大，预测的准的基学习器就给它话语权，它说了算</p><p>具体算法公式啥的大家就自行学习理解叭，我们今天主要是说如何使用sklearn包来实现Adaboost以及简单的调参演示，话不多说上代码~</p><h3 id="导入各种包-1"><a href="#导入各种包-1" class="headerlink" title="导入各种包"></a>导入各种包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier  </span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> graphviz </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>为了方便大家代码复现，本次使用的是python自带的泰坦尼克号数据集，共981个样本，特征涉及性别、年龄、船票价格、是否有同伴等等，标签列有两个，分别是‘survived’和‘alive’，都表示该乘客是否生还，所以我们取一列就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = sns.load_dataset(&#x27;titanic&#x27;)  # 导入泰坦尼克号生还数据</span><br><span class="line">data</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/35b01a01ac574f0aaeec1f3e57e81d28.png" alt="img"></p><h3 id="数据预处理-1"><a href="#数据预处理-1" class="headerlink" title="数据预处理"></a>数据预处理</h3><p> 首先进行数据的预处理，首先可以看到‘deck’列存在缺失值，我们可以看看总体数据缺失的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.replace(to_replace=r&#x27;^\s*$&#x27;, value=np.nan, regex=True, inplace=True)   # 把各类缺失类型统一改为NaN的形式</span><br><span class="line">data.isnull().mean()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/84327b8961134a2e8d175981bdcbe520.png" alt="img"></p><p>共4列数据存在缺失值，‘deck’缺失率超过70%，予以删除，剩余特征的缺失值使用其均值或是众数进行填补</p><p>细心地童鞋可能发现了有好几列重复的特征，‘embarked’和‘embark_town’都表示出发港口，‘sex’、‘who’、‘adult_male’都表示性别，‘pclass’和‘class’都是船票类型，‘sibsp’和‘alone’都表示是否有同伴，对于这几个特征，所以我们保留其中一个就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;deck&#x27;</span>]   <span class="comment"># 删除‘deck’列</span></span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;who&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;adult_male&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">&#x27;alone&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">data[<span class="string">&#x27;age&#x27;</span>].fillna(np.mean(data.age), inplace=<span class="literal">True</span>)   <span class="comment"># 年龄特征使用均值对缺失值进行填补</span></span><br><span class="line">data[<span class="string">&#x27;embarked&#x27;</span>].fillna(data[<span class="string">&#x27;embarked&#x27;</span>].mode(dropna=<span class="literal">False</span>)[<span class="number">0</span>], inplace=<span class="literal">True</span>)   <span class="comment"># 文本型特征视同众数进行缺失值填补</span></span><br><span class="line"> </span><br><span class="line">x = data.drop([<span class="string">&#x27;alive&#x27;</span>, <span class="string">&#x27;survived&#x27;</span>, <span class="string">&#x27;embark_town&#x27;</span>], axis=<span class="number">1</span>)   <span class="comment"># 取出用于建模的特征列X</span></span><br><span class="line">label = data[<span class="string">&#x27;survived&#x27;</span>]   <span class="comment"># 取出标签列Y</span></span><br></pre></td></tr></table></figure><p>sklean中的Adaboost算法是无法进行字符串的处理的，所以要先进行数据编码，这里我们就使用最简单的特征编码，转化完毕后特征全部变为数值型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oe = OrdinalEncoder()   <span class="comment"># 定义特征转化函数</span></span><br><span class="line"> <span class="comment"># 把需要转化的特征都写进去</span></span><br><span class="line">x[[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;embarked&#x27;</span>]] = oe.fit_transform(x[[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;embarked&#x27;</span>]])  </span><br><span class="line">x.head()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d7d1e17b17b043cdb53eef2111b820c0.png" alt="img"></p><p>划分训练集、测试集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrain, xtest, ytrain, ytest = train_test_split(x, label, test_size=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><h3 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">slearn封装的Adaboost及其参数</span></span><br><span class="line"><span class="string">sklearn.ensemble.AdaBoostClassifier(base_estimator=None, n_estimators=50, learning_rate=1.0, algorithm=&#x27;SAMME.R&#x27;, random_state=None)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 这里同时训练了Adaboost分类模型和随机森林分类模型，用于对比模型效果</span></span><br><span class="line">rfc = RandomForestClassifier(class_weight=<span class="string">&#x27;balanced&#x27;</span>, random_state=<span class="number">37</span>)  <span class="comment"># 随机森林</span></span><br><span class="line">rfc = rfc.fit(xtrain, ytrain)</span><br><span class="line">score_r = rfc.score(xtest, ytest)</span><br><span class="line"> </span><br><span class="line">abc = AdaBoostClassifier(random_state=<span class="number">37</span>)  <span class="comment"># adaboost</span></span><br><span class="line">abc = abc.fit(xtrain, ytrain)  <span class="comment"># 拟合训练集</span></span><br><span class="line">score_a = abc.score(xtest, ytest)  <span class="comment"># 输出测试集准确率</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;随机森林:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(score_r), <span class="string">&quot; adaboost:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(score_a))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c4914d82a46d4dde8933402df659850b.png" alt="img"></p><p>从准确率这个指标来看，随机森林略胜一筹，但毕竟是分类问题，我们再使用AUC来评估模型，看一看是否随机森林效果更好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">y_test_proba_rfc = rfc.predict_proba(xtest)</span><br><span class="line">false_positive_rate_rfc, recall_rfc, thresholds_rfc = roc_curve(ytest, y_test_proba_rfc[:, <span class="number">1</span>])</span><br><span class="line">roc_auc_rfc = auc(false_positive_rate_rfc, recall_rfc)  <span class="comment"># 随机森林AUC指标</span></span><br><span class="line"> </span><br><span class="line">y_test_proba_abc = abc.predict_proba(xtest)</span><br><span class="line">false_positive_rate_abc, recall_abc, thresholds_abc = roc_curve(ytest, y_test_proba_abc[:, <span class="number">1</span>])</span><br><span class="line">roc_auc_abc = auc(false_positive_rate_abc, recall_abc)  <span class="comment"># adaboost AUC指标</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 画出俩模型对应的ROC曲线</span></span><br><span class="line">plt.plot(false_positive_rate_rfc, recall_rfc, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;AUC_rfc=%0.3f&#x27;</span> % roc_auc_rfc)</span><br><span class="line">plt.plot(false_positive_rate_abc, recall_abc, color=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;AUC_abc=%0.3f&#x27;</span> % roc_auc_abc)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>, fontsize=<span class="number">15</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Recall&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fall-out&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/75e26c1c34c14d0288d9076613f5976a.png" alt="img"></p><p>蓝色实线为随机森林的ROC曲线，黄色实线为Adaboost的ROC曲线，从AUC指标评估模型的话，随机森林效果是要更好的，而且AUC指标对于分类模型的评估还是很公平有效的</p><h3 id="调参-1"><a href="#调参-1" class="headerlink" title="调参"></a>调参</h3><p>这里设定Adaboost的基学习器为决策树，最大深度为2，当然你也可以设为别的分类算法，通过参数base_estimator进行设置，集成算法最重要的俩参数就是基学习器数量n_estimators和学习率learning_rate，这里我们就通过调整这两个参数来提升模型效果</p><p>网格搜索类似枚举法，把要调整的参数和参数范围设置完毕之后，它可以进行参数组合，找到模型效果最佳的模型组合，当需要调整的参数较多或参数范围很广时，网格搜索就会非常慢，有利有弊叭，所以一般的调参可以先手动调一调，找到参数大致的最优范围，再通过网格搜索去准确定位最优参数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 通过网格搜索法选择合理的Adaboost算法参数</span><br><span class="line">n_estimators = [10, 100, 200, 300, 400, 500, 600]</span><br><span class="line">learning_rate = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5]</span><br><span class="line">params2 = &#123;&#x27;n_estimators&#x27;:n_estimators,&#x27;learning_rate&#x27;:learning_rate&#125;</span><br><span class="line">adaboost = GridSearchCV(estimator = ensemble.AdaBoostClassifier(base_estimator=DecisionTreeClassifier(max_depth=2), </span><br><span class="line">                            algorithm=&quot;SAMME&quot;, random_state=37), </span><br><span class="line">                        param_grid= params2, scoring = &#x27;roc_auc&#x27;, cv = 5, n_jobs = 10, verbose = 1)</span><br><span class="line">adaboost.fit(xtrain, ytrain)</span><br><span class="line"> </span><br><span class="line">print(&#x27;best_params_:&#x27;, adaboost.best_params_) # 返回参数的最佳组合和对应AUC值</span><br><span class="line">print(&#x27;best_score_:&#x27;, adaboost.best_score_)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e84db8322722426ca41de7d6b7b0280e.png" alt="img"></p><p>这里给出的最佳参数为100个基学习器搭配0.2的学习率，AUC达到0.86，那我们就认为这是最佳的参数组合，带入模型看看效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abc = ensemble.AdaBoostClassifier(base_estimator=DecisionTreeClassifier(max_depth=2),</span><br><span class="line">                                  n_estimators=100, learning_rate=0.2, algorithm=&quot;SAMME&quot;, random_state=37)</span><br><span class="line">abc = abc.fit(xtrain, ytrain)</span><br><span class="line"> </span><br><span class="line">y_test_proba_abc = abc.predict_proba(xtest)</span><br><span class="line">false_positive_rate_abc, recall_abc, thresholds_abc = roc_curve(ytest, y_test_proba_abc[:, 1])  </span><br><span class="line">auc(false_positive_rate_abc, recall_abc)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9dcc350728eb48f2a7be0175fe9bce45.png" alt="img"></p><p>带入模型后可以看到AUC值为0.87，和刚才的0.86并不相同，因为我们在调参时，设置了CV=5，就是使用了5折交叉验证，把数据分为五份，每一份都去训练评估得到一个AUC值，而这个0.86就是这5个AUC值得均值，后面把调参出来的组合带入模型后，使用的是原始的训练集合测试集，一般来说得到的AUC值都会产生波动，高点或者低点都是很正常的</p><h2 id="聚类算法（K-means）"><a href="#聚类算法（K-means）" class="headerlink" title="聚类算法（K-means）"></a>聚类算法（K-means）</h2><h3 id="K-means算法的流程："><a href="#K-means算法的流程：" class="headerlink" title="K-means算法的流程："></a>K-means算法的流程：</h3><p>1.随机选取K个中心点</p><p>2.遍历数据集里面的每个点，看距离哪个中心点最近就分为哪一类，遍历完一共K类</p><p>3.把属于一类的点取平均值，得到的平均值作为新的中心点</p><p>4.然后不断重复步骤2，3，直到达到结束条件为止。（当中心点不再变动或变动很小，当达到最大迭代次数）</p><h3 id="K-means算法的优缺点及算法复杂度"><a href="#K-means算法的优缺点及算法复杂度" class="headerlink" title="K-means算法的优缺点及算法复杂度"></a>K-means算法的优缺点及算法复杂度</h3><p><strong>优点：</strong></p><p>原理简单，算法复杂度较低</p><p><strong>缺点：</strong></p><p>k值未知，需要人为设定</p><p>对于初始化中心点特别敏感，不同的初始化，结果可能不一样</p><p>容易受到噪声的影响，可能收敛于局部最小值，同时数据量大时收敛速度较慢</p><p>不太适合离散的数据，样本类别不均衡的数据的聚类</p><p>k-means 有一个重要特征，它要求这些簇的模型必须是圆形：k-means 算法没有内置的方法<br>来实现椭圆形的簇</p><p><strong>算法复杂度：</strong></p><p>O(tkn*d)  t是迭代次数，k是类数，n是数据点个数，d是数据维度</p><h3 id="K-means算法的调优与改进"><a href="#K-means算法的调优与改进" class="headerlink" title="K-means算法的调优与改进"></a>K-means算法的调优与改进</h3><p>k值的选取问题，K-means++，或者先使用谱聚类或层次聚类对样本进行聚类，得到K</p><p>，或使用手肘法，遍历可能的K值，画出该点下Loss的大小，选择曲线的拐点处的K值</p><p>对于数据量大的情况，可以选择mini-batch的方法，不过准确度会下降</p><p>初始点敏感的问题，可以选择多种初始点情况，选择误差最小的一种</p><p>噪声影响问题，K-medoids，将步骤3改为，求一个类里面，每个点到类内其他点距离和最小的，选择它作为我们下一步的中心点，这样就有效缓解了噪声问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x,y = make_blobs(n_samples=<span class="number">1000</span>,n_features=<span class="number">4</span>,centers=[[-<span class="number">1</span>,-<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]],cluster_std=[<span class="number">0.4</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.4</span>],random_state=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">k_means = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">k_means.fit(x)</span><br><span class="line"></span><br><span class="line">y_predict = k_means.predict(x)</span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>],c=y_predict)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(k_means.predict((x[:<span class="number">30</span>,:])))</span><br><span class="line"><span class="built_in">print</span>(metrics.calinski_harabasz_score(x,y_predict))</span><br><span class="line"><span class="built_in">print</span>(k_means.cluster_centers_)</span><br><span class="line"><span class="built_in">print</span>(k_means.inertia_)</span><br><span class="line"><span class="built_in">print</span>(metrics.silhouette_score(x,y_predict))</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2672.175134496046</span></span><br><span class="line">[[-<span class="number">0.98579917</span> -<span class="number">1.04421422</span>]</span><br><span class="line"> [ <span class="number">1.4925044</span>   <span class="number">1.49887711</span>]</span><br><span class="line"> [-<span class="number">0.03211515</span> -<span class="number">0.01417351</span>]]</span><br><span class="line"><span class="number">415.81167375689665</span></span><br><span class="line"><span class="number">0.5758167373145309</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://github.com/446773160/Picbed/blob/main/blog_images20221207161835.png?raw=true" alt="blog_images20221207161835.png"></p>]]></content>
    
    
    <summary type="html">机器学习算法</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>QUIC协议</title>
    <link href="http://example.com/2022/10/19/QUIC%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2022/10/19/QUIC%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-10-19T14:00:00.000Z</published>
    <updated>2022-10-19T13:56:48.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QUIC-历史"><a href="#QUIC-历史" class="headerlink" title="QUIC 历史"></a>QUIC 历史</h1><p>QUIC（读作“quick”）是一个通用的传输层网络协议，最初由 Google 的 Jim Roskind 设计。该协议于 2012 年实现并部署，2013 年随着实验范围的扩大而公开发布，并向 IETF 描述。虽然长期处于互联网草案（英语：Internet Draft）阶段，但从 Chrome 浏览器至 Google 服务器的连接中超过一半的连接都使用了 QUIC。Microsoft Edge、Firefox 都已支持此协议；Safari 实现了 QUIC，但默认情况下没有启用。QUIC 于 RFC9000 中被正式标准化。</p><p>虽然 QUIC 的名称最初是“快速 UDP 互联网连接”（Quick UDP Internet Connection）的首字母缩写，但 IETF 指定的标准中 QUIC 并不是任何内容的缩写。QUIC 提高了目前使用 TCP 的面向连接的网络应用的性能。它通过使用用户数据报协议（UDP）在两个端点之间建立若干个多路连接来实现这一目标，其目的是为了在传输层淘汰 TCP，以满足许多应用的需求，因此该协议偶尔也会获得 “TCP/2”的昵称。</p><p>QUIC 与 HTTP/2 的多路复用连接协同工作，允许多个数据流独立到达所有端点，因此不受涉及其他数据流的丢包影响。相反，HTTP/2 建立在传输控制协议（TCP）上，如果任何一个 TCP 数据包延迟或丢失，所有多路数据流都会遭受队头阻塞延迟。</p><p>QUIC 的次要目标包括降低连接和传输时延，以及每个方向的带宽估计以避免拥塞。它还将拥塞控制算法移到了两个端点的使用者空间，而不是内核空间，据称这将使这些算法得到更快的改进。此外，该协议还可以扩展前向纠错（FEC），以进一步提高预期错误时的性能，这被视为协议演进的下一步。</p><p>2015 年 6 月，QUIC 规范的互联网草案（英语：Internet Draft）提交给 IETF 进行标准化[。2016 年，成立了 QUIC 工作组。2018 年 10 月，IETF 的 HTTP 工作组和 QUIC 工作组共同决定将 QUIC 上的 HTTP 映射称为 “HTTP/3”，以提前使其成为全球标准[18]。2021 年 5 月 IETF 公布 RFC9000，QUIC 规范推出了标准化版本。</p><p>总结：<strong>QUIC 通过 UDP 在两个端点之间快速建立多个连接来传输数据，且任何一个通路发送阻塞不会影响其他通路。所以 QUIC 在不影响可靠性的前提下，提高了数据的传输效率，降低了数据的传输时延。所以 QUIC 的出现是为了淘汰 TCP，偶尔也被称为”TCP/2”</strong></p><h1 id="传统-TCP-协议的缺点"><a href="#传统-TCP-协议的缺点" class="headerlink" title="传统 TCP 协议的缺点"></a>传统 TCP 协议的缺点</h1><p>传输控制协议 (TCP) 旨在为两个端点之间发送数据流提供一个接口。数据交给 TCP 系统，TCP 系统确保数据以完全相同的形式传到另一端，否则连接将提示存在错误。</p><p>为此，TCP 将数据分解成网路封包，并在每个数据包中添加少量数据。这些附加数据包括一个序列号，用于检测丢失或到达顺序不正确的数据包，以及一个校验和，可以检测数据包数据内的错误。当其中任何一个问题发生时，TCP 使用自动重传请求（ARQ）告诉发送方重新发送丢失或损坏的数据包。</p><p>在大多数实现中，TCP 会将连接上的任何错误视为阻塞，停止进一步传输，直到错误得到解决或连接被视为失败。如果使用单个连接来发送多个数据流，就像在 HTTP/2 协议中那样，所有这些数据流都会被阻止，尽管其中只有一个可能有问题。例如，如果在下载用于收藏夹图标的 GIF 图像时出现一个错误，页面的其余部分将等待问题得到解决。</p><p>由于 TCP 系统被设计成类似“数据管道”或流，TCP 刻意被设计成并不知晓其传输的数据之细节。如果对传输的数据存在额外需求，如需要使用 TLS 加密，那么此类协议必须建立在 TCP 的上层。每种协议都需要自己的握手过程，结果会导致在建立连接前需要大量交换数据，加之长距离通信的固有延迟，从而给整个传输过程增加大量开销[<a href="https://zh.m.wikipedia.org/zh-hans/QUIC#cite_note-ARSnext-19">19]</a>。</p><p>总结：<strong>TCP 协议被可以设计成数据管道，并不知道传输的细节，如果需要数据加密，会造成大量不必要的开销。</strong></p><p>​ <strong>TCP 协议会把数据封装成包，如果出现任何问题 TCP 都会使用自动重传请求（ARQ）造成线路阻塞。</strong></p><h1 id="QUIC-简介"><a href="#QUIC-简介" class="headerlink" title="QUIC 简介"></a>QUIC 简介</h1><p>​ QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvave0aU9VPsdSd9KFWjGQoIRKicElHTJYSuolgbicDoILkec4RJ6t1ZkGoWJbaJaCjl6lOc2tm5dphbA/640?wx_fmt=jpeg" alt="图片"></p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><p>QUIC 优点：</p><ul><li>大大减少开销，由于大多数 HTTP 都需要 TLS，因此 QUIC 使用协商秘钥和支持的协议成为初始握手一部分，消除了 TCP 上的先连接并通过附加数据包协商安全协议的需要。</li><li>每个 QUIC 流单独控制，如果一个流出现错误，协议栈仍然可以为其他流提供服务。</li><li>每个数据包单独加密这样就不需要等待部分数据包。</li><li>QUIC 包含一个连接标识符标识客户端和服务器端的连接，无论 ip 地址怎么变化只需要发送一个包含 id 的数据包就可以建立连接，提高了网路切换期间的性能（比如 WIFI 切换到移动热点）。</li><li>QUIC 在应用程序空间中实现而不是在操作系统内核，这样数据在程序之间移动的时候降低了进程上下文切换的额外开销。</li></ul><h1 id="QUIC-实现原理"><a href="#QUIC-实现原理" class="headerlink" title="QUIC 实现原理"></a>QUIC 实现原理</h1><p>一个 QUIC 数据包的格式如下：</p><p><img src="https://pic2.zhimg.com/v2-60231adb6c7014c7f043712839f77ab5_r.jpg" alt="img"></p><p>从图中可以看见由 header 和 data 构成</p><p>header 是明文的，包含 4 个字段：Flags（标记位）、Connection ID（连接 ID）、QUIC Version（QUIC 版本号）、Packet Number（包的数量）；</p><p>data 是加密的，可以包含 1 个或多个 frame，每个 frame 又分为 type 和 payload，其中 type 是数据帧类型， payload 就是应用数据；</p><p>数据帧有很多类型：Stream、ACK、Padding、Window_Update、Blocked 等，这里重点介绍下用于传输应用数据的 Stream 帧。</p><p><img src="https://pic2.zhimg.com/v2-f1cb88ac186e851a724a85dbd4f3de01_r.jpg" alt="img"></p><p><strong>Frame Type：</strong> 帧类型，占用 1 个字节</p><p><img src="https://pic3.zhimg.com/v2-eb52f6d7f4d12a2599085f62f9240162_r.jpg" alt="img"></p><ul><li>Bit7：必须设置为 1，表示 Stream 帧</li><li>Bit6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态</li><li>Bit5：如果设置为 1，表示 Stream 头中包含 Data length 字段</li><li>Bit4,3,2：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推</li><li>Bit1,0：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节</li></ul><p><strong>Stream ID：</strong> 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p><p><strong>Offset：</strong>偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p><p><strong>Data Length：</strong> 数据长度，占用 2 个字节，表示实际应用数据的长度</p><p><strong>Data：</strong> 实际的应用数据</p><h1 id="QUIC-建立连接"><a href="#QUIC-建立连接" class="headerlink" title="QUIC 建立连接"></a>QUIC 建立连接</h1><p>先分析下 HTTPS 的握手过程，包含 TCP 握手和 TLS 握手，TCP 握手：</p><p><img src="https://pic2.zhimg.com/v2-1fb94488942494ec9425ecf6682ed6e1_r.jpg" alt="img"></p><p>从图中可以看出，TCP 握手需要 1.5 个 RTT(其实就一个 RTT 因为第三次握手发出之后就可以发送数据了，但是服务器端必须接收到第三次握手才能接收数据)。</p><p>TLS 握手：密钥协商（1.3 版本）</p><p><img src="https://pic4.zhimg.com/80/v2-86cc5e2cf1b509083759b9c22800e2a7_720w.webp" alt="img"></p><p>从图中可以看出，TLS 握手需要 1 个 RTT，也就是 1 次 RTT 就把通信密钥协商好了，这是怎么做到的？</p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）服务器：生成随机数 b，计算 B=b*G%P，将 B 发送给客户端，也就是 Server Hello 消息</p><p>（3）客户端：使用 ECDH 算法生成通信密钥 KEY = a<em>B = a</em>b*G%P</p><p>（4）服务器：使用 ECDH 算法生成通信密钥 KEY = b<em>A = b</em>a*G%P</p><p>所以，这里的关键就是 ECDH 算法，a 和 b 是客户端和服务器的私钥，是不公开的，而其他参数是公开的。ECDH 算法有个非常重要的特征：即使知道 A、G、P，通过 A = a*G%P 公式也是无法推到出 a 的，保证了私钥的安全性。</p><p>综上所述，HTTPS 建立连接需要 3 个 RTT，由于 QUIC 的握手是基于 TLS1.3 实现的，所以首次建立连接时也是需要 1 次 RTT，那 QUIC 是如何做到 0-RTT 握手的呢？</p><p>0-RTT 握手</p><p>其实原理很简单：客户端缓存了 ServerConfig（B=b*G%P），下次建连直接使用缓存数据计算通信密钥：</p><p><img src="https://pic4.zhimg.com/80/v2-3862b1eeb75898f4f32de223b6123ddb_720w.webp" alt="img"></p><p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A=c*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY = c<em>B = c</em>b*G%P，加密发送应用数据</p><p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY = b<em>A = b</em>c*G%P</p><p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT 握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1=a<em>G%P，A2=c</em>G%P，……），一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p><p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p><p><strong>前向安全</strong></p><p>前向安全：是指用来产生会话密钥的长期密钥泄露出去，不会泄漏以前的通讯内容。</p><p><img src="https://pic2.zhimg.com/80/v2-d5e6bf3b74ae07927b0d62bccfa3c095_720w.webp" alt="img"></p><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算初始密钥 initKey = a<em>B = a</em>b*G%P，加密发送应用数据 1</p><p>（3）服务器：根据 Client Hello 消息计算初始密钥 initKey = b<em>A = b</em>a*G%P</p><p>（4）服务器：生成随机数 c，计算 C=c*G%P，使用 initKey 加密 C，发送给客户端，也就是 Server Hello 消息</p><p>（5）客户端：使用 initKey 解码获取 C，计算会话密钥 sessionKey = a<em>C = a</em>c*G%P，加密发送应用数据 2</p><p>（6）服务器：计算会话密钥 sessionKey = c<em>A = c</em>a*G%P，解密获取应用数据 2</p><p>客户端缓存的 ServerConfig 是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT 握手，使用会话密钥 sessionKey 保证通信数据的前向安全。</p><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="https://pic2.zhimg.com/80/v2-aace93419dd55c73ab4b5fd2976e1375_720w.webp" alt="img"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN = 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN=4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="https://pic1.zhimg.com/80/v2-e6abef5bc9316fd87905a5e97b547050_720w.webp" alt="img"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h1 id="QUIC-流量控制"><a href="#QUIC-流量控制" class="headerlink" title="QUIC 流量控制"></a>QUIC 流量控制</h1><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="https://pic4.zhimg.com/v2-2b659a36da1993c1a65bed4830606997_r.jpg" alt="img"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="https://pic4.zhimg.com/80/v2-62c627de56caf4617f97628215c4fa03_720w.webp" alt="img"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="https://pic3.zhimg.com/80/v2-a5f95afac0935ae11f4672d3fdf9bf3e_720w.webp" alt="img"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 = 60</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h2><p>初始拥塞窗口大小 cwnd=1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS = 1500（MTU）- 20（IP 首部）- 8（UDP 首部） = 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p><img src="https://pic1.zhimg.com/80/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_720w.webp" alt="img"></p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;</span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;= ssthresh</strong> 时，使用拥塞避免算法</li></ul><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h2><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1/cwnd</p><p><img src="https://pic3.zhimg.com/80/v2-1072c63fd6e97e671affe2d9346c3836_720w.webp" alt="img"></p><p>假设现在的 cwnd=8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h2 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h2><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1</li></ul><p><img src="https://pic1.zhimg.com/80/v2-dcefc32fcbaca9acf5a347580b56ff3c_720w.webp" alt="img"></p><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd = cwnd / 2</li><li>ssthresh = cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h2><p>快速恢复算法：cwnd = ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><p><img src="https://pic3.zhimg.com/80/v2-9158217fe2e02f6b17a29aadf649cdd2_720w.webp" alt="img"></p><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>多路复用是 HTTP/2 的主要特性之一。</p><p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1 中单个连接 1 次只能发送 1 个请求的性能瓶颈。HTTP/2 能实现多路复用的根本原因是采用了二进制帧格式的数据结构。</p><p><img src="https://pic2.zhimg.com/80/v2-9ec2f3b580d86711ce10bf983705e0a5_720w.webp" alt="img"></p><p>一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><p><img src="https://pic3.zhimg.com/80/v2-33cc6b4531a4de38b94da1b2a7b6ee8a_720w.webp" alt="img"></p><p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p><p><img src="https://pic3.zhimg.com/80/v2-0454bee543863c36908765244b989a56_720w.webp" alt="img"></p><p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据，这就是 TCP 层的队头阻塞问题。</p><p>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口，那如果给每个请求流都分配一个独立的滑动窗口，是不是就可以解决这个问题了？</p><p>QUIC 就是这么做的：</p><p><img src="https://pic2.zhimg.com/80/v2-b5a52474167933083a90ff8baa040005_720w.webp" alt="img"></p><p>A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。</p><h1 id="QUIC-连接迁移"><a href="#QUIC-连接迁移" class="headerlink" title="QUIC 连接迁移"></a>QUIC 连接迁移</h1><p>连接迁移：当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 64 位的 Connection ID，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。</p><p><img src="https://pic4.zhimg.com/80/v2-f82f920a417188160d2354757db44567_720w.webp" alt="img"></p><p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p>]]></content>
    
    
    <summary type="html">Quick UDP Internet Connections</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot事件</title>
    <link href="http://example.com/2022/10/18/SpringBoot%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2022/10/18/SpringBoot%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-10-18T13:00:00.000Z</published>
    <updated>2022-10-19T04:21:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-事件成员："><a href="#SpringBoot-事件成员：" class="headerlink" title="SpringBoot 事件成员："></a>SpringBoot 事件成员：</h1><p>Spring 事件机制是 <code>观察者模式</code> 的一种实现，但是除了 <code>发布者</code> 和 <code>监听者</code> 两个角色之外，还有一个 <code>广播者</code></p><ol><li><code>ApplicationEvent</code>：应用事件</li><li><code>ApplicationEventPublisher</code>：应用事件发布者</li><li><code>ApplicationEventMulticaster</code>：应用事件广播者</li><li><code>ApplicationListener</code> 继承 <code>EventListener</code>：应用事件监听者</li></ol><p>ApplicationContext 通过 ApplicationEvent 类和 ApplicationListener 接口进行事件处理。 如果将实现 ApplicationListener 接口的 bean 注入到上下文中，则每次使用 ApplicationContext 发布 ApplicationEvent 时，都会通知该 bean。 本质上，这是标准的观察者设计模式。</p><p><img src="https://img-blog.csdnimg.cn/20200601154141140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtU3RhcjI1NjA=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>ApplicationEventPublisher：发布 ApplicationEvent 到 ApplicationEventMulticaster<br>ApplicationEventMulticaster：广播将 ApplicationEvent 发送到对应的 ApplicationListener</p><p>Springboot 启动事件机制（SpringApplicationEvent 实现类）</p><table><thead><tr><th align="center">事件类型</th><th>说明</th></tr></thead><tbody><tr><td align="center">ApplicationStartedEvent <code>/</code> ApplicationStartingEvent</td><td>获取 SpringApplicationRunListener 实例之后调用（ApplicationListener 注册之后）</td></tr><tr><td align="center">ApplicationEnvironmentPreparedEvent</td><td><code>Enviroment</code> 准备完毕之后，<code>ApplicationContext</code> 创建之前调用</td></tr><tr><td align="center">ApplicationPreparedEvent</td><td>ApplicationContext 已准备齐全，但未刷新时发布的事件调用</td></tr><tr><td align="center">ApplicationReadyEvent</td><td>所有都准备完成</td></tr><tr><td align="center">ApplicationFailedEvent</td><td>启动异常时执行事件</td></tr></tbody></table><p>核心类：<code>EventPublishingRunListener</code>、<code>SimpleApplicationEventMulticaster</code><br>核心方法：<code>multicastEvent</code></p><p>Spring 事件只需要几步：</p><ul><li>自定义事件，继承 ApplicationEvent</li><li>定义监听器，实现 ApplicationListener 或者通过 @EventListener 注解到方法上</li><li>定义发布者，通过 ApplicationEventPublisher</li></ul><h1 id="SpringBoot-事件示例："><a href="#SpringBoot-事件示例：" class="headerlink" title="SpringBoot 事件示例："></a>SpringBoot 事件示例：</h1><p>情景：用户注册，注册成功会发送邮件、短信</p><ul><li><code>注册事件</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegistryEvent</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>发布注册事件</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistryService</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">registry</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryEvent</span>(user);</span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>注册事件监听</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;RegistryEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(RegistryEvent event)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) event.getSource();</span><br><span class="line">        <span class="comment">//发送邮件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送短信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>业务代码</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRegistryService userRegistryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        userRegistryService.registry(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;北京&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="监听事件的注解驱动："><a href="#监听事件的注解驱动：" class="headerlink" title="监听事件的注解驱动："></a>监听事件的注解驱动：</h1><p>从 Spring 4.1 开始，现在可以简单地注释托管 bean 的方法<code>@EventListener</code>以自动注册<code>ApplicationListener</code>匹配的方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRemovedListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  ReturnedEvent <span class="title function_">handleUserRemovedEvent</span><span class="params">(UserRemovedEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// handle UserRemovedEvent ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnedEvent</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleReturnedEvent</span><span class="params">(ReturnedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// handle ReturnedEvent ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用注释驱动配置后，无需额外配置。我们的方法可以监听多个事件，或者如果我们想在没有参数的情况下定义它，也可以在注解本身上指定事件类型。示例：<code>@EventListener(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</code>。对于带有注释<code>@EventListener</code>并定义为非 void 返回类型的方法，Spring 会将结果作为新事件发布给我们。在上面的例子中，<code>ReturnedEvent</code>第一种方法的返回值会被发布，然后由第二种方法处理。</p><p>如果我们指定 SpEL ，Spring 只允许在某些情况下触发我们的侦听器<code>condition</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRemovedListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener(condition = &quot;#event.name eq &#x27;reflectoring&#x27;&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleConditionalListener</span><span class="params">(UserRemovedEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// handle UserRemovedEvent</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当表达式计算结果为以下字符串之一或以下字符串之一时才会处理该事件<code>true</code>：“true”、“on”、“yes”或“1”。方法参数通过它们的名称公开。条件表达式还公开了一个引用原始<code>ApplicationEvent</code>( <code>#root.event</code>) 和实际方法参数的“根”变量<code>(#root.args)</code></p><p>在上面的例子中，<code>UserRemovedEvent</code>只有当<code>#event.name</code>的值为时才会触发监听器<code>&#39;reflectoring&#39;</code>，</p><h1 id="异步事件监听："><a href="#异步事件监听：" class="headerlink" title="异步事件监听："></a>异步事件监听：</h1><p><strong>默认情况下，spring 事件是同步的，这意味着发布者线程会阻塞，直到所有侦听器都处理完事件。</strong></p><p>要使事件侦听器以异步模式运行，我们所要做的就是<code>@Async</code>在该侦听器上使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Async</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleAsyncEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">    <span class="comment">// handle event</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使<code>@Async</code>注释起作用，我们还必须注释我们的一个<code>@Configuration</code>类或<code>@SpringBootApplication</code>使用<code>@EnableAsync</code>.上面的代码示例还表明我们可以将<code>String</code>s 用作事件。使用风险自负。<strong>最好使用特定于我们用例的数据类型，以免与其他事件发生冲突</strong>。</p><h1 id="事务绑定事件"><a href="#事务绑定事件" class="headerlink" title="事务绑定事件"></a>事务绑定事件</h1><p>Spring 允许我们将事件监听器绑定到当前事务的某个阶段。当当前事务的结果对侦听器很重要时，这允许更灵活地使用事件。当我们用 注释我们的方法时<code>@TransactionalEventListener</code>，我们会得到一个知道事务的扩展事件侦听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRemovedListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener(phase=TransactionPhase.AFTER_COMPLETION)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleAfterUserRemoved</span><span class="params">(UserRemovedEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// handle UserRemovedEvent</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserRemovedListener</code>只会在当前事务完成时调用。</p><p>我们可以将监听器绑定到事务的以下阶段：</p><ul><li><code>AFTER_COMMIT</code>: 事务提交成功时处理该事件。如果我们的事件监听器应该只在当前事务成功的情况下运行，我们就可以使用它。</li><li><code>AFTER_COMPLETION</code>: 事务提交或回滚时处理该事件。例如，我们可以使用它在事务完成后执行清理。</li><li><code>AFTER_ROLLBACK</code>: 该事件将在事务回滚后处理。</li><li><code>BEFORE_COMMIT</code>：事件将在事务提交之前处理。例如，我们可以使用它来将事务性 O/R 映射会话刷新到数据库。</li></ul><h1 id="Spring-Boot-的应用程序事件"><a href="#Spring-Boot-的应用程序事件" class="headerlink" title="Spring Boot 的应用程序事件"></a>Spring Boot 的应用程序事件</h1><p>Spring Boot 提供了几个<code>ApplicationEvent</code>与<code>SpringApplication</code>.</p><p><strong>有些事件是在<code>ApplicationContext</code>创建</strong>之前触发的，所以我们不能在这些事件上注册一个监听器<code>@Bean</code>。我们可以通过手动添加监听器来为这些事件注册监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventsDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">springApplication</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(EventsDemoApplication.class);</span><br><span class="line">    springApplication.addListeners(<span class="keyword">new</span> <span class="title class_">SpringBuiltInEventsListener</span>());</span><br><span class="line">    springApplication.run(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论应用程序是如何创建的，我们也可以注册我们的侦听器，方法是<code>META-INF/spring.factories</code>向我们的项目添加文件并使用键引用我们的侦听器<code>org.springframework.context.ApplicationListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener= com.reflectoring.eventdemo.SpringBuiltInEventsListener</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBuiltInEventsListener</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SpringApplicationEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SpringApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// handle event</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot-支持通用事件"><a href="#SpringBoot-支持通用事件" class="headerlink" title="SpringBoot 支持通用事件"></a>SpringBoot 支持通用事件</h1><p>创建通用事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericSpringEvent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T what;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericSpringEvent</span><span class="params">(T what, <span class="type">boolean</span> success)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.what = what;</span><br><span class="line">        <span class="built_in">this</span>.success = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... standard getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<em>GenericSpringEvent</em>和<em>CustomSpringEvent</em>之间的区别。我们现在可以灵活地发布任意事件，并且不再需要从<em>ApplicationEvent</em>继承。</p><p>创建监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericSpringEventListener</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;GenericSpringEvent&lt;String&gt;&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(<span class="meta">@NonNull</span> GenericSpringEvent&lt;String&gt; event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received spring generic event - &quot;</span> + event.getWhat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但不幸的是，这个定义要求我们从<em>ApplicationEvent</em>类继承<em>GenericSpringEvent 。</em>因此让我们使用前面讨论的注释驱动的事件监听器。也可以通过在*@EventListener<em>注释上定义布尔 SpEL 表达式来*<em>使事件监听器有条件。</em></em></p><p>在这种情况下，事件处理程序只会被<em>String</em>的<em>GenericSpringEvent</em>成功调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDrivenEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener(condition = &quot;#event.success&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSuccessful</span><span class="params">(GenericSpringEvent&lt;String&gt; event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Handling generic event (conditional).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot Event</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://example.com/2022/10/18/SpringMVC/"/>
    <id>http://example.com/2022/10/18/SpringMVC/</id>
    <published>2022-10-18T10:00:00.000Z</published>
    <updated>2022-10-21T06:57:24.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-SpringMVC？"><a href="#什么是-SpringMVC？" class="headerlink" title="什么是 SpringMVC？"></a>什么是 SpringMVC？</h1><p>Spring Web MVC 是一种基于 Java 的实现了 MVC 设计模式的、请求驱动类型的、轻量级 Web 框架。</p><p>ssm：即 springmvc， spring， mybatis</p><p>SpringMVC 的特点</p><ol><li>Spring 家族原生产品，与 IOC 容器无缝对接。</li><li>基于原生 Servlet，通过了功能强大的前端控制器 DispatcherServlet 来进行请求的统一管理。</li><li>内部组件化程度高、可插拔式组件即插即用，想要什么功能配置相应组件即可。</li></ol><h1 id="快速创建-SpringMVC-项目"><a href="#快速创建-SpringMVC-项目" class="headerlink" title="快速创建 SpringMVC 项目:"></a>快速创建 SpringMVC 项目:</h1><h2 id="配置-maven-工程"><a href="#配置-maven-工程" class="headerlink" title="配置 maven 工程"></a>配置 maven 工程</h2><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesimage-20221016162204303.png?raw=true" alt="blog_imagesimage-20221016162204303.png"></p><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesimage-20221016162007864.png?raw=true" alt="blog_imagesimage-20221016162007864.png"></p><h2 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h2><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesimage-20221016162404945.png?raw=true" alt="blog_imagesimage-20221016162404945.png"></p><h2 id="搭建-SpringMVC-项目"><a href="#搭建-SpringMVC-项目" class="headerlink" title="搭建 SpringMVC 项目"></a>搭建 SpringMVC 项目</h2><h3 id="导入-jar-包"><a href="#导入-jar-包" class="headerlink" title="导入 jar 包"></a>导入 jar 包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--        json依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-web-xml"><a href="#配置-web-xml" class="headerlink" title="配置 web.xml"></a>配置 web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在-resources-下创建-SpringMVC-xml"><a href="#在-resources-下创建-SpringMVC-xml" class="headerlink" title="在 resources 下创建 SpringMVC.xml"></a>在 resources 下创建 SpringMVC.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.shnu&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">      若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">      此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="快速启动-SpringMVC"><a href="#快速启动-SpringMVC" class="headerlink" title="快速启动 SpringMVC"></a>快速启动 SpringMVC</h3><p><strong>User 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shnu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17 14:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Bean 对象</strong>：受 Spring 容器管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.shnu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;山川&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springMVC.xml&quot;</span>);<span class="comment">//获取Spring容器</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)app.getBean(<span class="string">&quot;user&quot;</span>);<span class="comment">//获取Bean对象</span></span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h1 id="SpringMVC-项目配置文件"><a href="#SpringMVC-项目配置文件" class="headerlink" title="SpringMVC 项目配置文件"></a>SpringMVC 项目配置文件</h1><h2 id="Bean-标签"><a href="#Bean-标签" class="headerlink" title="Bean 标签"></a>Bean 标签</h2><h3 id="Bean-标签基本配置"><a href="#Bean-标签基本配置" class="headerlink" title="Bean 标签基本配置"></a>Bean 标签基本配置</h3><p>用于配置对象交由 Spring 来创建。<br>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p><p>基本属性：<br>id：Bean 实例在 Spring 容器中的唯一标识<br>class：Bean 的全限定名称</p><h3 id="Bean-标签范围配置"><a href="#Bean-标签范围配置" class="headerlink" title="Bean 标签范围配置"></a>Bean 标签范围配置</h3><p>scope:指对象的作用范围，取值如下：</p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中</td></tr><tr><td>session</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</td></tr><tr><td>global session</td><td>WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么 globalSession 相当于 session</td></tr></tbody></table><p><strong>当 scope 的取值为 singleton 时</strong></p><p>Bean 的实例化个数：1 个<br>Bean 的实例化时机：当 Spring 核心文件被加载时，实例化配置的 Bean 实例</p><p><strong>Bean 的生命周期</strong></p><ul><li><p>对象创建：当应用加载，创建容器时，对象就被创建了</p></li><li><p>对象运行：只要容器在，对象一直活着</p></li><li><p>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p><p><img src="https://secure2.wostatic.cn/static/4Q8tkkby84Tv4YhLqvVLnN/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?auth_key=1665992559-77Zc3iwQULWd3dUX6mQXTY-0-1753d8f023f0088e965b78dd05181ee4" alt="img"></p></li></ul><p>作用域对生命周期的影响</p><blockquote><p>Singleton : 容器创建后立马的执行 123， 后续获取直接从 4 开始，容器关闭调用 5 prototype：从容器中获取 bean 则 1, 2, 3, 4 执行，容器关闭不会执行 5 , 此作用域对象销毁方法需要用户自己处理。</p></blockquote><p><strong>当 scope 的取值为 prototype 时</strong></p><p>Bean 的实例化个数：多个<br>Bean 的实例化时机：当调用 getBean()方法时实例化 Bean</p><ul><li>对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li><li>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</li></ul><p><strong>Bean 生命周期配置</strong></p><p>init-method：指定类中的初始化方法名称</p><p>destroy-method：指定类中销毁方法名称</p><h3 id="Bean-通过-xml-方式注入"><a href="#Bean-通过-xml-方式注入" class="headerlink" title="Bean 通过 xml 方式注入"></a>Bean 通过 xml 方式注入</h3><h4 id="使用无参构造方法实例化"><a href="#使用无参构造方法实例化" class="headerlink" title="使用无参构造方法实例化"></a><strong>使用无参构造方法实例化</strong></h4><p>它会根据默认无参构造方法来创建类对象，如果 bean 中没有默认无参构造函数，将会创建失败</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="有参构造方法注入"><a href="#有参构造方法注入" class="headerlink" title="有参构造方法注入"></a>有参构造方法注入</h4><p>在<code>bean</code>标签中使用<code>constructor-arg</code>标签来实现有参构造方法来注入 Bean。</p><h5 id="index-方式"><a href="#index-方式" class="headerlink" title="index 方式"></a>index 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--有参构造方法注入：index表示属性定义的顺序--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.spring.ioc.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;三国演义&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="name-方式"><a href="#name-方式" class="headerlink" title="name 方式"></a>name 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--有参构造方法注入：name表示属性定义名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.spring.ioc.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;红楼梦&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Setter-注入"><a href="#Setter-注入" class="headerlink" title="Setter 注入"></a>Setter 注入</h4><p>我们也可以通过 Bean 属性的 set 方法注入值。此时，在<code>bean</code>标签中我们使用<code>property</code> 标签来完成属性的注入。这里的<code>name</code>的值是根据 setter 方法名推断出来的值，而非属性名称。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.spring.ioc.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;水浒传&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="P-名称空间注入"><a href="#P-名称空间注入" class="headerlink" title="P 名称空间注入"></a>P 名称空间注入</h4><p>在名称空间中加入 p 名称空间，直接在<code>bean</code>标签的属性中使用<code>p</code>来设置属性值。注意，这里不是属性名称，而是和属性对应的 setter 方法一一对应。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在p名称空间的加持下直接给属性赋值，这里要和Setter方法名称保持一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.spring.ioc.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book4&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;4&quot;</span> <span class="attr">p:bookName</span>=<span class="string">&quot;西游记&quot;</span> <span class="attr">p:price</span>=<span class="string">&quot;33&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a>静态工厂注入</h4><p>静态工厂方法提供了单实例的创建及获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient OkHttpClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (OkHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            OkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注入静态工厂方法提供的 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.OkHttpUtils&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpClient&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="实例工厂注入"><a href="#实例工厂注入" class="headerlink" title="实例工厂注入"></a>实例工厂注入</h4><p>实例工厂就是工厂方法是一个实例方法，这样，工厂类必须实例化之后才可以调用工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里是实例属性</span></span><br><span class="line">    <span class="keyword">private</span> okhttp3.OkHttpClient OkHttpClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (OkHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            OkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注入实例工厂方法提供的 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--先注册实例工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.spring.ioc.OkHttpUtils&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpUtils&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调用示例工厂的方法来注册实例okHttpClient--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;okhttp3.OkHttpClient&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;okHttpUtils&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpClient&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Bean-的依赖注入的数据类型"><a href="#Bean-的依赖注入的数据类型" class="headerlink" title="Bean 的依赖注入的数据类型"></a>Bean 的依赖注入的数据类型</h4><p>上面的操作，都是注入的引用 Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p><p>注入数据的三种数据类型</p><ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ul><p>其中引用数据类型，此处就不再赘述了，之前的操作都是对 UserDao 对象的引用进行注入的，下面将以 set 方法注入为例，演示普通数据类型和集合数据类型的注入。</p><h5 id="普通数据类型的注入"><a href="#普通数据类型的注入" class="headerlink" title="普通数据类型的注入"></a>普通数据类型的注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserDaoImpl&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&#x27;&quot;</span> + age + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;山川&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="集合数据类型（List）的注入"><a href="#集合数据类型（List）的注入" class="headerlink" title="集合数据类型（List）的注入"></a>集合数据类型（List<String>）的注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getStrList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrList</span><span class="params">(List&lt;String&gt; strList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strList = strList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="集合数据类型（List）的注入-1"><a href="#集合数据类型（List）的注入-1" class="headerlink" title="集合数据类型（List）的注入"></a>集合数据类型（List<User>）的注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userList = userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="集合数据类型（-Map-lt-String-User-gt-）的注入"><a href="#集合数据类型（-Map-lt-String-User-gt-）的注入" class="headerlink" title="集合数据类型（ Map&lt;String,User&gt; ）的注入"></a>集合数据类型（ Map&lt;String,User&gt; ）的注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    Map&lt;String, User&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, User&gt; <span class="title function_">getUserMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMap</span><span class="params">(Map&lt;String, User&gt; userMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMap = userMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tianjin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="集合数据类型（Properties）的注入"><a href="#集合数据类型（Properties）的注入" class="headerlink" title="集合数据类型（Properties）的注入"></a>集合数据类型（Properties）的注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Properties <span class="title function_">getProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h2><p>实际开发中，Spring 的配置内容非常多，这就导致 Spring 配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在 Spring 主配置文件通过 import 标签进行加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="spring-相关-API"><a href="#spring-相关-API" class="headerlink" title="spring 相关 API"></a>spring 相关 API</h1><h2 id="ApplicationContext-的继承体系"><a href="#ApplicationContext-的继承体系" class="headerlink" title="ApplicationContext 的继承体系"></a>ApplicationContext 的继承体系</h2><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68c28ecf080ffa12d21ddf63016822a5.png" alt="img"></p><h2 id="ApplicationContext-的实现类（获取-Spring-容器）"><a href="#ApplicationContext-的实现类（获取-Spring-容器）" class="headerlink" title="ApplicationContext 的实现类（获取 Spring 容器）"></a>ApplicationContext 的实现类（获取 Spring 容器）</h2><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>它是从类的根路径下加载配置文件 推荐使用这种</p><h3 id="FileSystemXmlApplicationContext"><a href="#FileSystemXmlApplicationContext" class="headerlink" title="FileSystemXmlApplicationContext"></a>FileSystemXmlApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\projects\\spring\\spring_ioc\\src\\main\\resources\\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解</p><h2 id="getBean-方法使用"><a href="#getBean-方法使用" class="headerlink" title="getBean()方法使用"></a>getBean()方法使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;       assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，当参数的数据类型是字符串时，表示根据 Bean 的 id 从容器中获得 Bean 实例，返回是 Object，需要强转。</p><p>当参数的数据类型是 Class 类型时，表示根据类型从容器中匹配 Bean 实例，当容器中相同类型的 Bean 有多个时，则此方法会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService2</span> <span class="operator">=</span> applicationContext.getBean(UserService.class);</span><br></pre></td></tr></table></figure><h1 id="Spring-配置数据源"><a href="#Spring-配置数据源" class="headerlink" title="Spring 配置数据源"></a>Spring 配置数据源</h1><h2 id="数据源（连接池）的作用"><a href="#数据源（连接池）的作用" class="headerlink" title="数据源（连接池）的作用"></a>数据源（连接池）的作用</h2><p>数据源(连接池)是提高程序性能如出现的</p><p>事先实例化数据源，初始化部分连接资源</p><p>使用连接资源时从数据源中获取</p><p>使用完毕后将连接资源归还给数据源</p><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid 等</p><p><strong>开发步骤</strong></p><p>① 导入数据源的坐标和数据库驱动坐标</p><p>② 创建数据源对象</p><p>③ 设置数据源的基本连接数据</p><p>④ 使用数据源获取连接资源和归还连接资源</p><h2 id="数据源的手动创建"><a href="#数据源的手动创建" class="headerlink" title="数据源的手动创建"></a>数据源的手动创建</h2><p>① 导入 mysql 数据库驱动坐标、导入 c3p0 和 druid 的坐标：随便选一个建议选择 Druid 连接池</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- C3P0连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit单元测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 创建 C3P0 连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建数据源</span></span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    <span class="comment">//设置数据库连接参数</span></span><br><span class="line">    dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://192.168.1.55:3306/mysql&quot;</span>);</span><br><span class="line">    dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;646453&quot;</span>);</span><br><span class="line">    <span class="comment">//获得连接对象</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">      <span class="keyword">if</span> (connection!=<span class="literal">null</span>)</span><br><span class="line">            connection.close();<span class="comment">//关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 创建 Druid 连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建数据源</span></span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    <span class="comment">//设置数据库连接参数</span></span><br><span class="line">    dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://192.168.1.55:3306/mysql&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;646453&quot;</span>);</span><br><span class="line">    <span class="comment">//获得连接对象</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    <span class="keyword">if</span> (connection!=<span class="literal">null</span>)</span><br><span class="line">            connection.close();<span class="comment">//关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 提取 jdbc.properties 配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.1.55:3306/mysql</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">646453</span></span><br></pre></td></tr></table></figure><p>④ 读取 jdbc.properties 配置文件创建连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0ByProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//加载类路径下的jdbc.properties</span></span><br><span class="line">    <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    dataSource.setDriverClass(rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>));</span><br><span class="line">    dataSource.setJdbcUrl(rb.getString(<span class="string">&quot;jdbc.url&quot;</span>));</span><br><span class="line">    dataSource.setUser(rb.getString(<span class="string">&quot;jdbc.username&quot;</span>));</span><br><span class="line">    dataSource.setPassword(rb.getString(<span class="string">&quot;jdbc.password&quot;</span>));</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-配置数据源-1"><a href="#Spring-配置数据源-1" class="headerlink" title="Spring 配置数据源"></a>Spring 配置数据源</h2><p>可以将 DataSource 的创建权交由 Spring 容器去完成</p><p>DataSource 有无参构造方法，而 Spring 默认就是通过无参构造方法实例化对象的</p><p>DataSource 要想使用需要通过 set 方法设置数据库连接信息，而 Spring 可以通过 set 方法进行字符串注入</p><p><strong>c3p0</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.1.55:3306/mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;646453&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Druid</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接池设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;16&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- 连接池最大活跃连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-注解开发"><a href="#Spring-注解开发" class="headerlink" title="Spring 注解开发"></a>Spring 注解开发</h1><h2 id="Spring-原始注解"><a href="#Spring-原始注解" class="headerlink" title="Spring 原始注解"></a>Spring 原始注解</h2><p>Spring 是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替 xml 配置文件可以简化配置，提高开发效率。</p><p>Spring 原始注解主要是替代<Bean>的配置</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化 Bean</td></tr><tr><td>@Controller</td><td>使用在 web 层类上用于实例化 Bean</td></tr><tr><td>@Service</td><td>使用在 service 层类上用于实例化 Bean</td></tr><tr><td>@Repository</td><td>使用在 dao 层类上用于实例化 Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired 一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注 Bean 的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是 Bean 的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注该方法是 Bean 的销毁方法</td></tr></tbody></table><p>注意：</p><p>使用注解进行开发时，需要在 applicationContext.xml 中配置组件扫描，作用是指定哪个包及其子包下的 Bean 需要进行扫描以便识别使用注解配置的类、字段和方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.shnu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用@Compont 或@Repository 标识 UserDaoImpl 需要 Spring 进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Compont 或@Service 标识 UserServiceImpl 需要 Spring 进行实例化</p><p>使用@Autowired 或者@Autowired+@Qulifier 或者@Resource 进行 userDao 的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">/*@Autowired</span></span><br><span class="line"><span class="comment">    @Qualifier(&quot;userDao&quot;)*/</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Value 进行字符串的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;注入普通数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(driver);</span><br><span class="line">        System.out.println(<span class="string">&quot;save running... ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Scope 标注 Bean 的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">   <span class="comment">//此处省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@PostConstruct 标注初始化方法，使用@PreDestroy 标注销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化方法....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;销毁方法.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-新注解"><a href="#Spring-新注解" class="headerlink" title="Spring 新注解"></a>Spring 新注解</h2><p>使用上面的注解还不能全部替代 xml 配置文件，还需要使用注解替代的配置如下：</p><p>非自定义的 Bean 的配置：<bean></p><p>加载 properties 文件的配置：context:property-placeholder</p><p>组件扫描的配置：context:component-scan</p><p>引入其他文件：<import></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties 文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table><p><strong>配置数据源</strong></p><p>c3p0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span>  <span class="comment">//Spring会将当前方法的返回值以指定名称存储到Spring容器中</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>druid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shnu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.chart.PieChart;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Spring启动的时候会从配置类先进行加载</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setDriverClassName(driver);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setInitialSize(<span class="number">10</span>);</span><br><span class="line">        druidDataSource.setMaxActive(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springMVC.xml&quot;</span>);<span class="comment">//获取Spring容器</span></span><br><span class="line">    <span class="type">DruidDataSource</span>  <span class="variable">dataSource</span> <span class="operator">=</span> (DruidDataSource)app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    <span class="keyword">if</span> (connection!=<span class="literal">null</span>)</span><br><span class="line">        connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-整合-Junit"><a href="#Spring-整合-Junit" class="headerlink" title="Spring 整合 Junit"></a>Spring 整合 Junit</h1><h2 id="原始-Junit-测试-Spring-的问题"><a href="#原始-Junit-测试-Spring-的问题" class="headerlink" title="原始 Junit 测试 Spring 的问题"></a>原始 Junit 测试 Spring 的问题</h2><p>在测试类中，每个测试方法都有以下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> applicationContext.getBean(DataSource.class);</span><br></pre></td></tr></table></figure><h2 id="上述问题解决思路"><a href="#上述问题解决思路" class="headerlink" title="上述问题解决思路"></a>上述问题解决思路</h2><p>让 SpringJunit 负责创建 Spring 容器，但是需要将配置文件的名称告诉它</p><p>将需要进行测试 Bean 直接在测试类中进行注入</p><h2 id="Spring-集成-Junit-步骤"><a href="#Spring-集成-Junit-步骤" class="headerlink" title="Spring 集成 Junit 步骤"></a>Spring 集成 Junit 步骤</h2><p>① 导入 spring 集成 Junit 的坐标</p><p>② 使用@Runwith 注解替换原来的运行期</p><p>③ 使用@ContextConfiguration 指定配置文件或配置类</p><p>④ 使用@Autowired 注入需要测试的对象</p><p>⑤ 创建测试方法进行测试</p><h2 id="Spring-集成-Junit-代码实现"><a href="#Spring-集成-Junit-代码实现" class="headerlink" title="Spring 集成 Junit 代码实现"></a>Spring 集成 Junit 代码实现</h2><p>1.导入 spring 集成 Junit 的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建核心配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.shnu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17 16:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//核心配置类</span></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">//标注是配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.shnu&quot;)</span><span class="comment">//扫描com.shnu下面的所有Bean对象</span></span><br><span class="line"><span class="meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span><span class="comment">//导入数据库源的配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(value = &quot;classpath:springMVC.xml&quot;)</span><span class="comment">//加载SpringMVC的配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用@Runwith 注解替换原来的运行期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用SpringJUnit4ClassRunner来运行</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载Spring核心配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用@Autowired 注入需要测试的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用SpringJUnit4ClassRunner来运行</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载Spring核心配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DruidDataSource dataSource;</span><br></pre></td></tr></table></figure><p>5.创建测试方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载Spring核心配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DruidDataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="keyword">if</span> (connection!=<span class="literal">null</span>)</span><br><span class="line">            connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spring-的-AOP-简介"><a href="#Spring-的-AOP-简介" class="headerlink" title="Spring 的 AOP 简介"></a>Spring 的 AOP 简介</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h2 id="AOP-的作用及其优势"><a href="#AOP-的作用及其优势" class="headerlink" title="AOP 的作用及其优势"></a>AOP 的作用及其优势</h2><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>优势：减少重复代码，提高开发效率，并且便于维护</p><h2 id="AOP-的底层实现"><a href="#AOP-的底层实现" class="headerlink" title="AOP 的底层实现"></a>AOP 的底层实现</h2><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h2 id="AOP-的动态代理技术"><a href="#AOP-的动态代理技术" class="headerlink" title="AOP 的动态代理技术"></a>AOP 的动态代理技术</h2><p>常用的动态代理技术</p><p>JDK 代理 : 基于接口的动态代理技术</p><p>cglib 代理：基于父类的动态代理技术</p><p><img src="https://img-blog.csdnimg.cn/3d4361f1e7f7461e8eea5d25f15f60a3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="JDK-的动态代理"><a href="#JDK-的动态代理" class="headerlink" title="JDK 的动态代理"></a>JDK 的动态代理</h2><p>目标类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强对象代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advice</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> loader 被代理类的类加载器   target.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> interfaces 被代理类实现的接口  arget.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> loader 代理类的类加载器     new  InvocationHandler()</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> proxy 代理的对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * new InvocationHandler()  提供了动态执行增强逻辑的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> proxy 代理对象  不能动</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 目标对象方法  重写invoke方法的返回值必须是method.invoke()的返回值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args 目标对象参数  方法参数直接传入method.invoke(target, args)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="type">TargetInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line"> target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                advice.before();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                advice.afterReturning();</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="cglib-的动态代理"><a href="#cglib-的动态代理" class="headerlink" title="cglib 的动态代理"></a>cglib 的动态代理</h2><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强对象代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advice</span>(); <span class="comment">//创建增强对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();  <span class="comment">//创建增强器</span></span><br><span class="line">        enhancer.setSuperclass(Target.class); <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123; <span class="comment">//设置回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects,MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                advice.before();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">                advice.afterReturning();</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) enhancer.create(); <span class="comment">//创建代理对象</span></span><br><span class="line">        proxy.save();<span class="comment">//执行测试方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a><strong>AOP 相关概念</strong></h2><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p><table><thead><tr><th>Target（目标对象）</th><th>代理的目标对象</th></tr></thead><tbody><tr><td>Proxy （代理）</td><td>一个类被 AOP 织入增强后，就产生一个结果代理类</td></tr><tr><td>Joinpoint（连接点）</td><td>所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法，因为 spring 只支持方法类型的连接点</td></tr><tr><td>Pointcut（切入点）</td><td>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</td></tr><tr><td>Advice（通知/ 增强）</td><td>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</td></tr><tr><td>Aspect（切面）</td><td>是切入点和通知（引介）的结合</td></tr><tr><td>Weaving（织入）</td><td>是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 Aspect 采用编译期织入和类装载期织入</td></tr></tbody></table><p><img src="https://github.com/446773160/Picbed/blob/main/blog_imagesAop.png?raw=true" alt="blog_imagesAop.png"></p><p>AOP 开发明确的事项<br>① 需要编写的内容</p><ul><li><p>编写核心业务代码（目标类的目标方法）</p></li><li><p>编写切面类，切面类中有通知(增强功能方法)</p></li><li><p>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p></li></ul><p>②AOP 技术实现的内容</p><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><p>③AOP 底层使用哪种代理方式</p><p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。<br>知识要点<br>aop：面向切面编程</p><p>aop 底层实现：基于 JDK 的动态代理 和 基于 Cglib 的动态代理</p><p>aop 的重点概念：</p><ul><li><p>Pointcut（切入点）：被增强的方法</p></li><li><p>Advice（通知/ 增强）：封装增强业务逻辑的方法</p></li><li><p>Aspect（切面）：切点+通知</p></li></ul><p>Weaving（织入）：将切点与通知结合的过程<br>开发明确事项：</p><ul><li><p>谁是切点（切点表达式配置）</p></li><li><p>谁是通知（切面类中的增强方法）</p></li><li><p>将切点和通知进行织入配置</p></li></ul><h2 id="基于-XML-的-AOP-开发"><a href="#基于-XML-的-AOP-开发" class="headerlink" title="基于 XML 的 AOP 开发"></a>基于 XML 的 AOP 开发</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a><strong>快速入门</strong></h3><p>导入 AOP 相关坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面类（内部有增强方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span>&#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/18 11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将目标类和切面类的对象创建权交给 spring</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.terence.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入 aop 命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br></pre></td></tr></table></figure><p>在 applicationContext.xml 中配置织入关系</p><p>配置切点表达式和前置增强的织入关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.terence.aop.Target.save())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XML-配置-AOP-详解"><a href="#XML-配置-AOP-详解" class="headerlink" title="XML 配置 AOP 详解"></a><strong>XML 配置 AOP 详解</strong></h3><p>切点表达式的写法</p><p>表达式语法：</p><ul><li><p>execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br>访问修饰符可以省略</p></li><li><p>返回值类型、包名、类名、方法名可以使用星号* 代表任意</p></li><li><p>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p></li><li><p>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.aop.Target.method())</span><br><span class="line">execution(<span class="keyword">void</span> com.itheima.aop.Target.*(..))</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><p>通知的类型</p><p>通知的配置语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:通知类型</span> <span class="attr">method</span>=<span class="string">“切面类中方法名”</span> <span class="attr">pointcut</span>=<span class="string">“切点表达式</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">aop:通知类型</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0e98123e1b234c52bf38a08ce2e7deaf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Proceeding JoinPoint:  正在执行的连接点===切点</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常抛出增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面：切点+通知 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切点表达式的抽取</p><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 抽取切点表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.terence.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面：切点+通知 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解的-AOP-开发"><a href="#基于注解的-AOP-开发" class="headerlink" title="基于注解的 AOP 开发"></a>基于注解的 AOP 开发</h2><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a><strong>快速入门</strong></h3><p>基于注解的 aop 开发步骤：</p><p>创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切面类（内部有增强方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将目标类和切面类的对象创建权交给 spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在切面类中使用注解配置织入关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在配置文件中开启组件扫描和 AOP 的自动代理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.terence.anno&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解配置-AOP-详解"><a href="#注解配置-AOP-详解" class="headerlink" title="注解配置 AOP 详解"></a><strong>注解配置 AOP 详解</strong></h3><p>注解通知的类型</p><p>通知的配置语法：@通知注解(“切点表达式”)</p><p><img src="https://img-blog.csdnimg.cn/6fdbec921d3e46ee838b88297e5063cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注当前MyAspect是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//配置前置通知</span></span><br><span class="line">    <span class="comment">//@Before(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置后置通知</span></span><br><span class="line">    <span class="comment">//@AfterReturning(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常抛出增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置最终通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切点表达式的抽取</p><p>同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut 注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.terence.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPoint</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;MyAspect.myPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execution-com-xxx-分解下如下"><a href="#execution-com-xxx-分解下如下" class="headerlink" title="execution(* com.xxx.*.*(..) 分解下如下"></a><strong>execution(* com.xxx.*.*(..) 分解下如下</strong></h3><p>从左到右依次是：</p><p>execution(): 表达式主体。<br>第一个<em>号：表示返回类型，</em>号表示所有的类型。<br>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl 包、子孙包下所有类的方法，_号表示所有的类。<br>_(..):最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p><h2 id="JointPoint-和-ProceedingJoinPoint-区别"><a href="#JointPoint-和-ProceedingJoinPoint-区别" class="headerlink" title="JointPoint 和 ProceedingJoinPoint 区别"></a>JointPoint 和 ProceedingJoinPoint 区别</h2><h4 id="JointPoint"><a href="#JointPoint" class="headerlink" title="JointPoint"></a>JointPoint</h4><p>通过 JpointPoint 对象可以获取到下面信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 返回目标对象，即被代理的对象</span><br><span class="line">Object <span class="title function_">getTarget</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"># 返回切入点的参数</span><br><span class="line">Object[] getArgs();</span><br><span class="line"></span><br><span class="line"># 返回切入点的Signature 方法</span><br><span class="line">Signature <span class="title function_">getSignature</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"># 返回切入的类型，比如method-call，field-get等等，感觉不重要</span><br><span class="line"> String <span class="title function_">getKind</span><span class="params">()</span>;</span><br><span class="line">#可以发挥反射的功能获取关于类的任何信息，例如获取类名如下</span><br><span class="line"> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br></pre></td></tr></table></figure><h4 id="ProceedingJoinPoint"><a href="#ProceedingJoinPoint" class="headerlink" title="ProceedingJoinPoint"></a>ProceedingJoinPoint</h4><p>Proceedingjoinpoint 继承了 JoinPoint。是在 JoinPoint 的基础上暴露出 proceed 这个方法。proceed 很重要，这个是 aop 代理链执行的方法。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的</span><br></pre></td></tr></table></figure><p>暴露出这个方法，就能支持 aop:around 这种切面（而其他的几种切面只需要用到 JoinPoint，，这也是环绕通知和前置、后置通知方法的一个最大区别。这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。建议看一下 JdkDynamicAopProxy 的 invoke 方法，了解一下代理链的执行原理。</p><p><strong>注：ProceedingJoinPoint is only supported for around advice</strong></p><h1 id="JdbcTemplate-基本使用"><a href="#JdbcTemplate-基本使用" class="headerlink" title="JdbcTemplate 基本使用"></a>JdbcTemplate 基本使用</h1><h2 id="JdbcTemplate-基本使用-概述-了解"><a href="#JdbcTemplate-基本使用-概述-了解" class="headerlink" title="JdbcTemplate 基本使用-概述(了解)"></a>JdbcTemplate 基本使用-概述(了解)</h2><p>JdbcTemplate 是 spring 框架中提供的一个对象，是对原始繁琐的 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类。例如：操作关系型数据的 JdbcTemplate 和 HibernateTemplate，操作 nosql 数据库的 RedisTemplate，操作消息队列的 JmsTemplate 等等。</p><h2 id="JdbcTemplate-基本使用-开发步骤-理解"><a href="#JdbcTemplate-基本使用-开发步骤-理解" class="headerlink" title="JdbcTemplate 基本使用-开发步骤(理解)"></a>JdbcTemplate 基本使用-开发步骤(理解)</h2><p>导入 spring-jdbc 和 spring-tx 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- C3P0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建数据库表和实体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `name` varchar(50) NOT NULL COMMENT &#x27;名称&#x27;,</span><br><span class="line">  `money` double DEFAULT NULL COMMENT &#x27;存款&#x27;,</span><br><span class="line">  PRIMARY KEY (`name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.terence.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(String money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&#x27;&quot;</span> + money + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 JdbcTemplate 对象</p><p>执行数据库操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试JdbcTemplate开发步骤</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://192.168.1.55:3306/terence_db&quot;</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;646453&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//设置数据源对象  知道数据库在哪</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account values(?,?)&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JdbcTemplate-基本使用-spring-产生模板对象"><a href="#JdbcTemplate-基本使用-spring-产生模板对象" class="headerlink" title="JdbcTemplate 基本使用-spring 产生模板对象"></a>JdbcTemplate 基本使用-spring 产生模板对象</h2><p>我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource 的创建权也交给 Spring，在 Spring 容器内部将数据源 DataSource 注入到 JdbcTemplate 模版对象中,然后通过 Spring 容器获得 JdbcTemplate 对象来执行操作。抽取 jdbc.properties：</p><p>将数据库的连接信息抽取到外部配置文件中，和 spring 的配置文件分离开，有利于后期维护</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.1.55:3306/terence_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">646453</span></span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载jdbc.properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--jdbc模板对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试Spring产生jdbcTemplate对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> app.getBean(JdbcTemplate.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account values(?,?)&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    System.out.println(row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate-基本使用-常用操作-更新操作-应用"><a href="#JdbcTemplate-基本使用-常用操作-更新操作-应用" class="headerlink" title="JdbcTemplate 基本使用-常用操作-更新操作(应用)"></a>JdbcTemplate 基本使用-常用操作-更新操作(应用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCRUDTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=? where name=?&quot;</span>,<span class="number">10000</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;delete from account where name=?&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate-基本使用-常用操作-查询操作-应用"><a href="#JdbcTemplate-基本使用-常用操作-查询操作-应用" class="headerlink" title="JdbcTemplate 基本使用-常用操作-查询操作(应用)"></a>JdbcTemplate 基本使用-常用操作-查询操作(应用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCRUDTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>, Long.class);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from account where name=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">&quot;select * from account&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class));</span><br><span class="line">        System.out.println(accountList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程式事务控制相关对象"><a href="#编程式事务控制相关对象" class="headerlink" title="编程式事务控制相关对象"></a>编程式事务控制相关对象</h1><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a><strong>PlatformTransactionManager</strong></h2><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p><p><img src="https://img-blog.csdnimg.cn/42023939b94e4073a39fccd2067c7c05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>注意：</p><p>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，</p><p>例如：</p><p>Dao 层技术是 jdbc 或 mybatis 时：</p><p>org.springframework.jdbc.datasource.DataSourceTransactionManager</p><p>Dao 层技术是 hibernate 时：</p><p>org.springframework.orm.hibernate5.HibernateTransactionManager</p><h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p><p><img src="https://img-blog.csdnimg.cn/c134e3c8493d41289975ff9fb553d588.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p><ul><li><p>ISOLATION_DEFAULT 数据库的默认隔离级别</p></li><li><p>ISOLATION_READ_UNCOMMITTED 未提交读取，都不能解决</p></li><li><p>ISOLATION_READ_COMMITTED 已提交读取，可以解决脏读</p></li><li><p>ISOLATION_REPEATABLE_READ 可重复读，可以解决不可重复读</p></li><li><p>ISOLATION_SERIALIZABLE 序列化，全部可以解决，但是效率低相当于缩表</p></li></ul><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><ul><li><p>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</p></li><li><p>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</p></li><li><p>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p></li><li><p>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p></li><li><p>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p></li><li><p>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p></li><li><p>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p></li><li><p>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p></li><li><p>是否只读：建议查询时设置为只读</p></li></ul><h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p><p><img src="https://img-blog.csdnimg.cn/b839de152ba64af7ac0288c499aadc4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVGVyZW5jZSBXYW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h1 id="基于-XML-的声明式事务控制"><a href="#基于-XML-的声明式事务控制" class="headerlink" title="基于 XML 的声明式事务控制"></a>基于 XML 的声明式事务控制</h1><h2 id="什么是声明式事务控制"><a href="#什么是声明式事务控制" class="headerlink" title="什么是声明式事务控制"></a>什么是声明式事务控制</h2><p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p><p>声明式事务处理的作用</p><ul><li><p>事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p></li><li><p>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p></li></ul><p>注意：Spring 声明式事务控制底层就是 AOP。</p><h2 id="声明式事务控制的实现"><a href="#声明式事务控制的实现" class="headerlink" title="声明式事务控制的实现"></a>声明式事务控制的实现</h2><p>声明式事务控制明确事项：</p><ul><li>谁是切点？ //被增强的方法</li><li>谁是通知？ //事务</li><li>配置切面？ //将切点和通知进行 AOP 的配置</li></ul><p>引入 tx 命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置事务增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置事务的属性信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置事务 AOP 织入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.terence.service.impl.*.*(..))&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.terence.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试事务控制转账业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">    accountDao.out(outMan,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    accountDao.in(inMan,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> app.getBean(AccountService.class);</span><br><span class="line">        accountService.transfer(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切点方法的事务参数的配置"><a href="#切点方法的事务参数的配置" class="headerlink" title="切点方法的事务参数的配置"></a>切点方法的事务参数的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置事务的属性信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<a href="tx:method">tx:method</a> 代表切点方法的事务参数的配置，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：切点方法名称</li><li>isolation:事务的隔离级别</li><li>propogation：事务的传播行为</li><li>timeout：超时时间</li><li>read-only：是否只读</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p><strong>声明式事务控制的配置要点</strong></p><ul><li>平台事务管理器配置</li><li>事务通知的配置</li><li>事务 aop 织入的配置</li></ul><h1 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h1><h2 id="使用注解配置声明式事务控制"><a href="#使用注解配置声明式事务控制" class="headerlink" title="使用注解配置声明式事务控制"></a>使用注解配置声明式事务控制</h2><ol><li>编写 AccoutDao</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">(String outMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money-? where name=?&quot;</span>,money,outMan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money+? where name=?&quot;</span>,money,inMan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 AccoutService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        accountDao.out(outMan,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.in(inMan,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Transactional(isolation = Isolation.DEFAULT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写 applicationContext.xml 配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.terence&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--事物的注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注解配置声明式事务控制解析"><a href="#注解配置声明式事务控制解析" class="headerlink" title="注解配置声明式事务控制解析"></a>注解配置声明式事务控制解析</h2><p>① 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p><p>② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p><p>③ 使用在方法上，不同的方法可以采用不同的事务参数配置。</p><p>④Xml 配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt;</p><h2 id="知识要点-1"><a href="#知识要点-1" class="headerlink" title="知识要点"></a>知识要点</h2><p><strong>注解声明式事务控制的配置要点</strong></p><ul><li>平台事务管理器配置（xml 方式）</li><li>事务通知的配置（@Transactional 注解配置）</li><li>事务注解驱动的配置 &lt;tx:annotation-driven /&gt;</li></ul>]]></content>
    
    
    <summary type="html">SpringMVC</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分页查询</title>
    <link href="http://example.com/2022/10/16/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/10/16/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-10-16T07:00:00.000Z</published>
    <updated>2022-10-16T07:34:54.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预热知识：分页中的关键字"><a href="#预热知识：分页中的关键字" class="headerlink" title="预热知识：分页中的关键字"></a>预热知识：分页中的关键字</h1><ul><li>index：当前页数据的起始索引</li><li>pageSize：每页显示的条数</li><li>pageNum：当前页的页码</li><li>count：总记录数</li><li>totalPage：总页数</li></ul><p><strong>例</strong>： pageSize=4，pageNum=1，index=0 ，每一页四个数据，在第一页，当前页的起始索引是0，limit的写法就是limit 0,4  （索引是从0开始的）</p><p>​        pageSize=4，pageNum=3，index=8， 每一页四个数据，在第三页，当前页的起始索引是8，limit的写法就是limit 8,4</p><p><strong>总结</strong>： pageSize=i ，paheNum=j ，index=i*（j-1）  limit写法就是limit index，pageSize</p><p>导航分页设置： <a>首页 </a>  <a>上一页</a>  1,2,3,4  <a>下一页</a>   <a>末页</a></p><h1 id="Mybatis实现分页查询："><a href="#Mybatis实现分页查询：" class="headerlink" title="Mybatis实现分页查询："></a>Mybatis实现分页查询：</h1><h2 id="mybatis分页插件介绍："><a href="#mybatis分页插件介绍：" class="headerlink" title="mybatis分页插件介绍："></a>mybatis分页插件介绍：</h2><ul><li>分页可以将很多条结果进行分页显示。</li><li>如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。</li><li>需要明确当前是第几页，这一页中显示多少条结果。</li></ul><p>MyBatis分页插件总结<br>        1. 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。<br>        2. 2.PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。</p><h2 id="mybatis分页插件的使用-SpringBoot版本"><a href="#mybatis分页插件的使用-SpringBoot版本" class="headerlink" title="mybatis分页插件的使用(SpringBoot版本)"></a>mybatis分页插件的使用(SpringBoot版本)</h2><p>如果查看SpringMVC版本请查看：</p><p>[]: <a href="https://446773160.github.io/2022/10/14/MyBatis%E7%AC%94%E8%AE%B0/#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">https://446773160.github.io/2022/10/14/MyBatis%E7%AC%94%E8%AE%B0/#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4</a>    “SpringMVC分页”</p><h3 id="1-导入与PageHelper的jar包"><a href="#1-导入与PageHelper的jar包" class="headerlink" title="1.导入与PageHelper的jar包"></a>1.导入与PageHelper的jar包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意spring-boot-starter-parent版本最好是2.5.5,pagehelper-spring-boot-starter版本为1.2.10</span></span><br><span class="line"><span class="comment">否则会抛出Error creating bean with name com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration异常</span></span><br><span class="line"><span class="comment">这是因为版本兼容问题，因为现在一般都采用mybatis-plus进行分页且mybatis-plus有内置分页插件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-在yml里面进行配置"><a href="#2-在yml里面进行配置" class="headerlink" title="2.在yml里面进行配置"></a>2.在yml里面进行配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#分页插件</span><br><span class="line">pagehelper:</span><br><span class="line">  helper-dialect: mysql</span><br><span class="line">  reasonable: <span class="literal">true</span></span><br><span class="line">  support-methods-arguments: <span class="literal">true</span></span><br><span class="line">  params: count=countSql</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//设置PageNum和PageSize</span></span><br><span class="line">List&lt;User&gt; all = userMapper.findAll();</span><br><span class="line"><span class="comment">//all.forEach(e-&gt; System.out.println(e));</span></span><br><span class="line">all.forEach(System.out::println);<span class="comment">//采用引用方法遍历集合</span></span><br></pre></td></tr></table></figure><h1 id="Mybatis-plus实现分页查询："><a href="#Mybatis-plus实现分页查询：" class="headerlink" title="Mybatis-plus实现分页查询："></a>Mybatis-plus实现分页查询：</h1><h2 id="mybatis-plus实现分类步骤："><a href="#mybatis-plus实现分类步骤：" class="headerlink" title="mybatis-plus实现分类步骤："></a>mybatis-plus实现分类步骤：</h2><h3 id="导入mybatis的包"><a href="#导入mybatis的包" class="headerlink" title="导入mybatis的包"></a>导入mybatis的包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建mybatis-plus配置类"><a href="#创建mybatis-plus配置类" class="headerlink" title="创建mybatis-plus配置类"></a>创建mybatis-plus配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@author</span> Liao.sc</span><br><span class="line"> * <span class="meta">@version</span> <span class="number">1.0</span></span><br><span class="line"> * <span class="meta">@date</span> <span class="number">2022</span>/<span class="number">8</span>/<span class="number">7</span> <span class="number">21</span>:<span class="number">40</span></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     * mybatis-plus的配置,实现分页拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>();</span><br><span class="line">        paginationInnerInterceptor.setDbType(DbType.MYSQL);</span><br><span class="line">        paginationInnerInterceptor.setOverflow(<span class="literal">true</span>);</span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试类："><a href="#编写测试类：" class="headerlink" title="编写测试类："></a>编写测试类：</h3><p><strong>User类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao.sc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/6 15:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>mapper接口编写</strong></p><p>mapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; <span class="title function_">selectPage</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page)</span>;</span><br></pre></td></tr></table></figure><p>mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPage&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; userPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//模拟前端传回的数据1,2</span></span><br><span class="line">Page&lt;User&gt; users = userMapper.selectPage(userPage);</span><br><span class="line">System.out.println(users.getRecords());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">mybatis和mybatis-plus分页查询</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://example.com/2022/10/15/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://example.com/2022/10/15/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2022-10-15T08:00:00.000Z</published>
    <updated>2022-10-16T07:48:17.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Redis入门"><a href="#一、Redis入门" class="headerlink" title="一、Redis入门"></a>一、Redis入门</h1><h2 id="1-认识NoSQL"><a href="#1-认识NoSQL" class="headerlink" title="1.认识NoSQL"></a>1.认识NoSQL</h2><h3 id="1-1-什么是NoSQL"><a href="#1-1-什么是NoSQL" class="headerlink" title="1.1    什么是NoSQL"></a>1.1    什么是NoSQL</h3><hr><ul><li>NoSQL最常见的解释是”<code>non-relational</code>“， 很多人也说它是”<em><strong>Not Only SQL</strong></em>“</li><li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li><li>区别于关系数据库，它们不保证关系数据的ACID特性</li><li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li><li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li></ul><h3 id="1-2-NoSQL与SQL的差异"><a href="#1-2-NoSQL与SQL的差异" class="headerlink" title="1.2    NoSQL与SQL的差异"></a>1.2    NoSQL与SQL的差异</h3><hr><table><thead><tr><th align="center"></th><th align="center">SQL</th><th align="center">NoSQL</th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">结构化</td><td align="center">非结构化</td></tr><tr><td align="center">数据关联</td><td align="center">关联的</td><td align="center">无关联的</td></tr><tr><td align="center">查询方式</td><td align="center">SQL查询</td><td align="center">非SQL</td></tr><tr><td align="center">事务特性</td><td align="center">ACID</td><td align="center">BASE</td></tr><tr><td align="center">存储方式</td><td align="center">磁盘</td><td align="center">内存</td></tr><tr><td align="center">扩展性</td><td align="center">垂直</td><td align="center">水平</td></tr><tr><td align="center">使用场景</td><td align="center">1）数据结构固定<br>2）相关业务对数据安全性、一致性要求较高</td><td align="center">1）数据结构不固定<br>2）对一致性、安全性要求不高<br>3）对性能要求</td></tr></tbody></table><h2 id="2-认识Redis"><a href="#2-认识Redis" class="headerlink" title="2.认识Redis"></a>2.认识Redis</h2><blockquote><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p></blockquote><p><strong>Redis的特征：</strong></p><ul><li>键值（<code>key-value</code>）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="3-安装Redis"><a href="#3-安装Redis" class="headerlink" title="3.安装Redis"></a>3.安装Redis</h2><h3 id="3-1-前置准备"><a href="#3-1-前置准备" class="headerlink" title="3.1    前置准备"></a>3.1    前置准备</h3><hr><blockquote><p>本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。</p><p>Ps：由于提供的CentOS操作系统为mini版，因此需要自行配置网络，不会配置的请联系我，如果您使用的是自己购买的服务器，请提前开放<code>6379</code>端口，避免后续出现的莫名其妙的错误！</p></blockquote><ul><li><p><strong>虚拟机</strong>：<a href="https://pan.baidu.com/s/1Zn13h9G7MtSgz-xdkQFeJg?pwd=1234">VMware16</a></p></li><li><p><strong>操作系统</strong>：<a href="https://pan.baidu.com/s/1SiYip29cYqiNBqjGGV0JgA?pwd=1234">CentOS-7-x86_64-Minimal-1708</a></p></li><li><p><strong>Redis</strong>：<a href="https://pan.baidu.com/s/1hsoEz1NTCDCCWZmaiZrIgg?pwd=1234">redis-6.2.6.tar</a></p></li><li><p><strong>xShell及xFtp</strong>：<a href="https://www.xshell.com/zh/free-for-home-school/">https://www.xshell.com/zh/free-for-home-school/</a></p></li></ul><h3 id="3-2-安装Redis依赖"><a href="#3-2-安装Redis依赖" class="headerlink" title="3.2    安装Redis依赖"></a>3.2    安装Redis依赖</h3><hr><blockquote><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p><strong>安装成功如下图所示：</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524181842626.png" alt="image-20220524181842626"></p><h3 id="3-3-正式安装Redis"><a href="#3-3-正式安装Redis" class="headerlink" title="3.3    正式安装Redis"></a>3.3    正式安装Redis</h3><hr><ul><li><p><strong>将<code>redis-6.2.6.tar</code>上传至<code>/usr/local/src</code>目录</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524185659727.png" alt="image-20220524185659727"></p></li><li><p><strong>在xShell中<code>cd</code>到<code>/usr/local/src</code>目录执行以下命令进行解压操作</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>解压成功后依次执行以下命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p><strong>安装成功后打开/usr/local/bin目录（该目录为Redis默认的安装目录）</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524190400547.png" alt="image-20220524190400547"></p></li></ul><h2 id="4-启动Redis"><a href="#4-启动Redis" class="headerlink" title="4.启动Redis"></a>4.启动Redis</h2><blockquote><p>Redis的启动方式有很多种，例如：<strong>前台启动</strong>、<strong>后台启动</strong>、<strong>开机自启</strong></p></blockquote><h3 id="4-1-前台启动（不推荐）"><a href="#4-1-前台启动（不推荐）" class="headerlink" title="4.1    前台启动（不推荐）"></a>4.1    前台启动（不推荐）</h3><hr><blockquote><p><strong>这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</strong></p></blockquote><ul><li><p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure></li><li><p><strong>启动成功如下图所示</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524191137983.png" alt="image-20220524191137983"></p></li></ul><h3 id="4-2-后台启动（不推荐）"><a href="#4-2-后台启动（不推荐）" class="headerlink" title="4.2    后台启动（不推荐）"></a>4.2    后台启动（不推荐）</h3><hr><blockquote><p><strong>如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</strong></p></blockquote><ul><li><p><strong>因为我们要修改配置文件，因此我们需要先将原文件备份一份</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure></li><li><p><strong>然后修改<code>redis.conf</code>文件中的一些配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span> </span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass 1325</span><br></pre></td></tr></table></figure></li><li><p><strong>Redis其他常用配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="built_in">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>停止Redis服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过kill命令直接杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 redis进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -a 来指定密码</span></span><br><span class="line">redis-cli -a 132537 shutdown</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-开机自启（推荐）"><a href="#4-3-开机自启（推荐）" class="headerlink" title="4.3    开机自启（推荐）"></a>4.3    开机自启（推荐）</h3><hr><blockquote><p><strong>我们也可以通过配置来实现开机自启</strong></p></blockquote><ul><li><p><strong>首先，新建一个系统服务文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure></li><li><p><strong>将以下命令粘贴进去</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p><strong>然后重载系统服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p><strong>现在，我们可以用下面这组命令来操作redis了</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p><strong>执行下面的命令，可以让redis开机自启</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、Redis常见命令"><a href="#二、Redis常见命令" class="headerlink" title="二、Redis常见命令"></a>二、Redis常见命令</h1><blockquote><p>我们可以通过Redis的中文文档：<a href="http://www.redis.cn/commands.html%EF%BC%8C%E6%9D%A5%E5%AD%A6%E4%B9%A0%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4%E3%80%82">http://www.redis.cn/commands.html，来学习各种命令。</a></p><p>也可以通过菜鸟教程官网来学习：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p></blockquote><h2 id="1-Redis数据结构介绍"><a href="#1-Redis数据结构介绍" class="headerlink" title="1.Redis数据结构介绍"></a>1.Redis数据结构介绍</h2><blockquote><p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524205926164.png" alt="image-20220524205926164"></p><h2 id="2-通用命令"><a href="#2-通用命令" class="headerlink" title="2.通用命令"></a>2.通用命令</h2><blockquote><p><strong>通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示</strong></p></blockquote><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">KEYS</td><td align="center">查看符合模板的所有key，不建议在生产环境设备上使用</td></tr><tr><td align="center">DEL</td><td align="center">删除一个指定的key</td></tr><tr><td align="center">EXISTS</td><td align="center">判断key是否存在</td></tr><tr><td align="center">EXPIRE</td><td align="center">给一个key设置有效期，有效期到期时该key会被自动删除</td></tr><tr><td align="center">TTL</td><td align="center">查看一个KEY的剩余有效期</td></tr></tbody></table><p><strong>可以通过<code>help [command] </code>可以查看一个命令的具体用法！</strong></p><h2 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3.String类型"></a>3.String类型</h2><blockquote><p><strong>String类型，也就是字符串类型，是Redis中最简单的存储类型。</strong></p></blockquote><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><blockquote><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过<strong>512m</strong>.</p></blockquote><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">msg</td><td align="center">hello world</td></tr><tr><td align="center">num</td><td align="center">10</td></tr><tr><td align="center">score</td><td align="center">92.5</td></tr></tbody></table><blockquote><p><strong>String的常见命令有如下表格所示</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SET</td><td align="center">添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td align="center">GET</td><td align="center">根据key获取String类型的value</td></tr><tr><td align="center">MSET</td><td align="center">批量添加多个String类型的键值对</td></tr><tr><td align="center">MGET</td><td align="center">根据多个key获取多个String类型的value</td></tr><tr><td align="center">INCR</td><td align="center">让一个整型的key自增1</td></tr><tr><td align="center">INCRBY</td><td align="center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td align="center">INCRBYFLOAT</td><td align="center">让一个浮点类型的数字自增并指定步长</td></tr><tr><td align="center">SETNX</td><td align="center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td align="center"><strong>SETEX</strong></td><td align="center">添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table><blockquote><p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 <code>heima</code>，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p><ul><li><strong>user</strong>相关的key：<code>heima:user:1</code></li><li><strong>product</strong>相关的key：<code>heima:product:1</code></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">heima:user:1</td><td align="center">{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td align="center">heima:product:1</td><td align="center">{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="4-Hash类型"><a href="#4-Hash类型" class="headerlink" title="4.Hash类型"></a>4.Hash类型</h2><blockquote><p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的<code>HashMap</code>结构。</strong></p></blockquote><ul><li><p><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525001227167.png" alt="image-20220525001227167"  /></li><li><p><strong>Hash的常见命令有：</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HSET key field value</td><td align="center">添加或者修改hash类型key的field的值</td></tr><tr><td align="center">HGET key field</td><td align="center">获取一个hash类型key的field的值</td></tr><tr><td align="center">HMSET</td><td align="center">hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td></tr><tr><td align="center">HMGET</td><td align="center">批量获取多个hash类型key的field的值</td></tr><tr><td align="center">HGETALL</td><td align="center">获取一个hash类型的key中的所有的field和value</td></tr><tr><td align="center">HKEYS</td><td align="center">获取一个hash类型的key中的所有的field</td></tr><tr><td align="center">HVALS</td><td align="center">获取一个hash类型的key中的所有的value</td></tr><tr><td align="center">HINCRBY</td><td align="center">让一个hash类型key的字段值自增并指定步长</td></tr><tr><td align="center">HSETNX</td><td align="center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table></li></ul><h2 id="5-List类型"><a href="#5-List类型" class="headerlink" title="5.List类型"></a>5.List类型</h2><blockquote><p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p></blockquote><p><strong>特征也与<code>LinkedList</code>类似：</strong></p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p><blockquote><p><strong>List的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LPUSH key  element …</td><td align="center">向列表左侧插入一个或多个元素</td></tr><tr><td align="center">LPOP key</td><td align="center">移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td align="center"><strong>RPUSH key  element …</strong></td><td align="center">向列表右侧插入一个或多个元素</td></tr><tr><td align="center">RPOP key</td><td align="center">移除并返回列表右侧的第一个元素</td></tr><tr><td align="center">LRANGE key star end</td><td align="center">返回一段角标范围内的所有元素</td></tr><tr><td align="center">BLPOP和BRPOP</td><td align="center">与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/new.gif" alt="new"></p><blockquote><p><strong>思考问题</strong></p></blockquote><ul><li><p><strong>如何利用List结构模拟一个栈?</strong></p><ul><li>先进后出，入口和出口在同一边</li></ul></li><li><p><strong>如何利用List结构模拟一个队列?</strong></p><ul><li>先进先出，入口和出口在不同边</li></ul></li><li><p><strong>如何利用List结构模拟一个阻塞队列?</strong></p><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul></li></ul><h2 id="6-Set类型"><a href="#6-Set类型" class="headerlink" title="6.Set类型"></a>6.Set类型</h2><blockquote><p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</strong></p></blockquote><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><blockquote><p><strong>Set的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SADD key member …</td><td align="center">向set中添加一个或多个元素</td></tr><tr><td align="center">SREM key member …</td><td align="center">移除set中的指定元素</td></tr><tr><td align="center">SCARD key</td><td align="center">返回set中元素的个数</td></tr><tr><td align="center">SISMEMBER key member</td><td align="center">判断一个元素是否存在于set中</td></tr><tr><td align="center">SMEMBERS</td><td align="center">获取set中的所有元素</td></tr><tr><td align="center">SINTER key1 key2 …</td><td align="center">求key1与key2的交集</td></tr><tr><td align="center">SDIFF key1 key2 …</td><td align="center">求key1与key2的差集</td></tr><tr><td align="center">SUNION key1 key2 ..</td><td align="center">求key1和key2的并集</td></tr></tbody></table><blockquote><p><strong>交集、差集、并集图示</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525112632214.png" alt="image-20220525112632214"></p><h2 id="7-SortedSet类型"><a href="#7-SortedSet类型" class="headerlink" title="7.SortedSet类型"></a>7.SortedSet类型</h2><blockquote><p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p></blockquote><p><strong>SortedSet具备下列特性：</strong></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><blockquote><p><strong>SortedSet的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ZADD key score member</td><td align="center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td align="center">ZREM key member</td><td align="center">删除sorted set中的一个指定元素</td></tr><tr><td align="center">ZSCORE key member</td><td align="center">获取sorted set中的指定元素的score值</td></tr><tr><td align="center">ZRANK key member</td><td align="center">获取sorted set 中的指定元素的排名</td></tr><tr><td align="center">ZCARD key</td><td align="center">获取sorted set中的元素个数</td></tr><tr><td align="center">ZCOUNT key min max</td><td align="center">统计score值在给定范围内的所有元素的个数</td></tr><tr><td align="center">ZINCRBY key increment member</td><td align="center">让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td align="center">ZRANGE key min max</td><td align="center">按照score排序后，获取指定排名范围内的元素</td></tr><tr><td align="center">ZRANGEBYSCORE key min max</td><td align="center">按照score排序后，获取指定score范围内的元素</td></tr><tr><td align="center">ZDIFF、ZINTER、ZUNION</td><td align="center">求差集、交集、并集</td></tr></tbody></table><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加<code>REV</code>即可</strong></p><h1 id="三、Redis客户端"><a href="#三、Redis客户端" class="headerlink" title="三、Redis客户端"></a>三、Redis客户端</h1><blockquote><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p></blockquote><ul><li><strong>命令行客户端</strong></li><li><strong>图形化桌面客户端</strong></li><li><strong>编程客户端</strong></li></ul><h2 id="1-命令行客户端"><a href="#1-命令行客户端" class="headerlink" title="1.命令行客户端"></a>1.命令行客户端</h2><ul><li><p><strong>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure></li><li><p><strong>其中常见的<code>options</code>有：</strong></p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 132537</code>：指定redis的访问密码 </li></ul></li><li><p><strong>其中的<code>commonds</code>就是Redis的操作命令，例如：</strong></p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li><li>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</li></ul></li></ul><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524201258092.png" alt="image-20220524201258092"></p><h2 id="2-图形化客户端"><a href="#2-图形化客户端" class="headerlink" title="2.图形化客户端"></a>2.图形化客户端</h2><blockquote><p>下载地址：<a href="https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234">https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234</a> </p></blockquote><ul><li><p><strong>安装图形化客户端</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装步骤过于简单不再演示</span><br></pre></td></tr></table></figure></li><li><p><strong>如何连接到Redis</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524202853286.png" alt="image-20220524202853286" style="zoom:80%;" /></li><li><p><strong>连接成功后如图所示</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524203745436.png" alt="image-20220524203745436" style="zoom:80%;" /></li></ul><h2 id="3-Java客户端"><a href="#3-Java客户端" class="headerlink" title="3.Java客户端"></a>3.Java客户端</h2><h3 id="3-1-Jedis快速入门"><a href="#3-1-Jedis快速入门" class="headerlink" title="3.1    Jedis快速入门"></a>3.1    Jedis快速入门</h3><hr><blockquote><p>Jedis的官网地址： <a href="https://github.com/redis/jedis%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A">https://github.com/redis/jedis，我们先来个快速入门：</a></p></blockquote><ul><li><p><strong>新建一个Maven工程并引入以下依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Jedis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入单元测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类并与Redis建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span> <span class="comment">//被该注解修饰的方法每次执行其他方法前自动执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取连接</span></span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 2. 设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 选择库（默认是下标为0的库）</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写一个操作数据的方法（这里以操作String类型为例）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.往redis中存放一条String类型的数据并获取返回结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;https://www.oz6.cn&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从redis中获取一条数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;url = &quot;</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后不要忘记编写一个释放资源的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span> <span class="comment">//被该注解修饰的方法会在每次执行其他方法后执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行<code>testString()</code>方法后测试结果如图所示</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525131017888.png" alt="image-20220525131017888"></p></li></ul><h3 id="3-2-Jedis连接池"><a href="#3-2-Jedis连接池" class="headerlink" title="3.2    Jedis连接池"></a>3.2    Jedis连接池</h3><hr><blockquote><p><strong>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-SpringDataRedis介绍"><a href="#3-3-SpringDataRedis介绍" class="headerlink" title="3.3    SpringDataRedis介绍"></a>3.3    SpringDataRedis介绍</h3><hr><blockquote><p><strong>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></strong></p><p><strong>官网地址</strong>：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p></blockquote><ul><li>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</li><li>提供了<code>RedisTemplate</code>统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><blockquote><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png" alt="image-20220525140217446"></p><h3 id="3-4-SpringDataRedis快速入门"><a href="#3-4-SpringDataRedis快速入门" class="headerlink" title="3.4 SpringDataRedis快速入门"></a>3.4 SpringDataRedis快速入门</h3><hr><blockquote><p><strong><code>SpringBoot</code>已经提供了对<code>SpringDataRedis</code>的支持，使用非常简单</strong></p></blockquote><ul><li><p><strong>首先新建一个Spring Boot工程</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525141608974.png" alt="image-20220525141608974"></p></li><li><p><strong>然后引入连接池依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写配置文件<code>application.yml</code>（连接池的配置在实际开发中是根据需求来的）</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.230</span><span class="number">.88</span> <span class="comment">#指定redis所在的host</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>  <span class="comment">#指定redis的端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span>  <span class="comment">#设置redis密码</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类执行测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1.通过RedisTemplate获取操作String类型的ValueOperations对象</span></span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// 2.插入一条数据</span></span><br><span class="line">ops.set(<span class="string">&quot;blogName&quot;</span>,<span class="string">&quot;Vz-Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">blogName</span> <span class="operator">=</span> (String) ops.get(<span class="string">&quot;blogName&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;blogName = &quot;</span> + blogName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-RedisSerializer配置"><a href="#3-5-RedisSerializer配置" class="headerlink" title="3.5    RedisSerializer配置"></a>3.5    RedisSerializer配置</h3><hr><blockquote><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png" alt="image-20220525170205272"></p><p><strong>缺点：</strong></p><ul><li>可读性差</li><li>内存占用较大</li></ul><blockquote><p><strong>那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。</strong></p></blockquote><ul><li><p><strong>编写一个配置类<code>RedisConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String ,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建序列化对象</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置key和hashKey采用String的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.设置value和hashValue采用json的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>此时我们已经将RedisTemplate的key设置为<code>String序列化</code>，value设置为<code>Json序列化</code>的方式，再来执行方法测试</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170925364.png" alt="image-20220525170925364"></p></li><li><p><strong>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525171340322.png" alt="image-20220525171340322"></p><p>尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。</p><p>如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>那么我们如何解决这个问题呢？我们可以通过下文的<code>StringRedisTemplate</code>来解决这个问题。</p></li></ul><h3 id="3-6-StringRedisTemplate"><a href="#3-6-StringRedisTemplate" class="headerlink" title="3.6    StringRedisTemplate"></a>3.6    StringRedisTemplate</h3><hr><blockquote><p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png" alt="image-20220525172001057"></p><blockquote><p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p></blockquote><ul><li><p><strong>我们可以直接编写一个测试类使用StringRedisTemplate来执行以下方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTemplateTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"><span class="comment">// 1.创建一个Json序列化对象</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 2.将要存入的对象通过Json序列化对象转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson1</span> <span class="operator">=</span> objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line"><span class="comment">// 3.通过StringRedisTemplate将数据存入redis</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,userJson1);</span><br><span class="line"><span class="comment">// 4.通过key取出value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line"><span class="comment">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(userJson2, User.class);</span><br><span class="line"><span class="comment">// 6.打印结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行完毕回到Redis的图形化客户端查看结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172508234.png" alt="image-20220525172508234"></p></li></ul><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7    总结"></a>3.7    总结</h3><hr><blockquote><p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p></blockquote><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol>]]></content>
    
    
    <summary type="html">Redis</summary>
    
    
    
    
  </entry>
  
</feed>
